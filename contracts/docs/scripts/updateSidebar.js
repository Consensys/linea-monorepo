/* eslint-disable */
// This script is meant to be executed in the root directory of https://github.com/Consensys/doc.linea, which has different linting rules
// The purpose of this script is to modify the sidebars.js file to correctly include the autogenerated smart contract documentation 

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

const SIDEBAR_FILE_PATH = process.env.SIDEBAR_FILE_PATH ?? "sidebars.js";

// Get JSON object from sidebar
const sidebars = require(path.join(__dirname, SIDEBAR_FILE_PATH));

// TYPES
class FolderSidebar {
  type = "category";
  label = "";
  link = null;
  collapsible = true;
  items = [];

  constructor(label = "", collapsible = false) {
    this.label = label;
    this.collapsible = collapsible;
  }
}

// MAIN

main();

function main() {
  // Create and populate smart contract sidebar
  const smartContractsPath = path.join(
    __dirname,
    "docs",
    "api",
    "linea-smart-contracts",
  );

  let smartContractSidebarNode = new FolderSidebar(
    "Linea Smart Contracts",
    true,
  );

  smartContractSidebarNode = getFileTree(
    smartContractSidebarNode,
    smartContractsPath,
    ".mdx",
  );

  // Push smart contract sidebar to main sidebar object
  sidebars?.apiSidebar?.push(smartContractSidebarNode);

  // Create new js file
  const sidebarFileLine1 =
    "/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */";
  const sidebarFileLine2 = "const sidebars =";
  const sidebarFileLineFinal = "module.exports = sidebars;";

  const newSidebarFileContent = `${sidebarFileLine1}\n${sidebarFileLine2}\n${JSON.stringify(sidebars, null, 2)}\n\n${sidebarFileLineFinal}`;

  // Save new js file
  const newSidebarFilePath = path.join(__dirname, "sidebar.tmp.js");

  fs.writeFileSync(newSidebarFilePath, newSidebarFileContent);

  // Lint the file
  lintJSFile(newSidebarFilePath);
}

// HELPER FUNCTIONS

// Recursive function to populate sidebar object for a given folder
function getFileTree(nodePointer, subdirectoryPath, fileExtension) {
  const subdirectoryFileList = fs.readdirSync(subdirectoryPath);

  for (const fileNode of subdirectoryFileList) {
    const filePath = path.join(subdirectoryPath, fileNode);
    const fileMetadata = fs.statSync(filePath);

    // Directory => Create folder node, recurse then add folder node
    if (fileMetadata.isDirectory()) {
      let newFolderNode = new FolderSidebar(fileNode);
      newFolderNode = getFileTree(newFolderNode, filePath, fileExtension);
      nodePointer?.items.push(newFolderNode);

      // Base case *.mdx file => Add relative path
    } else if (fileMetadata.isFile() && fileNode.endsWith(fileExtension)) {
      const relativePath = path.relative(
        path.join(__dirname, "docs"),
        filePath.split(fileExtension)[0],
      );
      nodePointer?.items.push(relativePath);
    }
  }

  return nodePointer;
}

function lintJSFile(filePath) {
  try {
    const cmd = `npx eslint --fix ${filePath}`;
    // Execute command synchronously and route output directly to the current stdout
    execSync(cmd, { stdio: "inherit" });
  } catch (error) {
    console.error(`Error:`, error.message);
    console.error(`Exiting...`);
    process.exit(1);
  }
}
