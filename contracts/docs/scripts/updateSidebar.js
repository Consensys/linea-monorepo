/* eslint-disable */
// This script is meant to be executed in the root directory of https://github.com/Consensys/doc.linea, which has different linting rules
// The purpose of this script is to modify the sidebars.js file to correctly include the autogenerated smart contract documentation 

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// CONSTANTS
const SIDEBAR_FILE_PATH = "sidebars.js";

// IMPORTED OBJECT
const sidebarObject = require(path.join(__dirname, SIDEBAR_FILE_PATH));

// TYPES
class FolderSidebar {
  type = "category";
  label = "";
  link = null;
  collapsible = true;
  items = [];

  constructor(label = "", collapsible = true) {
    this.label = label;
    this.collapsible = collapsible;
  }
}

// MAIN
main();

function main() {
  const smartContractSidebarNode = getSmartContractSidebar();
  sidebarObject?.apiSidebar?.push(smartContractSidebarNode);
  createNewSidebarFile(sidebarObject);
}

// HELPER FUNCTIONS
function getSmartContractSidebar() {
  // Create and populate smart contract sidebar
  const smartContractsPath = path.join(
    __dirname,
    "docs",
    "api",
    "linea-smart-contracts",
  );

  let smartContractSidebar = new FolderSidebar(
    "Linea smart contracts",
    false,
  );

  populateFolderSidebar(
    smartContractSidebar,
    smartContractsPath,
    ".mdx",
  );

  return smartContractSidebar;
}

// Recursive function to populate sidebar object for a given folder
// Essentially we do a depth-first search (DFS) of the folder tree, and populate the sidebar object recursively
// Do note that we mutate the parameter `folderSidebar` throughout the function body
function populateFolderSidebar(folderSidebar, subdirectoryPath, fileExtension) {
  const folderFileList = fs.readdirSync(subdirectoryPath);

  for (const fileNode of folderFileList) {
    const filePath = path.join(subdirectoryPath, fileNode);
    const fileMetadata = fs.statSync(filePath);

    // Directory => Create folder node, recurse then add folder node
    if (fileMetadata.isDirectory()) {
      let newFolderNode = new FolderSidebar(fileNode);
      populateFolderSidebar(newFolderNode, filePath, fileExtension);
      folderSidebar?.items.push(newFolderNode);

      // Base case => *.mdx file => Add relative path
    } else if (fileMetadata.isFile() && fileNode.endsWith(fileExtension)) {
      const relativePath = path.relative(
        path.join(__dirname, "docs"),
        filePath.split(fileExtension)[0],
      );
      folderSidebar?.items.push(relativePath);
    }
    // Not a directory or *.mdx file => Do nothing
  }

  return folderSidebar;
}

function createNewSidebarFile(sidebarObject) {
  // Create new js file
  const sidebarFileLine1 =
    "/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */";
  const sidebarFileLine2 = "const sidebars =";
  const sidebarFileLineFinal = "module.exports = sidebars;";

  const newSidebarFileContent = `${sidebarFileLine1}\n${sidebarFileLine2}\n${JSON.stringify(sidebarObject, null, 2)}\n\n${sidebarFileLineFinal}`;

  // Save new js file
  const newSidebarFilePath = path.join(__dirname, SIDEBAR_FILE_PATH);
  fs.writeFileSync(newSidebarFilePath, newSidebarFileContent);

  lintJSFile(newSidebarFilePath);
}

function lintJSFile(filePath) {
  try {
    const installCmd = `npm install --save-dev --no-save eslint`;
    execSync(installCmd, { stdio: "inherit" });

    const lintCmd = `npx eslint --fix --no-ignore ${filePath}`;
    // Execute command synchronously and route output directly to the current stdout
    execSync(lintCmd, { stdio: "inherit" });
  } catch (error) {
    console.error(`Error:`, error.message);
    console.error(`Exiting...`);
    process.exit(1);
  }
}
