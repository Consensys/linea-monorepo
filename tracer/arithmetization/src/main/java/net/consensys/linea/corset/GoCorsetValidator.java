/*
 * Copyright Consensys Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package net.consensys.linea.corset;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.consensys.linea.corset.CorsetValidator.Result;

/**
 * Responsible for running the command-line <code>go-corset</code> tool to check that a given trace
 * is accepted by the zkevm constraints. The <code>corset</code> tool has three IR levels at which
 * it can do this (HIR/MIR/AIR). The lowest level (AIR) provides the most accurate results (i.e.
 * most comparable with prover).
 *
 * <p>The configuration can be set using the environment variable <code>GO_CORSET_FLAGS</code>. If
 * this is not set, then this validator will not be activated. </code>.
 */
@Slf4j
public class GoCorsetValidator extends AbstractExecutable {
  /** Indicates whether or not this validator is active (i.e. we located the go-corset binary). */
  @Getter private boolean active = false;

  /**
   * Aggregation of all coverage reports generated by go-corset. If GOCORSET_COVERAGE is set, then
   * this data will be written out to that file upon JVM termination
   */
  private static final CoverageReport coverageReport = new CoverageReport();

  public GoCorsetValidator() {
    configGoCorset();
  }

  /**
   * Attempt to validate a given trace against a given zkEvmBin file.
   *
   * @param traceFile Path to the trace file being validated.
   * @param zkEvmBin Path to the zkEvmBin file being validated.
   * @return A result which tells us whether or not the trace file was accepted, and provides
   *     additional information for debugging purposes.
   */
  public Result validate(final Path traceFile, final String zkEvmBin) {
    //
    if (active) {
      Outcome outcome;
      try {
        List<String> commands = buildCommandLine(traceFile, zkEvmBin);
        log.debug("{}", commands);
        // Execute corset with a 5s timeout.
        outcome = super.exec(5, commands);
      } catch (Throwable e) {
        log.error("Corset validation has thrown an exception: %s".formatted(e.getMessage()));
        throw new RuntimeException(e);
      }
      // Manage coverage report
      consumeCoverageReport(traceFile);
      // Check for success or failure
      if (outcome.exitcode() != 0) {
        log.error("Validation failed: %s".formatted(outcome.output()));
        return new Result(false, traceFile.toFile(), outcome.output());
      }
      // success!
      return new Result(true, traceFile.toFile(), outcome.output());
    }
    // Tool is not active
    log.debug("(inactive)");
    return null;
  }

  /**
   * Configure corset from the <code>CORSET_FLAGS</code> environment variable (if set). If the
   * environment variable is not set, the default configuration is retained. If the environment
   * variable is set, but its value is malformed then an exception is raised.
   */
  private void configGoCorset() {
    // If we can execute go-corset then use it!
    this.active = super.isExecutable("go-corset", "--help");
  }

  /**
   * Construct the command-line to use for running corset to check a given trace file is accepted
   * (or not) by a given bin file. Amongst other things, this will configure the command-line flags
   * as dictated by the CORSET_FLAGS environment variable.
   *
   * @return
   */
  private List<String> buildCommandLine(Path traceFile, String zkEvmBin) {
    ArrayList<String> options = new ArrayList<>();
    // Determine options to use (either default or override)
    String flags =
        System.getenv().getOrDefault("GOCORSET_FLAGS", "-w --report --report-context 2 --hir ");
    // Determine whether to generate a coverage report (or not).
    String coverage = System.getenv().get("GOCORSET_COVERAGE");
    // Specify corset binary
    options.add("go-corset");
    // Specify corset "check" command.
    options.add("check");
    // Add all options
    options.addAll(Arrays.asList(flags.split(" ")));
    // Add coverage flag (if applicable)
    if (coverage != null) {
      Path coverageFilename = determineCoverageFile(traceFile);
      options.add("--coverage");
      options.add(coverageFilename.toString());
    }
    // Specify trace file to use
    options.add(traceFile.toAbsolutePath().toString());
    // Specify the zkevm.bin file.
    options.add(zkEvmBin);
    // Done
    return options;
  }

  /**
   * Determine the name of a temporary file to use for writing the coverage report. For now, this is
   * based upon the name of the trace file (but it doesn't have to be done like this).
   *
   * @param traceFile
   * @return
   */
  private Path determineCoverageFile(Path traceFile) {
    String filename = traceFile.toString().replace(".lt", ".coverage.json");
    return Paths.get(filename);
  }

  private void consumeCoverageReport(Path traceFile) {
    boolean coverage = System.getenv("GOCORSET_COVERAGE") != null;
    try {
      if (coverage) {
        Path coverageFile = determineCoverageFile(traceFile);
        // Read in the coverage file
        byte[] bytes = Files.readAllBytes(coverageFile);
        // Needed for Jackson
        ObjectMapper mapper = new ObjectMapper();
        // Read bytes using Jackson
        JsonNode json = mapper.readTree(bytes);
        // Aggregate coverage data together
        coverageReport.importJsonReport(json);
        // Delete temporary coverage file
        Files.delete(coverageFile);
        //
        log.debug("read coverage from {} ({}KB)", coverageFile, bytes.length / 1024);
      }
    } catch (IOException e) {
      log.debug("error reading coverage report: " + e.getMessage());
    }
  }

  static {
    String coverageFile = System.getenv("GOCORSET_COVERAGE");
    //
    if (coverageFile != null) {
      // Coverage is being requested, therefore register a shutdown hook so that we can aggregate
      // all the reports at the end.
      Thread aggregationHook =
          new Thread(
              () -> {
                aggregateCoverageReports(Paths.get(coverageFile));
              });
      Runtime.getRuntime().addShutdownHook(aggregationHook);
    }
  }

  static void aggregateCoverageReports(Path coverageFile) {
    try {
      byte[] bytes = coverageReport.toJsonBytes();
      // Finally, write the aggregated report out to the destination file.
      Files.write(coverageFile, bytes);
      // Record what happened
      log.debug("wrote aggregated coverage report to {} ({}KB)", coverageFile, bytes.length / 1024);
    } catch (IOException e) {
      log.error("error writing aggregated coverage report: {}", e.getMessage());
    }
  }

  static class CoverageReport {
    HashMap<String, HashSet<Integer>> air = new HashMap<>();
    HashMap<String, HashSet<Integer>> mir = new HashMap<>();
    HashMap<String, HashSet<Integer>> hir = new HashMap<>();

    public synchronized void importJsonReport(JsonNode report) throws IOException {
      importJsonSection(report.get("air"), air);
      importJsonSection(report.get("mir"), mir);
      importJsonSection(report.get("hir"), hir);
    }

    public synchronized byte[] toJsonBytes() throws IOException {
      var report = new HashMap<>();
      if (!air.isEmpty()) {
        report.put("air", air);
      }
      if (!mir.isEmpty()) {
        report.put("mir", mir);
      }
      if (!hir.isEmpty()) {
        report.put("hir", hir);
      }
      ObjectWriter mapper = new ObjectMapper().writer().withDefaultPrettyPrinter();
      return mapper.writeValueAsBytes(report);
    }

    private void importJsonSection(JsonNode section, Map<String, HashSet<Integer>> data) {
      // section can be null if there was no recorded data for the given target ir.
      if (section != null) {
        // Iterate over the fields of the section
        for (Iterator<Map.Entry<String, JsonNode>> it = section.fields(); it.hasNext(); ) {
          Map.Entry<String, JsonNode> field = it.next();
          HashSet<Integer> fieldData = data.get(field.getKey());
          // Initialise field data if necessary
          if (fieldData == null) {
            fieldData = new HashSet<>();
            data.put(field.getKey(), fieldData);
          }
          // Java happiness
          final HashSet<Integer> nFieldData = fieldData;
          // Add all elements to the set)
          field
              .getValue()
              .elements()
              .forEachRemaining(
                  (JsonNode n) -> {
                    nFieldData.add(n.asInt());
                  });
        }
      }
    }
  }
}
