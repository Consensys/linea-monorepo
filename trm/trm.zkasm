;; The address trimming module does two things: (i) reduce 256bit
;; addresses into u160 addresses (i.e. modulo 2^160); (b) identify
;; addresses of precompiles.
;;
;; The need for this function arises as some EVM opcodes take an u256
;; stack argument requires trimming to be interpreted as an address.
;; Likewise, when computing a deployment address associated with an
;; invocation of a CREATE-type, the raw KECCAK hash must be trimmed.
;;
;; The following opcodes may trigger it:
;;
;; * BALANCE
;; * EXTCODESIZE / EXTCODECOPY / EXTCODEHASH
;; * CALL / CALLCODE / STATICCALL
;; * SELFDESTRUCT
;; * DELEGATECALL
;;
;; NOTE: the function currently only returns the high word of the
;; trimmed address, since the low word is unchanged.
pub fn trm(RAW_ADDRESS u256) -> (ADDRESS_HI u32, IS_PRECOMPILE u1) {
  var low, tmp u128
  var high u96
  var b u1
  ;; trim off most significant 96 bytes
  high,ADDRESS_HI,low = RAW_ADDRESS
  ;; if hi word not zero, cannot be precompile.
  if ADDRESS_HI != 0 goto exit_0
  ;; discount address 0
  if low == 0 goto exit_0
  ;; determine low <= MAX_PRC_ADDRESS
  b,tmp = low - MAX_PRC_ADDRESS - 1
  ;; done
  IS_PRECOMPILE=b
  return
exit_0:
  ;; no, not precompile
  IS_PRECOMPILE=0
  return
}
