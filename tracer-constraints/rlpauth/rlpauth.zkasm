include "../constants/evm.zkasm"

;; https://eips.ethereum.org/EIPS/eip-7702

;; TODO: do we have an shared notation for constants, function arguments...?
;; const SECP256K1N = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
const SECP256K1N_DIVIDED_BY_TWO = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17
const MAGIC = 0x05

pub fn rlpauth(chain_id u256, nonce u256, delegation_address u160, y_parity u8, r u256, s u256, 
authority_address u160, ;; predicticted returned value by ecrecover
macro u1, blk_number u16, user_txn_number u24, txn_from_address u160, authority_is_sender_tot u1, ;; (TODO: check) columns for lookup into usertxndata
xtern u1, network_chain_id u256, ;; additional columns for lookup into blockdata
authority_ecrecover_success u1, authority_nonce u256, authority_has_empty_code_or_is_delegated u1) ;; additional columns for lookup into hub
-> (authorization_tuple_is_valid u1)
{
    ;; Preliminary computation
    var delegation_address_is_zero u1
    delegation_address_is_zero = delegation_address == 0 ? 1 : 0

    var sender_is_authority u1
    sender_is_authority = txn_from_address == authority_address ? 1 : 0

    ;; assert auth.chain_id < 2**256
    ;; assert auth.nonce < 2**64
    ;; assert len(auth.delegation_address) == 20
    ;; assert auth.y_parity < 2**8
    ;; assert auth.r < 2**256
    ;; assert auth.s < 2**256
    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == network_chain_id goto step_2
        fail
    step_2:
        ;; Check that nonce < 2^64
        var b u1
        var nonce_minus_2_to_the_power_of_64_tmp u256
        b, nonce_minus_2_to_the_power_of_64_tmp = nonce - 2^64
        if b == 0 goto failure 
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var secp256k1n_divided_by_two_minus_s_tmp u256
        b, secp256k1n_divided_by_two_minus_s_tmp = SECP256K1N_DIVIDED_BY_TWO - s
        if b == 1 goto failure
        
        var msg u240
        msg = compute_rlp(chain_id, delegation_address, nonce)

        var ecrecover_fails u1
        ecrecover_fails = ecrecover(msg, y_parity, r, s, authority_address, authority_ecrecover_success)
        if ecrecover_fails == 1 goto failure
    ;; step_4: happens in the HUB
        ;; Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        if authority_has_empty_code_or_is_delegated == 1 goto step_6
        fail
    step_6:
        ;; NOTE: the sender_nonce will be incremented after the authority list in Linea; if sender == authority_address (SENDER_IS_AUTHORITY) one must verify authority_nonce + 1 == nonce (TBC)
        if sender_is_authority == 1 goto step_6_with_sender_is_authority
        if sender_is_authority == 0 goto step_6_with_sender_is_not_authority
    step_6_with_sender_is_authority:
        var authority_nonce_plus_one u257 ;; to avoid overflow
        authority_nonce_plus_one = authority_nonce + 1
        if authority_nonce_plus_one == nonce goto exit
        fail
    step_6_with_sender_is_not_authority:
        if authority_nonce == nonce goto exit
        fail       
    ;; step_7: happens in the HUB
        ;; Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    ;; step_8: happens in the HUB
        ;; if delegation_address_is_zero goto delegation_address_is_zero_case:
        ;; delegation_address_is_zero_case:
        ;;  authority_code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ;; keccak256 of empty string
        ;;  exit
        ;; authority_code = (0xef0100 * 2^160) + delegation_address
    ;; step_9: happens in the HUB
        ;; authority_nonce = authority_nonce + 1
    exit:
        authorization_tuple_is_valid = 1
        return
    failure:
        authorization_tuple_is_valid = 0 ;; TODO: do we need this?
        fail
}

;; temporary dummy functions
fn compute_rlp(chain_id u256, address u160, nonce u256) -> (rlp_output u240) {
    rlp_output = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffff
    ;; TODO: call twice compute_rlp_integer and compute_rlp_address, verify sizes and concatenate
    return
}

fn compute_rlp_integer(integer u256) -> (rlp_prefix u128, leading_limb_left_shifted u128, leading_limb_byte_size u8) {
    var integer_hi u128
    var integer_lo u128
    integer_hi, integer_lo = integer

    var integer_is_nonzero u1
    integer_is_nonzero = integer != 0 ? 1 : 0

    var integer_hi_is_nonzero u1
    integer_hi_is_nonzero = integer_hi != 0 ? 1 : 0

    var rlp_prefix_required u1
    var integer_greater_or_equal_to_128 u1
    var b u1
    var integer_minus_128_tmp u256
    b, integer_minus_128_tmp = integer - 128
    integer_greater_or_equal_to_128 = b == 0 ? 1 : 0
    rlp_prefix_required = integer_is_nonzero == 0 ? 1 : integer_greater_or_equal_to_128

    rlp_prefix, leading_limb_left_shifted, leading_limb_byte_size = rlputils(RLP_UTILS_INST_INTEGER, integer_hi, integer_lo, integer_is_nonzero, integer_hi_is_nonzero, rlp_prefix_required)
    return
}

fn compute_rlp_address(address u160) -> (rlp_prefix u128, rlp_prefix_byte_size u8) {
    ;; TODO: should the other values verified here?
    ;; address_length = 20 ;; length of address in bytes

    var address_first_byte u8
    var address_other_bytes u152
    address_first_byte, address_other_bytes = address

    ;; address_is_list = 0

    ;; address_is_nonempty = 1

    ;; rlp_prefix_required  = 0 (as address_length is fixed to 20 bytes)

    var tmp u128
    rlp_prefix, tmp, rlp_prefix_byte_size = rlputils(RLP_UTILS_INST_BYTE_STRING_PREFIX, 20, address_first_byte, 0, 1, 0)
    return
}

;; keccak_output is a prediction to be confirmed by the prover
fn keccak(keccak_input u184, 
keccak_output u256) -> (keccak_fails u1) {
    ;; extract keccak_input and assign to limb
    var limb u128
    var left_aligned_prefix u24
    var left_aligned_address_hi u32
    var left_aligned_address_lo u128
    left_aligned_prefix, left_aligned_address_hi, left_aligned_address_lo = keccak_input
    limb = left_aligned_prefix * 2^104
    limb = left_aligned_address_hi * 2^96
    limb = left_aligned_address_lo

    keccak_fails = 0
    return
}

;; address and success_bit are predictions to be confirmed by the prover 
fn ecrecover(msg u240, y_parity u8, r u256, s u256, 
address u160, success_bit u1) -> (ecrecover_fails u1) {
    var limb u128
    
    limb = y_parity

    var r_lo u128
    limb, r_lo = r ;; r_hi
    limb = r_lo ;; r_lo

    var s_lo u128
    limb, s_lo = s ;; s_hi
    limb = s_lo ;; s_lo

    var address_lo u128
    limb, address_lo = address ;; address_hi
    limb = address_lo ;; address_lo

    limb = success_bit

    ;; extract msg and assign to limb TODO: give proper names
    var a, b, c, e, h u8    
    var d u24     
    var f u32
    var g u128
    var i u16    
    a, b, c, d, e, f, g, h, i = msg
    limb = a * 2^120 
    limb = b * 2^120 
    limb = c * 2^120 
    limb = d * 2^104 
    limb = e * 2^120 
    limb = f * 2^96 
    limb = g
    limb = h * 2^120 
    limb = i * 2^112 
    
    ecrecover_fails = 0
    return
}