include "../constants/evm.zkasm"
include "../util/padding.zkasm"
include "../util/byte_size.zkasm"

;; https://eips.ethereum.org/EIPS/eip-7702

pub fn rlpauth(chain_id u256, nonce u64, delegation_address u160, y_parity u8, r u256, s u256, 
authority_address u160, ;; predicticted returned value by ecrecover
macro u1, blk_number u16, user_txn_number u24, txn_from_address u160, authority_is_sender_tot u1, ;; columns for lookup into usertxndata
xtern u1, network_chain_id u256, ;; additional columns for lookup into blockdata
authority_ecrecover_success u1, authority_nonce u256, authority_has_empty_code_or_is_delegated u1) ;; additional columns for lookup into hub
-> (authorization_tuple_is_valid u1)
{
    ;; Preliminary computation
    var delegation_address_is_zero u1
    delegation_address_is_zero = delegation_address == 0 ? 1 : 0

    var sender_is_authority u1
    sender_is_authority = txn_from_address == authority_address ? 1 : 0

    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == network_chain_id goto step_2
        goto failure
    step_2:
        ;; Check that nonce < 2^64 - 1
        var b u1
        var nonce_minus_2_to_the_power_of_64_minus_1_tmp u64
        b, nonce_minus_2_to_the_power_of_64_minus_1_tmp = nonce - (2^64 - 1)
        if b == 0 goto failure 
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var secp256k1n_divided_by_two_minus_s_tmp u256
        b, secp256k1n_divided_by_two_minus_s_tmp = SECP256K1N_DIVIDED_BY_TWO - s
        if b == 1 goto failure
        
        var list_rlp_prefix_limb u128
        var chain_id_rlp_prefix_limb u128
        var chain_id_leading_limb u128
        var address_rlp_prefix_limb u128
        var address_hi_limb u128
        var address_lo_limb u128
        var nonce_rlp_prefix_limb u128
        var nonce_leading_limb u128
        var chain_id_byte_size u8
        var nonce_byte_size u8

        list_rlp_prefix_limb, chain_id_rlp_prefix_limb, chain_id_leading_limb, address_rlp_prefix_limb, address_hi_limb, address_lo_limb, nonce_rlp_prefix_limb, nonce_leading_limb, chain_id_byte_size, nonce_byte_size = compute_rlp(chain_id, delegation_address, nonce)

        var dummy u1
        dummy = ecrecover(list_rlp_prefix_limb, chain_id_rlp_prefix_limb, chain_id_leading_limb, address_rlp_prefix_limb, address_hi_limb, address_lo_limb, nonce_rlp_prefix_limb, nonce_leading_limb, chain_id_byte_size, nonce_byte_size, y_parity, r, s, authority_address, authority_ecrecover_success)            
    ;; step_4: happens in the HUB
        ;; Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        if authority_has_empty_code_or_is_delegated == 1 goto step_6
        goto failure
    step_6:
        ;; NOTE: the sender_nonce will be incremented after the authority list in Linea; if sender == authority_address (SENDER_IS_AUTHORITY) one must verify authority_nonce + 1 == nonce (TBC)
        if sender_is_authority == 1 goto step_6_with_sender_is_authority
        if sender_is_authority == 0 goto step_6_with_sender_is_not_authority
    step_6_with_sender_is_authority:
        var authority_nonce_plus_one u257 ;; to avoid overflow
        authority_nonce_plus_one = authority_nonce + 1
        if authority_nonce_plus_one == nonce goto exit
        goto failure
    step_6_with_sender_is_not_authority:
        if authority_nonce == nonce goto exit
        goto failure       
    ;; step_7: happens in the HUB
        ;; Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    ;; step_8: happens in the HUB
        ;; if delegation_address_is_zero goto delegation_address_is_zero_case:
        ;; delegation_address_is_zero_case:
        ;;  authority_code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ;; keccak256 of empty string
        ;;  exit
        ;; authority_code = (0xef0100 * 2^160) + delegation_address
    ;; step_9: happens in the HUB
        ;; authority_nonce = authority_nonce + 1
    exit:
        authorization_tuple_is_valid = 1
        return
    failure:
        authorization_tuple_is_valid = 0
        fail
}

fn compute_rlp(chain_id u256, address u160, nonce u64) -> (list_rlp_prefix_limb u128, chain_id_rlp_prefix_limb u128, chain_id_leading_limb u128, address_rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128, nonce_rlp_prefix_limb u128, nonce_leading_limb u128, chain_id_byte_size u8, nonce_byte_size u8)
{    
    var chain_id_rlp_prefix_required u1
    chain_id_rlp_prefix_required, chain_id_rlp_prefix_limb, chain_id_leading_limb, chain_id_byte_size = compute_rlp_integer_128_bits(chain_id)

    address_rlp_prefix_limb, address_hi_limb, address_lo_limb = compute_rlp_address(address)

    var nonce_rlp_prefix_required u1
    nonce_rlp_prefix_required, nonce_rlp_prefix_limb, nonce_leading_limb, nonce_byte_size = compute_rlp_integer_128_bits(nonce)

    ;; output (assuming chain_id at most 8 bytes):
    ;; list content (max 39 bytes <= 55 bytes)
    ;;          list_rlp_prefix_limb (1 byte)
    ;; OPTIONAL chain_id_rlp_prefix_limb (if chain_id_rlp_prefix_required == 1) (1 byte)
    ;;          chain_id_leading_limb (max 8 bytes)
    ;;          address_rlp_prefix_limb (1 byte) ?
    ;;          address_hi_limb (4 bytes)
    ;;          address_lo_limb (16 bytes)
    ;; OPTIONAL nonce_rlp_prefix_limb (if nonce_rlp_prefix_required == 1) (1 byte)
    ;;          nonce_leading_limb (max 8 bytes)

    list_rlp_prefix_limb = 
        0xc0 + ;; list prefix for payload <= 55 bytes
        chain_id_rlp_prefix_required + chain_id_byte_size + ;; chain_id
        1 + 4 + 16 + ;; address
        nonce_rlp_prefix_required + nonce_byte_size ;; nonce
   
    return
}

fn compute_rlp_integer_128_bits(integer u256) -> (rlp_prefix_required u1, rlp_prefix_limb u128, leading_limb u128, leading_limb_byte_size u8) {
    ;; sanity check
    var integer_hi u128
    var integer_lo u128
    integer_hi, integer_lo = integer
    if integer_hi != 0 goto failure

    var integer_greater_or_equal_to_128 u1
    var b u1
    var integer_minus_128_tmp u128
    b, integer_minus_128_tmp = integer_lo - 128
    integer_greater_or_equal_to_128 = b == 0 ? 1 : 0
    rlp_prefix_required = integer_lo == 0 ? 1 : integer_greater_or_equal_to_128

    leading_limb = rpad_128(integer_lo)
    leading_limb_byte_size = byte_size(integer_lo)
    rlp_prefix_limb = RLP_PREFIX_INT_SHORT + leading_limb_byte_size

    ;; output:
    ;; rlp_prefix_limb (if rlp_prefix_required == 1)
    ;; leading_limb

    return

    failure:
        fail
}

fn compute_rlp_address(address u160) -> (rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128) {
    rlp_prefix_limb = rpad_128(RLP_PREFIX_INT_SHORT + 20) ;; address is 20 bytes (<= 55 bytes)
    var address_hi u32
    address_hi, address_lo_limb = address
    address_hi_limb = rpad_128(address_hi)

    ;; output:
    ;; rlp_prefix_limb
    ;; address_hi_limb
    ;; address_lo_limb

    return
}

;; address and success_bit are predictions to be confirmed by the prover 
fn ecrecover(list_rlp_prefix_limb u128, chain_id_rlp_prefix_limb u128, chain_id_leading_limb u128, address_rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128, nonce_rlp_prefix_limb u128, nonce_leading_limb u128, chain_id_byte_size u8, nonce_byte_size u8, y_parity u8, r u256, s u256, address u160, success_bit u1) -> (dummy u1) {
    var limb u128
    var limb_size u8  
    var r_lo u128
    var s_lo u128
    var address_lo u128

    ;; limb
    limb = y_parity
    limb, r_lo = r ;; r_hi
    limb = r_lo ;; r_lo
    limb, s_lo = s ;; s_hi
    limb = s_lo ;; s_lo
    limb, address_lo = address ;; address_hi
    limb = address_lo ;; address_lo
    limb = success_bit
    limb = MAGIC
    limb = list_rlp_prefix_limb
    limb = chain_id_rlp_prefix_limb ;; may be zero
    limb = chain_id_leading_limb
    limb = address_rlp_prefix_limb
    limb = address_hi_limb
    limb = address_lo_limb
    limb = nonce_rlp_prefix_limb ;; may be zero
    limb = nonce_leading_limb 

    ;; limb_size
    var b u1
    var i u4
    i = 0
    fill_limb_size_loop:
        limb_size = 0
        b, i = i + 1
        if i == 7 goto after_fill_limb_size_loop
    
    after_fill_limb_size_loop:
    limb_size = 1 ;; MAGIC
    limb_size = 1 ;; list_rlp_prefix_limb
    limb_size = chain_id_rlp_prefix_limb == 0? 0 : 1
    limb_size = chain_id_byte_size 
    limb_size = 1 ;; address_rlp_prefix_limb
    limb_size = 4 ;; address_hi_limb
    limb_size = 16 ;; address_lo_limb
    limb_size = nonce_rlp_prefix_limb == 0? 0 : 1
    limb_size = nonce_byte_size ;; nonce_leading_limb

    ;; TODO: shall we fill other columns such as is_signature, is_result, is_message, index?
    var is_signature u1
    var is_result u1
    var is_message u1
    var index u4
  
    dummy = 0
    return
}

;; TODO: functions to be deleted or moved elsewhere

;; fn compute_rlp_integer(integer u256) -> (rlp_prefix_required u1, integer_hi_is_nonzero u1, rlp_prefix_limb u128, leading_limb u128, trailing_limb u128, leading_limb_byte_size u8) {
;;     var integer_hi u128
;;     var integer_lo u128
;;     integer_hi, integer_lo = integer
;;     var integer_is_nonzero u1
;;     integer_is_nonzero = integer != 0 ? 1 : 0
;;     integer_hi_is_nonzero = integer_hi != 0 ? 1 : 0
;;     var integer_greater_or_equal_to_128 u1
;;     var b u1
;;     var integer_minus_128_tmp u256
;;     b, integer_minus_128_tmp = integer - 128
;;     integer_greater_or_equal_to_128 = b == 0 ? 1 : 0
;;     rlp_prefix_required = integer_is_nonzero == 0 ? 1 : integer_greater_or_equal_to_128
;;     var leading_limb_left_shifted u128
;;     rlp_prefix_limb, leading_limb_left_shifted, leading_limb_byte_size = rlputils(RLP_UTILS_INST_INTEGER, integer_hi, integer_lo, integer_is_nonzero, integer_hi_is_nonzero, rlp_prefix_required)
;;     leading_limb = leading_limb_left_shifted
;;     trailing_limb = integer_lo
;;     ;; output:
;;     ;; rlp_prefix_limb (if rlp_prefix_required == 1)
;;     ;; leading_limb
;;     ;; trailing_limb (if integer_hi_is_nonzero == 1)
;;     return
;; }

;; keccak_output is a prediction to be confirmed by the prover
;; fn keccak(keccak_input u184, 
;; keccak_output u256) -> (keccak_fails u1) {
;;     ;; extract keccak_input and assign to limb
;;     var limb u128
;;     var left_aligned_prefix u24
;;     var left_aligned_address_hi u32
;;     var left_aligned_address_lo u128
;;     left_aligned_prefix, left_aligned_address_hi, left_aligned_address_lo = keccak_input
;;     limb = rpad_128(left_aligned_prefix)
;;     limb = rpad_128(left_aligned_address_hi)
;;     limb = rpad_128(left_aligned_address_lo)
;;     keccak_fails = 0
;;     return
;; }