include "../constants/evm.zkasm"
include "../util/padding.zkasm"
include "../util/byte.zkasm"
include "../util/max2.zkasm"
include "../util/bit_shl.zkasm"
include "../util/byte_shift.zkasm"

;; https://eips.ethereum.org/EIPS/eip-7702

pub fn rlpauth(chain_id u64, nonce u64, delegation_address u160, y_parity u8, r u256, s u256,
msg u256, ;; predicted returned value by keccak 
authority_address u160, ;; predicticted returned value by ecrecover
macro u1, blk_number u16, user_txn_number u24, txn_from_address u160, authority_is_sender_tot u1, ;; columns for lookup into txndata (to get txn_from_address)
xtern u1, network_chain_id u256, ;; additional columns for lookup into blockdata (to get network_chain_id)
authority_ecrecover_success u1, authority_nonce u64, authority_has_empty_code_or_is_delegated u1, tuple_index u10, hub_stamp u32) ;; additional columns for lookup into hub
-> (authorization_tuple_is_valid u1)
{
    ;; Preliminary computation
    var delegation_address_is_zero u1
    delegation_address_is_zero = delegation_address == 0 ? 1 : 0

    var sender_is_authority u1
    sender_is_authority = txn_from_address == authority_address ? 1 : 0

    var id u32
    var b u1
    b, id = hub_stamp + 1 ;; id for lookups to ECDATA and SHAKIRA

    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == network_chain_id goto step_2
        goto failure
    step_2:
        ;; Check that nonce < 2^64 - 1
        var nonce_is_in_bounds u1
        var nonce_minus_2_to_the_power_of_64_minus_1_tmp u64
        nonce_is_in_bounds, nonce_minus_2_to_the_power_of_64_minus_1_tmp = nonce - (2^64 - 1) 
        if nonce_is_in_bounds == 0 goto failure 
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var secp256k1n_is_out_of_bounds u1
        var secp256k1n_divided_by_two_minus_s_tmp u256
        secp256k1n_is_out_of_bounds, secp256k1n_divided_by_two_minus_s_tmp = SECP256K1N_DIVIDED_BY_TWO - s
        if secp256k1n_is_out_of_bounds == 1 goto failure
        
        var rlp_output u320
        var rlp_output_byte_size u6
        rlp_output, rlp_output_byte_size = compute_rlp(chain_id, delegation_address, nonce)

        ;; compute keccak input by concatenating MAGIC and rlp_output
        var keccak_input u328
        keccak_input = (MAGIC * 2^320) + rlp_output

        var keccak_input_byte_size u6
        b, keccak_input_byte_size = 1 + rlp_output_byte_size ;; 1 byte for MAGIC
       
        var dummy u1

        dummy = keccak(id, keccak_input, keccak_input_byte_size, msg)

        dummy = ecrecover(id, msg, y_parity, r, s, authority_address, authority_ecrecover_success)            
    ;; step_4: happens in the HUB
    ;;  Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        if authority_has_empty_code_or_is_delegated == 1 goto step_6
        goto failure
    step_6:
        ;; NOTE: the sender_nonce will be incremented after the authority list in Linea; if sender == authority_address (SENDER_IS_AUTHORITY) 
        ;; one must verify authority_nonce + 1 == nonce (TBC)
        var authority_nonce_plus_sender_is_authority u65
        authority_nonce_plus_sender_is_authority = authority_nonce + sender_is_authority
        if authority_nonce_plus_sender_is_authority == nonce goto exit
        goto failure       
    ;; step_7: happens in the HUB
    ;;  Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    ;; step_8: happens in the HUB
    ;;  Set the code of authority
    ;; step_9: happens in the HUB
    ;;  authority_nonce = authority_nonce + 1
    exit:
        authorization_tuple_is_valid = 1
        return
    failure:
        authorization_tuple_is_valid = 0
        fail
}

fn compute_rlp(chain_id u64, address u160, nonce u64) -> (rlp_output u320, rlp_output_byte_size u6)
{    
    ;; chain_id is assumed to be at most 8 bytes
    var chain_id_rlp u72
    chain_id_rlp = compute_rlp_integer_64_bits(chain_id)

    var address_rlp u168
    address_rlp = ((RLP_PREFIX_INT_SHORT + 20) * 2^160) + address ;; compute rlp address

    var nonce_rlp u72
    nonce_rlp = compute_rlp_integer_64_bits(nonce)

    ;; output (max 40 bytes):
    ;;  list_rlp_prefix (1 byte) since list content max 39 bytes <= 55 bytes
    ;;  chain_id_rlp (max 9 bytes)
    ;;  address_rlp (21 bytes)
    ;;  nonce_rlp (max 9 bytes)

    var chain_id_rlp_byte_size u6
    chain_id_rlp_byte_size = byte_size(chain_id_rlp)
    var nonce_rlp_byte_size u6
    nonce_rlp_byte_size = byte_size(nonce_rlp)

    var list_rlp_prefix u8
    var b2 u2    
    b2, list_rlp_prefix = 
        RLP_PREFIX_LIST_SHORT + ;; list prefix for payload <= 55 bytes
        chain_id_rlp_byte_size + ;; chain_id
        21 + ;; address
        nonce_rlp_byte_size ;; nonce

    var nonce_rlp_address_rlp_chain_id_rlp_byte_size u6
    b2, nonce_rlp_address_rlp_chain_id_rlp_byte_size = nonce_rlp_byte_size + 21 + chain_id_rlp_byte_size ;; 9 + 21 + 9 = 39 bytes at most
    
    var nonce_rlp_address_rlp_byte_size u6
    var b u1
    b, nonce_rlp_address_rlp_byte_size = nonce_rlp_byte_size + 21 ;; 9 + 21 = 30 bytes at most

    var list_rlp_prefix_left_shifted u512
    list_rlp_prefix_left_shifted = byte_shl512(list_rlp_prefix, nonce_rlp_address_rlp_chain_id_rlp_byte_size)
    ;; 1 byte shifted at most by 39 bytes (320 bits)

    var chain_id_rlp_left_shifted u512
    chain_id_rlp_left_shifted = byte_shl512(chain_id_rlp, nonce_rlp_address_rlp_byte_size)
    ;; 3 bytes shifted at most by 30 bytes 

    var address_rlp_left_shifted u512
    address_rlp_left_shifted = byte_shl512(address_rlp, nonce_rlp_byte_size)
    ;; 21 bytes shifted at most by 9 bytes

    ;; compose output with leading zeros
    var rlp_output_with_leading_zeros u512
    var b192 u192 ;; 512 - 320
    b2, b192, rlp_output_with_leading_zeros = list_rlp_prefix_left_shifted + chain_id_rlp_left_shifted + address_rlp_left_shifted + nonce_rlp

    ;; left shift output to remove leading zeros
    b, rlp_output_byte_size = 1 + nonce_rlp_address_rlp_chain_id_rlp_byte_size

    var rlp_output_left_shift u6
    var b3 u3
    b3, rlp_output_left_shift = 320 - rlp_output_byte_size

    var rlp_output_left_shifted u512
    rlp_output_left_shifted = byte_shl512(rlp_output_with_leading_zeros, rlp_output_left_shift)

    b192, rlp_output = rlp_output_left_shifted

    return
}

fn compute_rlp_integer_64_bits(integer u64) -> (integer_rlp u72) { ;; 8 + 64 (max 9 bytes)    
    ;; checking if rlp prefix is required
    var rlp_prefix_required u1
    var integer_greater_or_equal_to_128 u1
    var integer_smaller_than_128 u1
    var integer_minus_128_tmp u64
    integer_smaller_than_128, integer_minus_128_tmp = integer - 128    
    integer_greater_or_equal_to_128 = integer_smaller_than_128 == 0 ? 1 : 0
    rlp_prefix_required = integer == 0 ? 1 : integer_greater_or_equal_to_128

    ;; compute rlp prefix
    var b u1
    var integer_byte_size u5
    var integer_byte_size_tmp u6
    var rlp_prefix u8
    integer_byte_size_tmp = byte_size(integer) ;; at most 8
    b, integer_byte_size = integer_byte_size_tmp
    b, rlp_prefix = rlp_prefix_required == 0 ? 0 : (RLP_PREFIX_INT_SHORT + integer_byte_size)

    var rlp_prefix_left_shifted u256
    rlp_prefix_left_shifted = byte_shl256(rlp_prefix, integer_byte_size)

    var b185 u185 ;; 256 - 72 + 1
    b185, integer_rlp = rlp_prefix_left_shifted + integer
    return
}

;; h is a prediction to be confirmed by SHAKIRA
pub fn keccak(id u32, keccak_input u328, keccak_input_byte_size u6, h u256) -> (lookup_selector u1) {
    var limb u128
    var limb_size u8  

    var total_size u32
    total_size = keccak_input_byte_size
    
    var h_lo u128

    ;; determine numbers of limbs based on keccak_input_byte_size
    var keccak_input_byte_size_vs_32 u8
    keccak_input_byte_size_vs_32 = max_u8(keccak_input_byte_size, 32)

    var keccak_input_byte_size_vs_16 u8
    keccak_input_byte_size_vs_16 = max_u8(keccak_input_byte_size, 16)

    if keccak_input_byte_size == keccak_input_byte_size_vs_32 goto limbs_are_3
    if keccak_input_byte_size == keccak_input_byte_size_vs_16 goto limbs_are_2

    var index_max_data u2
    var b u1
    limbs_are_3:
        index_max_data = 2

        ;; limb 
        ;; data
        limb = limb_u512(keccak_input, 0)
        limb = limb_u512(keccak_input, 16)
        limb = limb_u512(keccak_input, 32)

        ;; limb size
        limb_size = 16
        limb_size = 16
        b, limb_size = keccak_input_byte_size - 32

        ;; lookup to SHAKIRA for keccak computation (case 3 limbs)
        lookup_selector = 0

        goto result_and_fill_other_columns

    limbs_are_2:
        index_max_data = 1

        ;; limb 
        ;; data
        limb = limb_u512(keccak_input, 0)
        limb = limb_u512(keccak_input, 16)

        ;; limb size
        limb_size = 16
        b, limb_size = keccak_input_byte_size - 16
    
        ;; lookup to SHAKIRA for keccak computation (case 2 limbs)
        lookup_selector = 1

    result_and_fill_other_columns:
        ;; result
        limb, h_lo = h ;; h_hi
        limb = h_lo ;; h_lo

        ;; fill other columns
        var is_keccak_data u1
        var is_keccak_result u1
        var index u2

        index = 0
        data_loop:
            is_keccak_data = 1
            is_keccak_result = 0
            if index != index_max_data  goto data_loop
            if index == index_max_data  goto exit_data_loop
            b, index = index + 1
        exit_data_loop:
            index = 0

        result_loop:
            is_keccak_data = 0
            is_keccak_result = 1
            if index != 1 goto result_loop
            if index == 1 goto exit_result_loop
            b, index = index + 1
        exit_result_loop:

        return
}

;; address and success_bit are predictions to be confirmed by ECDATA 
pub fn ecrecover(id u32, h u256, y_parity u8, r u256, s u256, address u160, success_bit u1) -> (lookup_selector u1) {
    var limb u128

    var total_size u16
    total_size = 128 ;; 8 data limbs 

    var h_lo u128
    var r_lo u128
    var s_lo u128
    var address_lo u128

    ;; limb
    ;; data
    limb, h_lo = h ;; h_hi
    limb = h_lo ;; h_lo
    limb = 0 ;; v_hi
    limb = y_parity + 27 ;; v_lo
    limb, r_lo = r ;; r_hi
    limb = r_lo ;; r_lo
    limb, s_lo = s ;; s_hi
    limb = s_lo ;; s_lo

    ;; result
    limb, address_lo = address ;; address_hi
    limb = address_lo ;; address_lo

    ;; fill other columns
    var is_ecrecover_data u1
    var is_ecrecover_result u1
    var index u3
    index = 0
    var b u1

    data_loop:
        is_ecrecover_data = 1
        is_ecrecover_result = 0
        if index != 7 goto data_loop
        if index == 7 goto exit_data_loop  
        b, index = index + 1

    exit_data_loop:
        index = 0

    result_loop:
        is_ecrecover_data = 0
        is_ecrecover_result = 1
        if index != 1 goto result_loop
        if index == 1 goto exit_result_loop  
        b, index = index + 1

    exit_result_loop:   

    ;; lookup to ECDATA for ecrecover computation
    lookup_selector = 1
    return
}