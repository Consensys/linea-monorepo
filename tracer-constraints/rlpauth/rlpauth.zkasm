include "../constants/evm.zkasm"

;; https://eips.ethereum.org/EIPS/eip-7702

;; TODO: do we have an shared notation for constants, function arguments...?
;; const SECP256K1N = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
const SECP256K1N_DIVIDED_BY_TWO = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17
const MAGIC = 0x05

pub fn rlpauth(chain_id u256, raw_nonce u256, raw_delegation_address u256, raw_y_parity u256, r u256, s u256, 
authority_address u160, ;; predicticted returned value by ecrecover
macro u1, blk_number u16, user_txn_number u24, txn_from_address u160, authority_is_sender_tot u1, ;; columns for lookup into usertxndata
xtern u1, network_chain_id u256, ;; additional columns for lookup into blockdata
authority_ecrecover_success u1, authority_nonce u256, authority_has_empty_code_or_is_delegated u1) ;; additional columns for lookup into hub
-> (authorization_tuple_is_valid u1)
{
    ;; Bound checks
    ;; assert auth.nonce < 2**64
    var nonce u64
    var is_nonce_out_of_bound u192
    is_nonce_out_of_bound, nonce = raw_nonce
    if is_nonce_out_of_bound != 0 goto failure

    ;; assert len(auth.delegation_address) == 20
    var delegation_address u160
    var is_delegation_address_out_of_bound u96
    is_delegation_address_out_of_bound, delegation_address = raw_delegation_address
    if is_delegation_address_out_of_bound != 0 goto failure 

    ;; assert auth.y_parity < 2**8
    var y_parity u8
    var is_y_parity_out_of_bound u248
    is_y_parity_out_of_bound, y_parity = raw_y_parity
    if is_y_parity_out_of_bound != 0 goto failure

    ;; Preliminary computation
    var delegation_address_is_zero u1
    delegation_address_is_zero = delegation_address == 0 ? 1 : 0

    var sender_is_authority u1
    sender_is_authority = txn_from_address == authority_address ? 1 : 0

    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == network_chain_id goto step_2
        fail
    step_2:
        ;; Check that nonce < 2^64 - 1
        var b u1
        var nonce_minus_2_to_the_power_of_64_minus_1_tmp u64
        b, nonce_minus_2_to_the_power_of_64_minus_1_tmp = nonce - (2^64 - 1)
        if b == 0 goto failure 
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var secp256k1n_divided_by_two_minus_s_tmp u256
        b, secp256k1n_divided_by_two_minus_s_tmp = SECP256K1N_DIVIDED_BY_TWO - s
        if b == 1 goto failure
        
        var list_rlp_prefix_limb u128
        var chain_id_rlp_prefix_limb u128
        var chain_id_leading_limb u128
        var address_rlp_prefix_limb u128
        var address_hi_limb u128
        var address_lo_limb u128
        var nonce_rlp_prefix_limb u128
        var nonce_leading_limb u128
        var chain_id_byte_size u8
        var nonce_byte_size u8

        list_rlp_prefix_limb, chain_id_rlp_prefix_limb, chain_id_leading_limb, address_rlp_prefix_limb, address_hi_limb, address_lo_limb, nonce_rlp_prefix_limb, nonce_leading_limb, chain_id_byte_size, nonce_byte_size = compute_rlp(chain_id, delegation_address, nonce)

        var ecrecover_fails u1
        ecrecover_fails = ecrecover(list_rlp_prefix_limb, chain_id_rlp_prefix_limb, chain_id_leading_limb, address_rlp_prefix_limb, address_hi_limb, address_lo_limb, nonce_rlp_prefix_limb, nonce_leading_limb, chain_id_byte_size, nonce_byte_size, y_parity, r, s, authority_address, authority_ecrecover_success)
            
        if ecrecover_fails == 1 goto failure
    ;; step_4: happens in the HUB
        ;; Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        if authority_has_empty_code_or_is_delegated == 1 goto step_6
        fail
    step_6:
        ;; NOTE: the sender_nonce will be incremented after the authority list in Linea; if sender == authority_address (SENDER_IS_AUTHORITY) one must verify authority_nonce + 1 == nonce (TBC)
        if sender_is_authority == 1 goto step_6_with_sender_is_authority
        if sender_is_authority == 0 goto step_6_with_sender_is_not_authority
    step_6_with_sender_is_authority:
        var authority_nonce_plus_one u257 ;; to avoid overflow
        authority_nonce_plus_one = authority_nonce + 1
        if authority_nonce_plus_one == nonce goto exit
        fail
    step_6_with_sender_is_not_authority:
        if authority_nonce == nonce goto exit
        fail       
    ;; step_7: happens in the HUB
        ;; Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    ;; step_8: happens in the HUB
        ;; if delegation_address_is_zero goto delegation_address_is_zero_case:
        ;; delegation_address_is_zero_case:
        ;;  authority_code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ;; keccak256 of empty string
        ;;  exit
        ;; authority_code = (0xef0100 * 2^160) + delegation_address
    ;; step_9: happens in the HUB
        ;; authority_nonce = authority_nonce + 1
    exit:
        authorization_tuple_is_valid = 1
        return
    failure:
        authorization_tuple_is_valid = 0 ;; TODO: do we need this?
        fail
}

fn compute_rlp(chain_id u256, address u160, nonce u256) -> (list_rlp_prefix_limb u128, chain_id_rlp_prefix_limb u128, chain_id_leading_limb u128, address_rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128, nonce_rlp_prefix_limb u128, nonce_leading_limb u128, chain_id_byte_size u8, nonce_byte_size u8)
{    
    var chain_id_rlp_prefix_required u1
    var chain_id_hi_is_nonzero u1
    var chain_id_trailing_limb u128
    chain_id_rlp_prefix_required, chain_id_hi_is_nonzero, chain_id_rlp_prefix_limb, chain_id_leading_limb, chain_id_trailing_limb, chain_id_byte_size = compute_rlp_integer(chain_id)

    address_rlp_prefix_limb, address_hi_limb, address_lo_limb = compute_rlp_address(address)

    var nonce_rlp_prefix_required u1
    var nonce_hi_is_nonzero u1
    var nonce_trailing_limb u128
    nonce_rlp_prefix_required, nonce_hi_is_nonzero, nonce_rlp_prefix_limb, nonce_leading_limb, nonce_trailing_limb, nonce_byte_size = compute_rlp_integer(nonce)

    ;; output:
    ;; list content (max 87 bytes)
    ;;          list_rlp_prefix_limb (1 byte)
    ;; OPTIONAL list_byte_size (if list byte size > 55) (1 byte)   
    ;; OPTIONAL chain_id_rlp_prefix_limb (if chain_id_rlp_prefix_required == 1) (1 byte)
    ;;          chain_id_leading_limb (max 16 bytes)
    ;; OPTIONAL chain_id_trailing_limb (if chain_id_hi_is_nonzero == 1) (max 16 bytes)
    ;;          address_rlp_prefix_limb (1 byte)
    ;;          address_hi_limb (4 bytes)
    ;;          address_lo_limb (16 bytes)
    ;; OPTIONAL nonce_rlp_prefix_limb (if nonce_rlp_prefix_required == 1) (1 byte)
    ;;          nonce_leading_limb (max 16 bytes)
    ;; OPTIONAL nonce_trailing_limb (if nonce_hi_is_nonzero == 1) (max 16 bytes)

    ;; But chain_id is at most 2 bytes and nonce is at most 8 bytes.
    ;;
    ;; output:
    ;; list content (max 33 bytes <= 55 bytes)
    ;;          list_rlp_prefix_limb (1 byte)
    ;; OPTIONAL chain_id_rlp_prefix_limb (if chain_id_rlp_prefix_required == 1) (1 byte)
    ;;          chain_id_leading_limb (max 2 bytes)
    ;;          address_rlp_prefix_limb (1 byte)
    ;;          address_hi_limb (4 bytes)
    ;;          address_lo_limb (16 bytes)
    ;; OPTIONAL nonce_rlp_prefix_limb (if nonce_rlp_prefix_required == 1) (1 byte)
    ;;          nonce_leading_limb (max 8 bytes)

    list_rlp_prefix_limb = 
        0xc0 + ;; list prefix for payload <= 55 bytes
        chain_id_rlp_prefix_required + chain_id_byte_size + ;; chain_id
        1 + 4 + 16 + ;; address
        nonce_rlp_prefix_required + nonce_byte_size ;; nonce
   
    return
}

fn compute_rlp_integer(integer u256) -> (rlp_prefix_required u1, integer_hi_is_nonzero u1, rlp_prefix_limb u128, leading_limb u128, trailing_limb u128, leading_limb_byte_size u8) {
    var integer_hi u128
    var integer_lo u128
    integer_hi, integer_lo = integer

    var integer_is_nonzero u1
    integer_is_nonzero = integer != 0 ? 1 : 0

    integer_hi_is_nonzero = integer_hi != 0 ? 1 : 0

    var integer_greater_or_equal_to_128 u1
    var b u1
    var integer_minus_128_tmp u256
    b, integer_minus_128_tmp = integer - 128
    integer_greater_or_equal_to_128 = b == 0 ? 1 : 0
    rlp_prefix_required = integer_is_nonzero == 0 ? 1 : integer_greater_or_equal_to_128

    var leading_limb_left_shifted u128
    rlp_prefix_limb, leading_limb_left_shifted, leading_limb_byte_size = rlputils(RLP_UTILS_INST_INTEGER, integer_hi, integer_lo, integer_is_nonzero, integer_hi_is_nonzero, rlp_prefix_required)

    leading_limb = leading_limb_left_shifted
    trailing_limb = integer_lo

    ;; output:
    ;; rlp_prefix_limb (if rlp_prefix_required == 1)
    ;; leading_limb
    ;; trailing_limb (if integer_hi_is_nonzero == 1)

    return
}

fn compute_rlp_address(address u160) -> (rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128) {
    ;; address_length = 20 ;; address length is fixed to 20 bytes

    var address_first_byte u8
    var address_other_bytes u152
    address_first_byte, address_other_bytes = address

    ;; address_is_list = 0 ;; address is considered a byte string, not a list

    ;; address_is_nonempty = 1 ;; address length is fixed to 20 bytes

    ;; rlp_prefix_required  = 1 ;; address length is fixed to 20 bytes, thus it is interpretes as a string between 0 and 55 bytes long (0x80 + length prefix)

    var tmp u128
    var rlp_prefix_byte_size u8
    rlp_prefix_limb, tmp, rlp_prefix_byte_size = rlputils(RLP_UTILS_INST_BYTE_STRING_PREFIX, 20, address_first_byte, 0, 1, 1)

    var address_hi u32
    address_hi, address_lo_limb = address
    address_hi_limb = address_hi * 2^96

    ;; output:
    ;; rlp_prefix_limb
    ;; address_hi_limb
    ;; address_lo_limb

    return
}

;; keccak_output is a prediction to be confirmed by the prover
;; fn keccak(keccak_input u184, 
;; keccak_output u256) -> (keccak_fails u1) {
;;     ;; extract keccak_input and assign to limb
;;     var limb u128
;;     var left_aligned_prefix u24
;;     var left_aligned_address_hi u32
;;     var left_aligned_address_lo u128
;;     left_aligned_prefix, left_aligned_address_hi, left_aligned_address_lo = keccak_input
;;     limb = left_aligned_prefix * 2^104
;;     limb = left_aligned_address_hi * 2^96
;;     limb = left_aligned_address_lo
;;     keccak_fails = 0
;;     return
;; }

;; address and success_bit are predictions to be confirmed by the prover 
fn ecrecover(list_rlp_prefix_limb u128, chain_id_rlp_prefix_limb u128, chain_id_leading_limb u128, address_rlp_prefix_limb u128, address_hi_limb u128, address_lo_limb u128, nonce_rlp_prefix_limb u128, nonce_leading_limb u128, chain_id_byte_size u8, nonce_byte_size u8, y_parity u8, r u256, s u256, address u160, success_bit u1) -> (ecrecover_fails u1) {
    var limb u128
    var limb_size u8
    
    limb = y_parity

    var r_lo u128
    limb, r_lo = r ;; r_hi
    limb = r_lo ;; r_lo

    var s_lo u128
    limb, s_lo = s ;; s_hi
    limb = s_lo ;; s_lo

    var address_lo u128
    limb, address_lo = address ;; address_hi
    limb = address_lo ;; address_lo

    limb = success_bit

    ;; fill 8 limbs with zeros
    var b u1
    var i u4
    i = 0
    fill_limb_size_loop:
        limb_size = 0
        b, i = i + 1
        if i != 8 goto fill_limb_size_loop

    limb = MAGIC
    limb = list_rlp_prefix_limb
    limb = chain_id_rlp_prefix_limb ;; may be zero
    limb = chain_id_leading_limb
    limb = address_rlp_prefix_limb
    limb = address_hi_limb
    limb = address_lo_limb
    limb = nonce_rlp_prefix_limb ;; may be zero
    limb = nonce_leading_limb 

    limb_size = 1 ;; MAGIC
    limb_size = 1 ;; list_rlp_prefix_limb
    limb_size = chain_id_byte_size == 0? 0 : 1 ;; chain_id_rlp_prefix_limb
    limb_size = chain_id_byte_size 
    limb_size = 1 ;; address_rlp_prefix_limb
    limb_size = 4 ;; address_hi_limb
    limb_size = 16 ;; address_lo_limb
    limb_size = nonce_byte_size == 0? 0 : 1 ;; nonce_rlp_prefix_limb
    limb_size = nonce_byte_size ;; nonce_leading_limb

    ;; TODO: should we fill explicitly also other columns such as is_signature, is_result, is_message (even if number of rows is fixed)? Shall we extract fill_column_with_value_n_times?
    ecrecover_fails = 0
    return
}

;; TODO: wip
;; fn fill_column_with_value_n_times(column u8, value u8, n u8) -> (dummy u1) {
;;     var b u1
;;     var i u8
;;     i = 0
;;     fill_loop:
;;         column = value
;;         b, i = i + 1
;;         if i != n goto fill_loop
;;     return
;; }