include "../constants/evm.zkasm"
include "../util/padding.zkasm"
include "../util/byte_size.zkasm"
include "../util/max2.zkasm"
include "../util/bit_shl.zkasm"

;; https://eips.ethereum.org/EIPS/eip-7702

pub fn rlpauth(chain_id u256, nonce u64, delegation_address u160, y_parity u8, r u256, s u256,
msg u256, ;; predicted returned value by keccak_for_ecrecover 
authority_address u160, ;; predicticted returned value by ecrecover
macro u1, blk_number u16, user_txn_number u24, txn_from_address u160, authority_is_sender_tot u1, ;; columns for lookup into usertxndata
xtern u1, network_chain_id u256, ;; additional columns for lookup into blockdata
authority_ecrecover_success u1, authority_nonce u256, authority_has_empty_code_or_is_delegated u1) ;; additional columns for lookup into hub
-> (authorization_tuple_is_valid u1)
{
    ;; Preliminary computation
    var delegation_address_is_zero u1
    delegation_address_is_zero = delegation_address == 0 ? 1 : 0

    var sender_is_authority u1
    sender_is_authority = txn_from_address == authority_address ? 1 : 0

    step_1:
        ;; Verify that chain_id is 0 or the ID of the current chain
        if chain_id == 0 goto step_2
        if chain_id == network_chain_id goto step_2
        goto failure
    step_2:
        ;; Check that nonce < 2^64 - 1
        var nonce_is_in_bounds u1
        var nonce_minus_2_to_the_power_of_64_minus_1_tmp u64
        nonce_is_in_bounds, nonce_minus_2_to_the_power_of_64_minus_1_tmp = nonce - (2^64 - 1) 
        if nonce_is_in_bounds == 0 goto failure 
    step_3:
        ;; Check that s <= SECP256K1N_DIVIDED_BY_TWO
        var secp256k1n_is_out_of_bounds u1
        var secp256k1n_divided_by_two_minus_s_tmp u256
        secp256k1n_is_out_of_bounds, secp256k1n_divided_by_two_minus_s_tmp = SECP256K1N_DIVIDED_BY_TWO - s
        if secp256k1n_is_out_of_bounds == 1 goto failure
        
        var rlp_output u320
        
        rlp_output = compute_rlp(chain_id, delegation_address, nonce)
       
        var dummy u1

        dummy = keccak_for_ecrecover(rlp_output, msg)

        dummy = ecrecover(msg, y_parity, r, s, authority_address, authority_ecrecover_success)            
    ;; step_4: happens in the HUB
        ;; Add authority to accessed_addresses, as defined in EIP-2929.
    step_5:
        if authority_has_empty_code_or_is_delegated == 1 goto step_6
        goto failure
    step_6:
        ;; NOTE: the sender_nonce will be incremented after the authority list in Linea; if sender == authority_address (SENDER_IS_AUTHORITY) one must verify authority_nonce + 1 == nonce (TBC)
        if sender_is_authority == 1 goto step_6_with_sender_is_authority
        if sender_is_authority == 0 goto step_6_with_sender_is_not_authority
    step_6_with_sender_is_authority:
        var authority_nonce_plus_one u257 ;; to avoid overflow
        authority_nonce_plus_one = authority_nonce + 1
        if authority_nonce_plus_one == nonce goto exit
        goto failure
    step_6_with_sender_is_not_authority:
        if authority_nonce == nonce goto exit
        goto failure       
    ;; step_7: happens in the HUB
        ;; Add PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST gas to the global refund counter if authority is not empty.
    ;; step_8: 
        ;; TODO: this needs to be done here now probably
        ;; happens in the HUB
        ;; if delegation_address_is_zero goto delegation_address_is_zero_case:
        ;; delegation_address_is_zero_case:
        ;;  authority_code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ;; keccak256 of empty string
        ;;  exit
        ;; authority_code = (0xef0100 * 2^160) + delegation_address
    ;; step_9: happens in the HUB
        ;; authority_nonce = authority_nonce + 1
    exit:
        authorization_tuple_is_valid = 1
        return
    failure:
        authorization_tuple_is_valid = 0
        fail
}

fn compute_rlp(chain_id u256, address u160, nonce u64) -> (rlp_output u320)
{    
    ;; chain_id is assumed to be at most 8 bytes
    var chain_id_rlp u72
    chain_id_rlp = compute_rlp_integer_64_bits(chain_id)

    var address_rlp u168
    address_rlp = ((RLP_PREFIX_INT_SHORT + 20) * 2^160) + address ;; compute rlp address

    var nonce_rlp u72
    nonce_rlp = compute_rlp_integer_64_bits(nonce)

    ;; output (max 40 bytes):
    ;;  list_rlp_prefix (1 byte) since list content max 39 bytes <= 55 bytes
    ;;  chain_id_rlp (max 9 bytes)
    ;;  address_rlp (21 bytes)
    ;;  nonce_rlp (max 9 bytes)

    var chain_id_rlp_byte_size u8
    chain_id_rlp_byte_size = byte_size(chain_id_rlp)
    var nonce_rlp_byte_size u8
    nonce_rlp_byte_size = byte_size(nonce_rlp)

    var list_rlp_prefix u8
    var b u2
    b, list_rlp_prefix = 
        RLP_PREFIX_LIST_SHORT + ;; list prefix for payload <= 55 bytes
        chain_id_rlp_byte_size + ;; chain_id
        21 + ;; address
        nonce_rlp_byte_size ;; nonce

    var nonce_rlp_address_chain_id_byte_size u8
    b, nonce_rlp_address_chain_id_byte_size = nonce_rlp_byte_size + 21 + chain_id_rlp_byte_size
    var nonce_rlp_address_chain_id_bit_size u8
    nonce_rlp_address_chain_id_bit_size = byte_size_to_bit_size(nonce_rlp_address_chain_id_byte_size)

    var nonce_rlp_address_byte_size u8
    b, nonce_rlp_address_byte_size = nonce_rlp_byte_size + 21
    var nonce_rlp_address_bit_size u8
    nonce_rlp_address_bit_size = byte_size_to_bit_size(nonce_rlp_address_byte_size)

    var nonce_rlp_bit_size u8
    nonce_rlp_bit_size = byte_size_to_bit_size(nonce_rlp_byte_size)

    var list_rlp_prefix_left_shifted u256
    list_rlp_prefix_left_shifted = bit_shl256(list_rlp_prefix, nonce_rlp_address_chain_id_bit_size)

    var chain_id_rlp_left_shifted u256
    chain_id_rlp_left_shifted = bit_shl256(chain_id_rlp, nonce_rlp_address_bit_size)

    var address_rlp_left_shifted u256
    address_rlp_left_shifted = bit_shl256(address_rlp, nonce_rlp_bit_size)

    rlp_output = list_rlp_prefix_left_shifted + chain_id_rlp_left_shifted + address_rlp_left_shifted + nonce_rlp

    return
}

fn compute_rlp_integer_64_bits(integer u256) -> (integer_rlp u72) { ;; 8 + 64 (max 9 bytes)
    ;; sanity check
    var integer_hi u192
    var integer_lo u64
    integer_hi, integer_lo = integer
    if integer_hi != 0 goto failure
    
    ;; checking if rlp prefix is required
    var rlp_prefix_required u1
    var integer_greater_or_equal_to_128 u1
    var integer_smaller_than_128 u1
    var integer_minus_128_tmp u64
    integer_smaller_than_128, integer_minus_128_tmp = integer_lo - 128    
    integer_greater_or_equal_to_128 = integer_smaller_than_128 == 0 ? 1 : 0
    rlp_prefix_required = integer_lo == 0 ? 1 : integer_greater_or_equal_to_128

    ;; compute rlp prefix
    var b u1
    var integer_byte_size u8
    var rlp_prefix u8
    integer_byte_size = byte_size(integer_lo)    
    b, rlp_prefix = rlp_prefix_required == 0 ? 0 : RLP_PREFIX_INT_SHORT + integer_byte_size

    var rlp_prefix_left_shifted u256
    var integer_bit_size u8
    integer_bit_size = byte_size_to_bit_size(integer_byte_size)
    rlp_prefix_left_shifted = bit_shl256(rlp_prefix, integer_bit_size)

    var b185 u185 ;; 256 - 72 + 1
    b185, integer_rlp = rlp_prefix_left_shifted + integer_lo
    return

    failure:
        fail
}

;; convert byte size to bit size, fails if 8 * byte_size overflows u8
fn byte_size_to_bit_size(byte_size u8) -> (bit_size u8) {
    var b3 u3
    b3, bit_size = 8 * byte_size
    if b3 != 0 goto failure
    return
    failure:
        fail
}

;; h is a prediction to be confirmed by SHAKIRA
pub fn keccak_for_ecrecover(keccak_input u320, h u256) -> (dummy u1) {
    var limb u128
    var limb_size u8  

    var total_size u32
    total_size = 48 ;; 3 limbs
    
    var keccak_input_without_first_limb u192 ;; 320 - 128
    var keccak_input_without_first_2_limbs u64  ;; 192 - 128

    var h_lo u128

    ;; right-pad keccak_input to 320 bits
    var keccak_input_rpad u320
    keccak_input_rpad = rpad_320(keccak_input)

    ;; limb 
    ;; data
    limb, keccak_input_without_first_limb = keccak_input_rpad
    limb, keccak_input_without_first_2_limbs = keccak_input_without_first_limb
    limb = rpad_128(keccak_input_without_first_2_limbs)

    ;; result
    limb, h_lo = h ;; h_hi
    limb = h_lo ;; h_lo

    var keccak_input_byte_size u8
    keccak_input_byte_size = byte_size_u512(keccak_input)

    ;; limb_size 
    var keccak_input_byte_size_vs_32 u8
    keccak_input_byte_size_vs_32 = max_u8(keccak_input_byte_size, 32)

    var keccak_input_byte_size_vs_16 u8
    keccak_input_byte_size_vs_16 = max_u8(keccak_input_byte_size, 16)

    if keccak_input_byte_size == keccak_input_byte_size_vs_32 goto two_full_limbs_and_one_partial
    if keccak_input_byte_size == keccak_input_byte_size_vs_16 goto one_full_limb_and_one_partial
    goto one_partial_limb

    var b u1
    two_full_limbs_and_one_partial:
        limb_size = 16
        limb_size = 16
        b, limb_size = keccak_input_byte_size - 32
        goto exit

    one_full_limb_and_one_partial:
        limb_size = 16
        b, limb_size = keccak_input_byte_size - 16
        limb_size = 0
        goto exit
    
    one_partial_limb:
        limb_size = keccak_input_byte_size
        limb_size = 0
        limb_size = 0

    ;; lookup to SHAKIRA for keccak computation

    exit:
        dummy = 0
        return
}

pub fn keccak_for_code_hash(address u160, h u256) -> (dummy u1) {
    var limb u128
    var limb_size u8

    var total_size u32
    total_size = 32 ;; 2 limbs

    var keccak_input u184 ;; 24 + 160
    var keccak_input_lo u56 ;; 184 - 128

    var h_lo u128

    keccak_input = (DELEGATION_PREFIX * 2^160) + address

    ;; limb
    ;; data
    limb, keccak_input_lo = keccak_input
    limb = rpad_128(keccak_input_lo)

    ;; result
    limb, h_lo = h ;; h_hi
    limb = h_lo ;; h_lo

    ;; limb_size
    limb_size = 16 
    limb_size = 16 
    limb_size = 7 

    ;; lookup to SHAKIRA for keccak computation

    dummy = 0
    return
}

;; address and success_bit are predictions to be confirmed by ECDATA 
pub fn ecrecover(h u256, y_parity u8, r u256, s u256, address u160, success_bit u1) -> (dummy u1) {
    var limb u128

    var total_size u16
    total_size = 160

    var h_lo u128
    var r_lo u128
    var s_lo u128
    var address_lo u128

    ;; limb
    ;; data
    limb, h_lo = h ;; h_hi
    limb = h_lo ;; h_lo
    limb = 0 ;; v_hi
    limb = y_parity + 27 ;; v_lo
    limb, r_lo = r ;; r_hi
    limb = r_lo ;; r_lo
    limb, s_lo = s ;; s_hi
    limb = s_lo ;; s_lo

    ;; result
    limb, address_lo = address ;; address_hi
    limb = address_lo ;; address_lo

    ;; TODO: shall we fill other columns such as is_signature, is_result, index?
    var is_signature u1
    var is_result u1
    var index u4

    ;; lookup to ECDATA for ecrecover computation
  
    dummy = 0
    return
}