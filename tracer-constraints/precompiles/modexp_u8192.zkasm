;; MODEXP precompile where all input are at most 8192 bits long (ie are 1024 bytes)

fn modexp_u8192(base u8192, exponent u8192, modulus=2 u8192) -> (result=1 u8192){

;; some trivial output
var exp_0, exp_1, base_0 u1
exp_0 = exponent == 0 ? 1 : 0
exp_1 = exponent == 1 ? 1 : 0
base_0 = base == 0 ? 1 : 0
if exponent == 0 goto exit_1
if base == 0 goto exit_0
if exponent == 1 goto exit_modulus

;; exponent = 2*e_next + remainder
;; b ** e mod n == ((b**2) ** e_next mod n) * (b ** remainder mod n)
var e_next u8191
var remainder u1
e_next, remainder = exponent

;; ((b**2) ** e_next mod n) == (b_sq mod (n)) ** e_next mod n
var b_next, res_sq u8192
b_next = mul_mod_8192(base, base, modulus)
res_sq = modexp_u8192(b_next, e_next, modulus)

var tmp_useless u8192
tmp_useless = mul_mod_8192(res_sq, base, modulus)
result = remainder == 1 ? tmp_useless : res_sq
return

exit_modulus:
result = modulus_u16384_u8192(base, modulus)
return

exit_0:
result = 0
return

exit_1:
result = 1
return
}

fn mul_mod_8192(A u8192, B u8192, M u8192) -> (RES u8192) {
  var tmp u16384
  tmp = A * B
  RES = modulus_u16384_u8192(tmp, M)
  return
}

fn divide_u8192(num u8192, den=1 u8192) -> (rem u8192) {
  var quot u8192
  var sum u16385
  var witsum u8193
  var witness u8192
  ;; handle division by 0
  if den == 0 goto exit_0
  ;;
  quot, rem, witness, sum, witsum = num / den
  ;;
  return
exit_0:
  rem = 0
  return
}

fn modulus_u16384_u8192(A u16384, M u8192) -> (RES u8192) {
  var quot u16384
  var sum u24576
  var witsum u8193
  var witness u8192
  ;; handle division by 0
  var is_M_zero u1
  is_M_zero = M == 0 ? 1 : 0
  if is_M_zero == 1 goto exit_0
  quot, RES, witness, sum, witsum = A / M
  return
exit_0:
  RES = 0
  return
}
