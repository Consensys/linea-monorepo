;; Rotate right a u64 word

fn bit_ror64(word u64, n u6) -> (res u64) {
      if n == 0  goto unchanged
      var b u1
      var m u5
      var msw u32
      var lsw u32
      ;; decompose shift
      b,m = n
      ;;
      if b!=0 goto apply
      res = bit_ror64_u5(word,m)
      return
apply:
      msw, lsw = word
      res = bit_ror64_u5((2^32*lsw) + msw,m)
      return
unchanged:
      res = word
      return
}

fn bit_ror64_u5(word u64, n u5) -> (res u64) {
      var b u1
      var m u4
      var msw u48
      var lsw u16
      ;; decompose shift
      b,m = n
      ;;
      if b!=0 goto apply
      res = bit_ror64_u4(word,m)
      return
apply:
      msw, lsw = word
      res = bit_ror64_u4((2^48*lsw) + msw,m)
      return
}

fn bit_ror64_u4(word u64, n u4) -> (res u64) {
      var b u1
      var m u3
      var msw u56
      var lsw u8
      ;; decompose shift
      b,m = n
      ;;
      if b!=0 goto apply
      res = bit_ror64_u3(word,m)
      return
apply:
      msw, lsw = word
      res = bit_ror64_u3((2^56*lsw) + msw,m)
      return
}

fn bit_ror64_u3(word u64, n u3) -> (res u64) {
      var b u1
      var m u2
      var msw u60
      var lsw u4
      ;; decompose shift
      b,m = n
      ;;
      if b!=0 goto apply
      res = bit_ror64_u2(word,m)
      return
apply:
      msw, lsw = word
      res = bit_ror64_u2((2^60*lsw) + msw,m)
      return
}

fn bit_ror64_u2(word u64, n u2) -> (res u64) {
      var b u1
      var m u1
      var msw u62
      var lsw u2
      ;; decompose shift
      b,m = n
      ;;
      if b!=0 goto apply
      res = bit_ror64_u1(word,m)
      return
apply:
      msw, lsw = word
      res = bit_ror64_u1((2^62*lsw) + msw,m)
      return
}

fn bit_ror64_u1(word u64, n u1) -> (res u64) {
      var lsw u1
      if n!=0 goto apply
      res = word
      return
apply:
      var hi u63
      hi, lsw = word
      res = (lsw * 2^63) + hi
      return
}