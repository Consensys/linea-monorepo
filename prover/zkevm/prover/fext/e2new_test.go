// Copyright 2020 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fext

import (
	"crypto/rand"
	"fmt"
	"github.com/consensys/gnark-crypto/ecc/bls12-377/fr"
	"testing"

	"github.com/consensys/gnark-crypto/ecc/bls12-377/fp"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
)

// ------------------------------------------------------------
// tests

func GenFr() gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		var elmt fr.Element

		if _, err := elmt.SetRandom(); err != nil {
			panic(err)
		}
		genResult := gopter.NewGenResult(elmt, gopter.NoShrinker)
		return genResult
	}
}

func GenE2New() gopter.Gen {
	return gopter.CombineGens(
		GenFr(),
		GenFr(),
	).Map(func(values []interface{}) *Element {
		return &Element{A0: values[0].(fr.Element), A1: values[1].(fr.Element)}
	})
}

func TestE2NewNewReceiverIsOperand(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genA := GenE2New()
	genB := GenE2New()
	GenFr := GenFr()

	properties.Property("[BLS12-377] Having the receiver as operand (addition) should output the same result", prop.ForAll(
		func(a, b *Element) bool {
			var c, d Element
			d.Set(a)
			c.Add(a, b)
			a.Add(a, b)
			b.Add(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (sub) should output the same result", prop.ForAll(
		func(a, b *Element) bool {
			var c, d Element
			d.Set(a)
			c.Sub(a, b)
			a.Sub(a, b)
			b.Sub(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (mul) should output the same result", prop.ForAll(
		func(a, b *Element) bool {
			var c, d Element
			d.Set(a)
			c.Mul(a, b)
			a.Mul(a, b)
			b.Mul(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (square) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Square(a)
			a.Square(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (neg) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Neg(a)
			a.Neg(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (double) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Double(a)
			a.Double(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (mul by non residue) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.MulByNonResidue(a)
			a.MulByNonResidue(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (mul by non residue inverse) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.MulByNonResidueInv(a)
			a.MulByNonResidueInv(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (Inverse) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Inverse(a)
			a.Inverse(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (Conjugate) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Conjugate(a)
			a.Conjugate(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (mul by element) should output the same result", prop.ForAll(
		func(a *Element, b fr.Element) bool {
			var c Element
			c.MulByElement(a, &b)
			a.MulByElement(a, &b)
			return a.Equal(&c)
		},
		genA,
		GenFr,
	))

	properties.Property("[BLS12-377] Having the receiver as operand (Sqrt) should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b, c, d, s Element

			s.Square(a)
			a.Set(&s)
			b.Set(&s)

			a.Sqrt(a)
			b.Sqrt(&b)

			c.Square(a)
			d.Square(&b)
			return c.Equal(&d)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))

}

/*
func TestE2NewMulMaxed(t *testing.T) {
	// let's pick a and b, with maxed A0 and A1
	var a, b Element
	fpMaxValue := fp.Element{
		9586122913090633729,
		1660523435060625408,
		2230234197602682880,
		1883307231910630287,
		14284016967150029115,
		121098312706494698,
	}
	fpMaxValue[0]--

	a.A0 = fpMaxValue
	a.A1 = fpMaxValue
	b.A0 = fpMaxValue
	b.A1 = fpMaxValue

	var c, d Element
	d.Inverse(&b)
	c.Set(&a)
	c.Mul(&c, &b).Mul(&c, &d)
	if !c.Equal(&a) {
		t.Fatal("mul with max fp failed")
	}
}*/

func TestE2NewOps(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genA := GenE2New()
	genB := GenE2New()
	GenFr := GenFr()

	properties.Property("[BLS12-377] sub & add should leave an element invariant", prop.ForAll(
		func(a, b *Element) bool {
			var c Element
			c.Set(a)
			c.Add(&c, b).Sub(&c, b) // a+b-b
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[BLS12-377] mul & inverse should leave an element invariant", prop.ForAll(
		func(a, b *Element) bool {
			var c, d Element
			d.Inverse(b)
			c.Set(a)
			c.Mul(&c, b).Mul(&c, &d)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[BLS12-377] BatchInvertE2New should output the same result as Inverse", prop.ForAll(
		func(a, b, c *Element) bool {

			batch := BatchInvertE2New([]Element{*a, *b, *c})
			a.Inverse(a)
			b.Inverse(b)
			c.Inverse(c)
			return a.Equal(&batch[0]) && b.Equal(&batch[1]) && c.Equal(&batch[2])
		},
		genA,
		genA,
		genA,
	))

	properties.Property("[BLS12-377] inverse twice should leave an element invariant", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Inverse(a).Inverse(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] neg twice should leave an element invariant", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Neg(a).Neg(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] square and mul should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b, c Element
			b.Mul(a, a)
			c.Square(a)
			res := b.Equal(&c)
			fmt.Println("square and mul should output the same result———", res)
			return b.Equal(&c)
		},
		genA,
	))

	properties.Property("[BLS12-377] MulByElement MulByElement inverse should leave an element invariant", prop.ForAll(
		func(a *Element, b fr.Element) bool {
			var c Element
			var d fr.Element
			d.Inverse(&b)
			c.MulByElement(a, &b).MulByElement(&c, &d)
			return c.Equal(a)
		},
		genA,
		GenFr,
	))

	properties.Property("[BLS12-377] Double and mul by 2 should output the same result", prop.ForAll(
		func(a *Element) bool {
			var b Element
			var c fr.Element
			c.SetUint64(2)
			b.Double(a)
			a.MulByElement(a, &c)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Mulbynonres mulbynonresinv should leave the element invariant", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.MulByNonResidue(a).MulByNonResidueInv(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] a + pi(a), a-pi(a) should be real", prop.ForAll(
		func(a *Element) bool {
			var b, c, d Element
			var e, f fr.Element
			b.Conjugate(a)
			c.Add(a, &b)
			d.Sub(a, &b)
			e.Double(&a.A0)
			f.Double(&a.A1)
			return c.A1.IsZero() && d.A0.IsZero() && e.Equal(&c.A0) && f.Equal(&d.A1)
		},
		genA,
	))

	properties.Property("[BLS12-377] Legendre on square should output 1", prop.ForAll(
		func(a *Element) bool {
			var b Element
			b.Mul(a, a)
			c := b.Legendre()
			fmt.Println("DEBUG MESSAGE ", c)
			return c == 1
		},
		genA,
	))

	/*
		properties.Property("[BLS12-377] square(sqrt) should leave an element invariant", prop.ForAll(
			func(a *Element) bool {
				var b, c, d, e Element
				b.Square(a)
				c.Sqrt(&b)
				d.Square(&c)
				e.Neg(a)
				return (c.Equal(a) || c.Equal(&e)) && d.Equal(&b)
			},
			genA,
		))

	*/

	properties.Property("[BLS12-377] neg(Element) == neg(Element.A0, Element.A1)", prop.ForAll(
		func(a *Element) bool {
			var b, c Element
			b.Neg(a)
			c.A0.Neg(&a.A0)
			c.A1.Neg(&a.A1)
			return c.Equal(&b)
		},
		genA,
	))

	properties.Property("[BLS12-377] Cmp and LexicographicallyLargest should be consistent", prop.ForAll(
		func(a *Element) bool {
			var negA Element
			negA.Neg(a)
			cmpResult := a.Cmp(&negA)
			lResult := a.LexicographicallyLargest()
			if lResult && cmpResult == 1 {
				return true
			}
			if !lResult && cmpResult != 1 {
				return true
			}
			return false
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))

}

// ------------------------------------------------------------
// benches

func BenchmarkE2NewAdd(b *testing.B) {
	var a, c Element
	_, _ = a.SetRandom()
	_, _ = c.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Add(&a, &c)
	}
}

func BenchmarkE2NewSub(b *testing.B) {
	var a, c Element
	_, _ = a.SetRandom()
	_, _ = c.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sub(&a, &c)
	}
}

func BenchmarkE2NewMul(b *testing.B) {
	var a, c Element
	_, _ = a.SetRandom()
	_, _ = c.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Mul(&a, &c)
	}
}

func BenchmarkE2NewMulByElement(b *testing.B) {
	var a Element
	var c fr.Element
	_, _ = c.SetRandom()
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByElement(&a, &c)
	}
}

func BenchmarkE2NewSquare(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Square(&a)
	}
}

func BenchmarkE2NewSqrt(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sqrt(&a)
	}
}

func BenchmarkE2NewExp(b *testing.B) {
	var x Element
	_, _ = x.SetRandom()
	b1, _ := rand.Int(rand.Reader, fp.Modulus())
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		x.Exp(x, b1)
	}
}

func BenchmarkE2NewInverse(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Inverse(&a)
	}
}

func BenchmarkE2NewMulNonRes(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByNonResidue(&a)
	}
}

func BenchmarkE2NewMulNonResInv(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByNonResidueInv(&a)
	}
}

func BenchmarkE2NewConjugate(b *testing.B) {
	var a Element
	_, _ = a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Conjugate(&a)
	}
}

func TestE2NewDiv(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	properties := gopter.NewProperties(parameters)

	genA := GenE2New()
	genB := GenE2New()

	properties.Property("[BLS12-377] dividing then multiplying by the same element does nothing", prop.ForAll(
		func(a, b *Element) bool {
			var c Element
			c.Div(a, b)
			c.Mul(&c, b)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestBasicQnrEquality(t *testing.T) {
	var xCoeff = [...]int64{1, 3, 3}
	var yCoeff = [...]int64{2, 1, 2}
	var zCoeff = [...]int64{-43, -2, -35}
	var wCoeff = [...]int64{4, 6, 12}

	for i := 0; i < len(xCoeff); i++ {
		x := new(fr.Element).SetInt64(xCoeff[i])
		y := new(fr.Element).SetInt64(yCoeff[i])
		z := new(fr.Element).SetInt64(zCoeff[i])
		w := new(fr.Element).SetInt64(wCoeff[i])
		a := Element{*x, *y}
		c := new(Element)
		c.Mul(&a, &a)
		d := Element{*z, *w}
		res := c.Equal(&d)
		fmt.Println(res)
	}

}

func TestBasicQnrEqualitySquare(t *testing.T) {
	var xCoeff = [...]int64{1, 3, 3}
	var yCoeff = [...]int64{2, 1, 2}
	var zCoeff = [...]int64{-43, -2, -35}
	var wCoeff = [...]int64{4, 6, 12}
	for i := 0; i < len(xCoeff); i++ {
		x := new(fr.Element).SetInt64(xCoeff[i])
		y := new(fr.Element).SetInt64(yCoeff[i])
		z := new(fr.Element).SetInt64(zCoeff[i])
		w := new(fr.Element).SetInt64(wCoeff[i])
		a := Element{*x, *y}
		c := new(Element)
		c.Square(&a)
		d := Element{*z, *w}
		res := c.Equal(&d)
		//fmt.Println(c.A0.String(), c.A1.String())
		fmt.Println(c.String())
		fmt.Println(d.String())
		fmt.Println(res)
	}

}
