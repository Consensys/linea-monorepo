package recursion

import (
	"strconv"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/witness"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/linea-monorepo/prover/crypto/state-management/smt"
	vCom "github.com/consensys/linea-monorepo/prover/crypto/vortex"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/accessors"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/selfrecursion"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/vortex"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/internal/plonkinternal"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/utils"
)

// Recursion is a collection of wizard items composing a wizard circuit
// for recursion. The recursion operates over a wizard proof for a
// protocol featuring the [vortex.Compile] such that the runtime only
// goes through the vortex commitments and stops just before the opening.
//
// The [Recursion] takes over at this moment and the reason is that it
// allows us to combine the self-recursion (a.k.a vortex verifier in
// wizard) with the plonk-in-wizard verifier. This allows for more
// efficiency.
type Recursion struct {

	// Name is a name used to prefix all the wizard items generated by the
	// present [Recursion].
	Name string

	// Subscript is an optional parameter that allows providing more context
	// than [Name] alone. It is not used to derive the name of the columns
	// and queries of the recursion.
	Subscript string

	// InputCompiledIOP is the input compiled-IOP whose proofs are to be
	// recursed.
	InputCompiledIOP *wizard.CompiledIOP

	// Round is an optional parameter that allows the caller to specify
	// which round of the input proof they want to use. If not specified,
	// the initial round is used.
	Round int

	// PlonkCtx is the [PlonkInWizard] context that we use to verify the
	// non-vortex part of the input wizard proof. Namely, it runs all its
	// verifier actions and the corresponding circuit assignments.
	PlonkCtx plonkinternal.PlonkInWizardProverAction

	// PcsCtx represents the compilation context to pass to the self-recursion
	// context. For clarity, this is not the compilation context of the
	// input proof but the "translated" one that is built by the recursion.
	PcsCtx []*vortex.Ctx
}

// Witness represents the witness for a single recursion
type Witness struct {

	// Proof is the wizard proof to recurse
	Proof wizard.Proof

	// Pub is the list of the public inputs for the proof
	Pub []field.Element

	// FinalFS is the final Fiat-Shamir state of the protocol
	FinalFS field.Element

	// CommittedMatrices are the list of the Reed-Solomon matrices
	// for each committed round. They are needed by the prover of the self-recursion.
	CommittedMatrices []vCom.EncodedMatrix

	// SisHashes is the list of the SIS hashes of the vortex columns
	// for each committed round. They are needed by the prover of the self-recursion.
	SisHashes [][]field.Element

	// MimcHashes is the list of the Vortex columns that are not
	// hashed using SIS. They are needed by the prover of the self-recursion.
	MimcHashes [][]field.Element

	// Trees are the list of the commitment merkle trees. They are needed
	// by the prover of the self-recursion.
	Trees []*smt.Tree
}

// GetStoppingRound returns the number of rounds to pass to [wizard.RunProverUntil]
// in order to reach the end of the vortex commitment phase and stop just
// before the opening.
func (r *Recursion) GetStoppingRound() int {
	qName := r.InputCompiledIOP.PcsCtxs.(*vortex.Ctx).Query.QueryID
	return r.InputCompiledIOP.QueriesParams.Round(qName)
}

// Parameters is a collection of parameters for the recursion.
type Parameters struct {
	// Name is a name used to prefix all the wizard items generated by the
	// present [DefineRecursionOf] function.
	Name string

	// Subscript is an optional parameter that allows providing more context
	// than [Name] alone. It is not used to derive the name of the columns
	// and queries of the recursion.
	Subscript string

	// WithoutGkr is a flag that indicates if the recursion is run without GKR
	WithoutGkr bool

	// MaxNumProof controls the number of proofs to be recursed at once. It
	// is a mandatory parameter and must be a positive integer.
	MaxNumProof int

	// FixedNbRowPlonkCircuit is a flag indicating that the Plonk circuit should
	// be built with a fixed number of rows.
	FixedNbRowPlonkCircuit int

	// ExternalHasherNbRows is a flag indicating that the MiMC circuit should
	// be built with a fixed number of rows.
	ExternalHasherNbRows int

	// WithExternalHasherOpts is a flag indicating that the recursion circuit should
	// be built using the external hasher builder.
	WithExternalHasherOpts bool
}

// DefineRecursionOf builds a recursion sub-circuit into 'comp' for verifying
// 'inputComp' and returns the recursion context. 'inputComp' is expected to
// be compiled with the [vortex.Compile] compiler with the options
// [PremarkAsSelfRecursed].
//
// To assign the recursion, use [Assign] and make sure the input compiled
// IOP is run using [wizard.RunProverUntil] passing the return value of
// [GetStoppingRound].
func DefineRecursionOf(comp, inputComp *wizard.CompiledIOP, params Parameters) *Recursion {

	plonkOpts := []plonkinternal.Option{}
	if params.FixedNbRowPlonkCircuit > 0 {
		plonkOpts = append(plonkOpts, plonkinternal.WithFixedNbRows(params.FixedNbRowPlonkCircuit))
	}

	if params.WithExternalHasherOpts {
		plonkOpts = append(plonkOpts, plonkinternal.WithExternalHasher(params.ExternalHasherNbRows))
	}

	if len(params.Subscript) > 0 {
		plonkOpts = append(plonkOpts, plonkinternal.WithSubscript(params.Subscript))
	}

	if !params.WithoutGkr && params.WithExternalHasherOpts {
		utils.Panic("inconsistent choice, cannot use GKR and external hasher together")
	}

	var (
		plonkCircuit = AllocRecursionCircuit(inputComp, params.WithoutGkr, params.WithExternalHasherOpts)
		plonkCtx     = plonkinternal.PlonkCheck(comp, params.Name, 0, plonkCircuit, params.MaxNumProof, plonkOpts...)
		vortexCtxs   = make([]*vortex.Ctx, params.MaxNumProof)
		numYs        = len(plonkCircuit.Ys)
		numComs      = len(plonkCircuit.Commitments)
		// pubInputOffset corresponds to the positions of the public inputs
		// in the plonk-in-wizard public witness. They are at
		// 		pubInputOffset:pubInputOffset+numPubs
		pubInputOffset = 1 + numYs + numComs
	)

	for i := 0; i < params.MaxNumProof; i++ {

		translator := &compTranslator{
			Prefix: params.Name + "-" + strconv.Itoa(i),
			Target: comp,
		}

		dstVortexCtx := createNewPcsCtx(translator, inputComp)
		vortexCtxs[i] = dstVortexCtx

		for k := range inputComp.PublicInputs {

			comp.InsertPublicInput(
				addPrefixToID(translator.Prefix, inputComp.PublicInputs[k].Name),
				accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+k),
			)
		}
	}

	rec := &Recursion{
		Name:             params.Name,
		PcsCtx:           vortexCtxs,
		PlonkCtx:         plonkCtx.GetPlonkProverAction(),
		InputCompiledIOP: inputComp,
	}

	comp.RegisterVerifierAction(0, &ConsistencyCheck{Ctx: rec, PIs: plonkCtx.Columns.PI})
	comp.RegisterProverAction(1, AssignVortexUAlpha{Ctxs: rec})
	comp.RegisterProverAction(2, AssignVortexOpenedCols{Ctxs: rec})

	// Importantly, this must happen after the "vortex" actions are registered
	// otherwise the items to self-recurse are not well-defined.
	for i := range rec.PcsCtx {
		selfrecursion.RecurseOverCustomCtx(comp, rec.PcsCtx[i], params.Name+"-"+strconv.Itoa(i))
	}

	return rec
}

// GetMainProverStep returns a prover step assigning the provided witness.
// It can be used for circuits where the only thing happening is the recursion.
//
// Filling is an optional parameter used if len(wit) < maxNumProof.
func (r *Recursion) GetMainProverStep(wit []Witness, filling *Witness) wizard.MainProverStep {
	return func(run *wizard.ProverRuntime) {
		r.Assign(run, wit, filling)
	}
}

// Assign assigns the items generated for the recursion of an item. As a first
// steps, the function assigns the Plonk-in-Wizard context. Then, it assigns
// the "merkle-roots" columns of the PCS.
func (r *Recursion) Assign(run *wizard.ProverRuntime, _wit []Witness, _filling *Witness) {

	var (
		// wit is reallocated because we are going to append to it and it
		// may mutate _wit in unexpected ways.
		wit           = append([]Witness(nil), _wit...)
		nbProofActual = len(wit)
		maxNbProof    = len(r.PcsCtx)
		fullWitnesses = make([]witness.Witness, len(r.PcsCtx))
		err           error
	)

	// When we have less proofs than the max
	for i := 0; i < maxNbProof; i++ {

		filling := _filling
		if filling == nil {
			filling = &_wit[0]
		}

		if i >= nbProofActual {
			wit = append(wit, *filling)
		}
	}

	for i := range wit {

		// Assigns the plonk-in-wizard context. We do so by providing a witness
		var (
			prefix = r.Name + "-" + strconv.Itoa(i)
			assign = AssignRecursionCircuit(r.InputCompiledIOP, wit[i].Proof, wit[i].Pub, wit[i].FinalFS)
		)

		fullWitnesses[i], err = frontend.NewWitness(assign, ecc.BLS12_377.ScalarField())
		if err != nil {
			utils.Panic("could not create witness: %v", err)
		}

		// Uses the assignment to assigns the merkle-roots columns.
		for j := range assign.Commitments {
			colName := addPrefixToID(prefix, assign.MerkleRoots[j].GetColID())

			// One of the Merkle root may be the root to the precomputed
			// polynomials and it may be of type precomputed ("may be", not
			// "is") and thus may not be assignable.
			if run.Spec.Precomputed.Exists(colName) {
				continue
			}

			x := assign.Commitments[j].(field.Element)
			run.AssignColumn(colName, smartvectors.NewConstant(x, 1))
		}

		// Assigns the poly query.
		params := wit[i].Proof.QueriesParams.MustGet(assign.PolyQuery.QueryID).(query.UnivariateEvalParams)
		run.AssignUnivariate(r.PcsCtx[i].Query.QueryID, params.X, params.Ys...)

		// Store the self-recursion artefacts for the vortex prover and the
		// self-recursion prover.
		numRound := max(len(wit[i].CommittedMatrices), len(wit[i].SisHashes), len(wit[i].Trees))
		for round := 0; round < numRound; round++ {

			if round < len(wit[i].CommittedMatrices) && wit[i].CommittedMatrices[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].VortexProverStateName(round), wit[i].CommittedMatrices[round])
			}

			if round < len(wit[i].SisHashes) && wit[i].SisHashes[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].SisHashName(round), wit[i].SisHashes[round])
			}

			if round < len(wit[i].Trees) && wit[i].Trees[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].MerkleTreeName(round), wit[i].Trees[round])
			}

			if round < len(wit[i].MimcHashes) && wit[i].MimcHashes[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].MIMCHashName(round), wit[i].MimcHashes[round])
			}
		}
	}

	r.PlonkCtx.Run(run, fullWitnesses)
}

// GetPublicInputOfInstance relative to one recursed module.
func (rec *Recursion) GetPublicInputOfInstance(run wizard.Runtime, name string, inst int) field.Element {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return run.GetPublicInput(name)
}

// GetPublicInputOfInstanceGnark returns the requested public input in a
// gnark circuit context.
func (rec *Recursion) GetPublicInputOfInstanceGnark(api frontend.API, run wizard.GnarkRuntime, name string, inst int) frontend.Variable {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return run.GetPublicInput(api, name)
}

// GetPublicInputAccessorOfInstance returns the accessor of a public input
// relative to one recursed module.
func (rec *Recursion) GetPublicInputAccessorOfInstance(comp *wizard.CompiledIOP, name string, inst int) ifaces.Accessor {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return comp.GetPublicInputAccessor(name)
}

// VortexQueryRound returns the round at which the last commitment
// is made.
func VortexQueryRound(comp *wizard.CompiledIOP) int {
	vortexPCS := comp.PcsCtxs.(*vortex.Ctx)
	query := vortexPCS.Query
	return comp.QueriesParams.Round(query.QueryID)
}

// createNewPcsCtx creates a mirror for a vortex compilation context into
// comp. The mirror has all its commitments defined at the initial round
// and the "vortex proof" columns are inserted starting at round 1 (after
// vortex.alpha has been sampled).
func createNewPcsCtx(translator *compTranslator, srcComp *wizard.CompiledIOP) *vortex.Ctx {

	srcVortexCtx := srcComp.PcsCtxs.(*vortex.Ctx)

	if !srcVortexCtx.IsSelfrecursed {
		utils.Panic("the input vortex ctx is expected to be selfrecursed. Please make sure the input comp has been last compiled by Vortex with the option [vortex.PremarkAsSelfRecursed]")
	}

	dstVortexCtx := &vortex.Ctx{
		// Direct Copy
		RunStateNamePrefix:    translator.Prefix,
		BlowUpFactor:          srcVortexCtx.BlowUpFactor,
		ApplySISHashThreshold: srcVortexCtx.ApplySISHashThreshold,
		CommittedRowsCount:    srcVortexCtx.CommittedRowsCount,
		CommittedRowsCountSIS: srcVortexCtx.CommittedRowsCountSIS,
		NumCols:               srcVortexCtx.NumCols,
		MaxCommittedRound:     srcVortexCtx.MaxCommittedRound,
		NumOpenedCol:          srcVortexCtx.NumOpenedCol,
		VortexParams:          srcVortexCtx.VortexParams,
		SisParams:             srcVortexCtx.SisParams,
		RoundStatus:           srcVortexCtx.RoundStatus,

		// Copy via the translator
		IsSelfrecursed:                            true,
		CommitmentsByRounds:                       translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRounds),
		CommitmentsByRoundsSIS:                    translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRoundsSIS),
		CommitmentsByRoundsNonSIS:                 translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRoundsNonSIS),
		PolynomialsTouchedByTheQuery:              translator.TranslateColumnSet(srcVortexCtx.PolynomialsTouchedByTheQuery),
		ShadowCols:                                translator.TranslateColumnSet(srcVortexCtx.ShadowCols),
		Query:                                     translator.AddUniEval(0, srcVortexCtx.Query),
		AddMerkleRootToPublicInputsOpt:            srcVortexCtx.AddMerkleRootToPublicInputsOpt,
		AddPrecomputedMerkleRootToPublicInputsOpt: srcVortexCtx.AddPrecomputedMerkleRootToPublicInputsOpt,
	}

	translator.Target.QueriesParams.MarkAsIgnored(dstVortexCtx.Query.QueryID)

	if srcVortexCtx.IsNonEmptyPrecomputed() {
		dstVortexCtx.Items.Precomputeds.PrecomputedColums = translator.AddColumnList(srcVortexCtx.Items.Precomputeds.PrecomputedColums, true, 0)

		// If the vortex compilation is done with the [AddPrecomputedMerkleRootToPublicInputsOpt]
		// option, then the [MerkleRoot] column will not actually be a
		// precomputed column. In this case, we cannot use the same function of
		// the translator to add the column in the dst compilation context.
		mRootCol := srcVortexCtx.Items.Precomputeds.MerkleRoot
		if srcComp.Precomputed.Exists(mRootCol.GetColID()) {
			dstVortexCtx.Items.Precomputeds.MerkleRoot = translator.AddPrecomputed(srcComp, mRootCol)
		} else {
			dstVortexCtx.Items.Precomputeds.MerkleRoot = translator.AddColumnAtRound(mRootCol, false, 0)
		}

		dstVortexCtx.Items.Precomputeds.CommittedMatrix = srcVortexCtx.Items.Precomputeds.CommittedMatrix
		dstVortexCtx.Items.Precomputeds.DhWithMerkle = srcVortexCtx.Items.Precomputeds.DhWithMerkle
		dstVortexCtx.Items.Precomputeds.Tree = srcVortexCtx.Items.Precomputeds.Tree
	}

	dstVortexCtx.Items.MerkleRoots = translator.AddColumnList(srcVortexCtx.Items.MerkleRoots, false, 0)
	dstVortexCtx.Items.Alpha = translator.AddCoinAtRound(srcVortexCtx.Items.Alpha, 1)
	dstVortexCtx.Items.Ualpha = translator.AddColumnAtRound(srcVortexCtx.Items.Ualpha, false, 1)
	dstVortexCtx.Items.Q = translator.AddCoinAtRound(srcVortexCtx.Items.Q, 2)
	dstVortexCtx.Items.MerkleProofs = translator.AddColumnAtRound(srcVortexCtx.Items.MerkleProofs, false, 2)
	dstVortexCtx.Items.OpenedColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedColumns, false, 2)
	dstVortexCtx.Items.OpenedSISColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedSISColumns, false, 2)
	dstVortexCtx.Items.OpenedNonSISColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedNonSISColumns, false, 2)

	return dstVortexCtx
}
