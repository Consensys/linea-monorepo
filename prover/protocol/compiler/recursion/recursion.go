package recursion

import (
	"strconv"

	"github.com/consensys/gnark/backend/witness"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/linea-monorepo/prover/crypto/state-management/smt_koalabear"
	"github.com/consensys/linea-monorepo/prover/crypto/vortex/vortex_koalabear"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/maths/field/fext"
	"github.com/consensys/linea-monorepo/prover/maths/field/koalagnark"
	"github.com/consensys/linea-monorepo/prover/protocol/accessors"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/selfrecursion"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/vortex"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/plonkinternal"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/utils"
)

const blockSize = 8

// Recursion is a collection of wizard items composing a wizard circuit
// for recursion. The recursion operates over a wizard proof for a
// protocol featuring the [vortex.Compile] such that the runtime only
// goes through the vortex commitments and stops just before the opening.
//
// The [Recursion] takes over at this moment and the reason is that it
// allows us to combine the self-recursion (a.k.a vortex verifier in
// wizard) with the plonk-in-wizard verifier. This allows for more
// efficiency.
type Recursion struct {
	// Name is a name used to prefix all the wizard items generated by the
	// present [Recursion].
	Name string

	// Subscript is an optional parameter that allows providing more context
	// than [Name] alone. It is not used to derive the name of the columns
	// and queries of the recursion.
	Subscript string

	// InputCompiledIOP is the input compiled-IOP whose proofs are to be
	// recursed.
	InputCompiledIOP *wizard.CompiledIOP

	// Round is an optional parameter that allows the caller to specify
	// which round of the input proof they want to use. If not specified,
	// the initial round is used.
	Round int

	// PlonkCtx is the [PlonkInWizard] context that we use to verify the
	// non-vortex part of the input wizard proof. Namely, it runs all its
	// verifier actions and the corresponding circuit assignments.
	PlonkCtx plonkinternal.PlonkInWizardProverAction

	// PcsCtx represents the compilation context to pass to the self-recursion
	// context. For clarity, this is not the compilation context of the
	// input proof but the "translated" one that is built by the recursion.
	PcsCtx []*vortex.Ctx
}

// Witness represents the witness for a single recursion
type Witness struct {
	// Proof is the wizard proof to recurse
	Proof wizard.Proof

	// Pub is the list of the public inputs for the proof
	Pub []fext.GenericFieldElem

	// FinalFS is the final Fiat-Shamir state of the protocol
	FinalFS field.Octuplet

	// CommittedMatrices are the list of the Reed-Solomon matrices
	// for each committed round. They are needed by the prover of the self-recursion.
	CommittedMatrices []vortex_koalabear.EncodedMatrix

	// SisHashes is the list of the SIS hashes of the vortex columns
	// for each committed round. They are needed by the prover of the self-recursion.
	SisHashes [][]field.Element

	// Poseidon2Hashes is the list of the Vortex columns that are not
	// hashed using SIS. They are needed by the prover of the self-recursion.
	Poseidon2Hashes [][]field.Element

	// Trees are the list of the commitment merkle trees. They are needed
	// by the prover of the self-recursion.
	Trees []*smt_koalabear.Tree
}

// GetStoppingRound returns the number of rounds to pass to [wizard.RunProverUntil]
// in order to reach the end of the vortex commitment phase and stop just
// before the opening.
func (r *Recursion) GetStoppingRound() int {
	qName := r.InputCompiledIOP.PcsCtxs.(*vortex.Ctx).Query.QueryID
	return r.InputCompiledIOP.QueriesParams.Round(qName)
}

// Parameters is a collection of parameters for the recursion.
type Parameters struct {
	// Name is a name used to prefix all the wizard items generated by the
	// present [DefineRecursionOf] function.
	Name string

	// Subscript is an optional parameter that allows providing more context
	// than [Name] alone. It is not used to derive the name of the columns
	// and queries of the recursion.
	Subscript string

	// MaxNumProof controls the number of proofs to be recursed at once. It
	// is a mandatory parameter and must be a positive integer.
	MaxNumProof int

	// FixedNbRowPlonkCircuit is a flag indicating that the Plonk circuit should
	// be built with a fixed number of rows.
	FixedNbRowPlonkCircuit int

	// FixedNbPublicInput is a flag indicating that the Plonk circuit should
	// be built with a fixed number of public inputs.
	FixedNbPublicInput int

	// ExternalHasherNbRows is a flag indicating that the MiMC circuit should
	// be built with a fixed number of rows.
	ExternalHasherNbRows int

	// WithExternalHasherOpts is a flag indicating that the recursion circuit should
	// be built using the external hasher builder.
	WithExternalHasherOpts bool

	// SkipRecursionPrefix indicates that the compilation of the recursion
	// should not add a prefix to the recursed public-inputs. When set to true,
	// the public inputs will be named exactly as in the input IOP. Otherwise,
	// the public input are prefixed with `[Parameters.Name]_[i : the ID of the
	// instance]`. If SkipRecursionPrefix is set to true, then
	// [DefinedRecursionOf] will assert that [Parameters.MaxNumProof] is 1;
	// otherwise, there would be a naming conflict.
	SkipRecursionPrefix bool

	// RestrictPublicInputs specifies the list of the public inputs from the
	// initial IOP to be re-exposed as public inputs in the recursion circuit.
	//
	// /!\ : Passing []string{} will expose NO public inputs. But passing 'nil'
	// will expose ALL the public inputs.
	RestrictPublicInputs []string
}

// DefineRecursionOf builds a recursion sub-circuit into 'comp' for verifying
// 'inputComp' and returns the recursion context. 'inputComp' is expected to
// be compiled with the [vortex.Compile] compiler with the options
// [PremarkAsSelfRecursed].
//
// To assign the recursion, use [Assign] and make sure the input compiled
// IOP is run using [wizard.RunProverUntil] passing the return value of
// [GetStoppingRound].
func DefineRecursionOf(comp, inputComp *wizard.CompiledIOP, params Parameters) *Recursion {
	plonkOpts := []plonkinternal.Option{}
	if params.FixedNbRowPlonkCircuit > 0 {
		plonkOpts = append(plonkOpts, plonkinternal.WithFixedNbRows(params.FixedNbRowPlonkCircuit))
	}

	if params.WithExternalHasherOpts {
		plonkOpts = append(plonkOpts, plonkinternal.WithExternalHasher(params.ExternalHasherNbRows))
	}

	if len(params.Subscript) > 0 {
		plonkOpts = append(plonkOpts, plonkinternal.WithSubscript(params.Subscript))
	}

	var (
		plonkCircuit = AllocRecursionCircuit(inputComp, params.WithExternalHasherOpts)
		plonkCtx     = plonkinternal.PlonkCheck(comp, params.Name, 0, plonkCircuit, params.MaxNumProof, plonkOpts...)
		vortexCtxs   = make([]*vortex.Ctx, params.MaxNumProof)
		numYs        = len(plonkCircuit.Ys)
		numComs      = len(plonkCircuit.Commitments)
		// pubInputOffset corresponds to the positions of the public inputs
		// in the plonk-in-wizard public witness. They are at
		// 		pubInputOffset:pubInputOffset+numPubs
		pubInputOffset           = 4*(1+numYs) + 8*numComs // 4 for x, 4*numYs for ys, 8*numComs for merkle roots
		restrictedPublicInputSet = map[string]struct{}{}
	)

	for k := range params.RestrictPublicInputs {
		restrictedPublicInputSet[params.RestrictPublicInputs[k]] = struct{}{}
	}

	for i := 0; i < params.MaxNumProof; i++ {

		translator := &compTranslator{
			Prefix: params.Name + "-" + strconv.Itoa(i),
			Target: comp,
		}
		dstVortexCtx := createNewPcsCtx(translator, inputComp)
		vortexCtxs[i] = dstVortexCtx

		// currPositionPI is a cursor pointing to the next position in the
		// public input column. It is decoupled from the loop index because it
		// account for the fact that field extensions public-input use 4
		// positions in the column.
		currPositionInPI := 0
		for _, pub := range inputComp.PublicInputs {

			var (
				isBase         = pub.Acc.IsBase()
				gapToNext      = utils.Ite(isBase, 1, 4)
				loadedPosition = currPositionInPI
				name           = pub.Name
			)

			// currPosition should not be reaccessed within the loop clause
			// as it is already pointing to the next public input.
			currPositionInPI += gapToNext

			// expectedly, this check never passes if [RestrictPublicInputs]
			// is nil and always pass if it is []string{}.
			if _, ok := restrictedPublicInputSet[name]; !ok && params.RestrictPublicInputs != nil {
				continue
			}

			if !params.SkipRecursionPrefix {
				name = addPrefixToID(translator.Prefix, name)
			}

			var acc ifaces.Accessor

			if isBase {
				acc = accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+loadedPosition)
			} else {
				acc = &accessors.Extension{
					Title: name,
					Coords: [4]ifaces.Accessor{
						accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+loadedPosition),
						accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+loadedPosition+1),
						accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+loadedPosition+2),
						accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+loadedPosition+3),
					},
				}
			}

			comp.InsertPublicInput(name, acc)
		}
	}

	rec := &Recursion{
		Name:             params.Name,
		PcsCtx:           vortexCtxs,
		PlonkCtx:         plonkCtx.GetPlonkProverAction(),
		InputCompiledIOP: inputComp,
	}

	comp.RegisterVerifierAction(0, &ConsistencyCheck{Ctx: rec, PIs: plonkCtx.Columns.PI})
	comp.RegisterProverAction(1, AssignVortexUAlpha{Ctxs: rec})
	comp.RegisterProverAction(2, AssignVortexOpenedCols{Ctxs: rec})

	// Importantly, this must happen after the "vortex" actions are registered
	// otherwise the items to self-recurse are not well-defined.
	for i := range rec.PcsCtx {
		selfrecursion.RecurseOverCustomCtx(comp, rec.PcsCtx[i], params.Name+"-"+strconv.Itoa(i))
	}

	// This passes the "extra-data" of the input comp with or without prefix
	// to the output comp.
	for k, v := range inputComp.ExtraData {
		comp.ExtraData[k] = v
	}

	return rec
}

// GetMainProverStep returns a prover step assigning the provided witness.
// It can be used for circuits where the only thing happening is the recursion.
//
// Filling is an optional parameter used if len(wit) < maxNumProof.
func (r *Recursion) GetMainProverStep(wit []Witness, filling *Witness) wizard.MainProverStep {
	return func(run *wizard.ProverRuntime) {
		r.Assign(run, wit, filling)
	}
}

// Assign assigns the items generated for the recursion of an item. As a first
// steps, the function assigns the Plonk-in-Wizard context. Then, it assigns
// the "merkle-roots" columns of the PCS.
func (r *Recursion) Assign(run *wizard.ProverRuntime, _wit []Witness, _filling *Witness) {
	var (
		// wit is reallocated because we are going to append to it and it
		// may mutate _wit in unexpected ways.
		wit           = append([]Witness(nil), _wit...)
		nbProofActual = len(wit)
		maxNbProof    = len(r.PcsCtx)
		fullWitnesses = make([]witness.Witness, len(r.PcsCtx))
		err           error
	)

	// When we have less proofs than the max
	for i := 0; i < maxNbProof; i++ {

		filling := _filling
		if filling == nil {
			filling = &_wit[0]
		}

		if i >= nbProofActual {
			wit = append(wit, *filling)
		}
	}

	for i := range wit {

		// Assigns the plonk-in-wizard context. We do so by providing a witness
		var (
			prefix = r.Name + "-" + strconv.Itoa(i)
			assign = AssignRecursionCircuit(r.InputCompiledIOP, wit[i].Proof, wit[i].Pub, wit[i].FinalFS)
		)

		fullWitnesses[i], err = frontend.NewWitness(assign, field.Modulus())
		if err != nil {
			utils.Panic("could not create witness: %v", err)
		}

		// Uses the assignment to assigns the merkle-roots columns.
		for j := range assign.Commitments {
			for k := 0; k < blockSize; k++ {
				colName := addPrefixToID(prefix, assign.MerkleRoots[j][k].GetColID())

				// One of the Merkle root may be the root to the precomputed
				// polynomials and it may be of type precomputed ("may be", not
				// "is") and thus may not be assignable.
				if run.Spec.Precomputed.Exists(colName) {
					continue
				}

				var x field.Element
				if _, err := x.SetInterface(assign.Commitments[j][k]); err != nil {
					utils.Panic("could not convert commitment to field element: %v", err)
				}
				run.AssignColumn(colName, smartvectors.NewConstant(x, 1))
			}
		}

		// Assigns the poly query.
		params := wit[i].Proof.QueriesParams.MustGet(assign.PolyQuery.QueryID).(query.UnivariateEvalParams)

		run.AssignUnivariateExt(r.PcsCtx[i].Query.QueryID, params.ExtX, params.ExtYs...)

		// Store the self-recursion artefacts for the vortex prover and the
		// self-recursion prover.
		numRound := max(len(wit[i].CommittedMatrices), len(wit[i].SisHashes), len(wit[i].Trees))
		for round := 0; round < numRound; round++ {

			if round < len(wit[i].CommittedMatrices) && wit[i].CommittedMatrices[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].VortexProverStateName(round), wit[i].CommittedMatrices[round])
			}

			if round < len(wit[i].SisHashes) && wit[i].SisHashes[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].SisHashName(round), wit[i].SisHashes[round])
			}

			if round < len(wit[i].Trees) && wit[i].Trees[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].MerkleTreeName(round), wit[i].Trees[round])
			}

			if round < len(wit[i].Poseidon2Hashes) && wit[i].Poseidon2Hashes[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].NoSisHashName(round), wit[i].Poseidon2Hashes[round])
			}
		}
	}

	r.PlonkCtx.Run(run, fullWitnesses)
}

// GetPublicInputOfInstance relative to one recursed module.
func (rec *Recursion) GetPublicInputOfInstance(run wizard.Runtime, name string, inst int) fext.GenericFieldElem {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return run.GetPublicInput(name)
}

// GetPublicInputOfInstanceGnark returns the requested public input in a
// gnark circuit context.
func (rec *Recursion) GetPublicInputOfInstanceGnark(api frontend.API, run wizard.GnarkRuntime, name string, inst int) koalagnark.Element {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return run.GetPublicInput(api, name)
}

// GetPublicInputAccessorOfInstance returns the accessor of a public input
// relative to one recursed module.
func (rec *Recursion) GetPublicInputAccessorOfInstance(comp *wizard.CompiledIOP, name string, inst int) ifaces.Accessor {
	name = addPrefixToID(rec.Name+"-"+strconv.Itoa(inst), name)
	return comp.GetPublicInputAccessor(name)
}

// VortexQueryRound returns the round at which the last commitment
// is made.
func VortexQueryRound(comp *wizard.CompiledIOP) int {
	vortexPCS := comp.PcsCtxs.(*vortex.Ctx)
	query := vortexPCS.Query
	return comp.QueriesParams.Round(query.QueryID)
}

// createNewPcsCtx creates a mirror for a vortex compilation context into
// comp. The mirror has all its commitments defined at the initial round
// and the "vortex proof" columns are inserted starting at round 1 (after
// vortex.alpha has been sampled).
func createNewPcsCtx(translator *compTranslator, srcComp *wizard.CompiledIOP) *vortex.Ctx {
	srcVortexCtx := srcComp.PcsCtxs.(*vortex.Ctx)

	if !srcVortexCtx.IsSelfrecursed {
		utils.Panic("the input vortex ctx is expected to be selfrecursed. Please make sure the input comp has been last compiled by Vortex with the option [vortex.PremarkAsSelfRecursed]")
	}

	dstVortexCtx := &vortex.Ctx{
		// Direct Copy
		RunStateNamePrefix:    translator.Prefix,
		BlowUpFactor:          srcVortexCtx.BlowUpFactor,
		ApplySISHashThreshold: srcVortexCtx.ApplySISHashThreshold,
		CommittedRowsCount:    srcVortexCtx.CommittedRowsCount,
		CommittedRowsCountSIS: srcVortexCtx.CommittedRowsCountSIS,
		NumCols:               srcVortexCtx.NumCols,
		MaxCommittedRound:     srcVortexCtx.MaxCommittedRound,
		NumOpenedCol:          srcVortexCtx.NumOpenedCol,
		VortexKoalaParams:     srcVortexCtx.VortexKoalaParams,
		SisParams:             srcVortexCtx.SisParams,
		RoundStatus:           srcVortexCtx.RoundStatus,

		// Copy via the translator
		IsSelfrecursed:                            true,
		CommitmentsByRounds:                       translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRounds),
		CommitmentsByRoundsSIS:                    translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRoundsSIS),
		CommitmentsByRoundsNonSIS:                 translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRoundsNonSIS),
		PolynomialsTouchedByTheQuery:              translator.TranslateColumnSet(srcVortexCtx.PolynomialsTouchedByTheQuery),
		ShadowCols:                                translator.TranslateColumnSet(srcVortexCtx.ShadowCols),
		Query:                                     translator.AddUniEval(0, srcVortexCtx.Query),
		AddMerkleRootToPublicInputsOpt:            srcVortexCtx.AddMerkleRootToPublicInputsOpt,
		AddPrecomputedMerkleRootToPublicInputsOpt: srcVortexCtx.AddPrecomputedMerkleRootToPublicInputsOpt,
	}

	translator.Target.QueriesParams.MarkAsIgnored(dstVortexCtx.Query.QueryID)

	if srcVortexCtx.IsNonEmptyPrecomputed() {
		dstVortexCtx.Items.Precomputeds.PrecomputedColums = translator.AddColumnList(srcVortexCtx.Items.Precomputeds.PrecomputedColums, true, 0)

		// If the vortex compilation is done with the [AddPrecomputedMerkleRootToPublicInputsOpt]
		// option, then the [MerkleRoot] column will not actually be a
		// precomputed column. In this case, we cannot use the same function of
		// the translator to add the column in the dst compilation context.
		mRootCol := srcVortexCtx.Items.Precomputeds.MerkleRoot
		for i := 0; i < blockSize; i++ {
			if srcComp.Precomputed.Exists(mRootCol[i].GetColID()) {
				dstVortexCtx.Items.Precomputeds.MerkleRoot[i] = translator.AddPrecomputed(srcComp, mRootCol[i])
			} else {
				dstVortexCtx.Items.Precomputeds.MerkleRoot[i] = translator.AddColumnAtRound(mRootCol[i], false, 0)
			}
		}
		dstVortexCtx.Items.Precomputeds.CommittedMatrix = srcVortexCtx.Items.Precomputeds.CommittedMatrix
		dstVortexCtx.Items.Precomputeds.DhWithMerkle = srcVortexCtx.Items.Precomputeds.DhWithMerkle
		dstVortexCtx.Items.Precomputeds.Tree = srcVortexCtx.Items.Precomputeds.Tree
	}
	// Allocate the dst merkle roots
	dstVortexCtx.Items.MerkleRoots = make([][blockSize]ifaces.Column, dstVortexCtx.MaxCommittedRound+1)

	for round := 0; round <= dstVortexCtx.MaxCommittedRound; round++ {
		for i := 0; i < blockSize; i++ {
			dstVortexCtx.Items.MerkleRoots[round][i] = translator.AddColumnAtRound(srcVortexCtx.Items.MerkleRoots[round][i], false, 0)
		}
	}
	// dstVortexCtx.Items.MerkleRoots = translator.AddColumnList(srcVortexCtx.Items.MerkleRoots, false, 0)
	dstVortexCtx.Items.Alpha = translator.AddCoinAtRound(srcVortexCtx.Items.Alpha, 1)
	dstVortexCtx.Items.Ualpha = translator.AddColumnAtRound(srcVortexCtx.Items.Ualpha, false, 1)
	dstVortexCtx.Items.Q = translator.AddCoinAtRound(srcVortexCtx.Items.Q, 2)
	for i := 0; i < blockSize; i++ {
		dstVortexCtx.Items.MerkleProofs[i] = translator.AddColumnAtRound(srcVortexCtx.Items.MerkleProofs[i], false, 2)
	}
	dstVortexCtx.Items.OpenedColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedColumns, false, 2)
	dstVortexCtx.Items.OpenedSISColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedSISColumns, false, 2)
	dstVortexCtx.Items.OpenedNonSISColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedNonSISColumns, false, 2)

	return dstVortexCtx
}
