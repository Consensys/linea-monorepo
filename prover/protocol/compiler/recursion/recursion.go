package recursion

import (
	"strconv"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/witness"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/linea-monorepo/prover/crypto/state-management/smt"
	vCom "github.com/consensys/linea-monorepo/prover/crypto/vortex"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/accessors"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/selfrecursion"
	"github.com/consensys/linea-monorepo/prover/protocol/compiler/vortex"
	"github.com/consensys/linea-monorepo/prover/protocol/internal/plonkinternal"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/utils"
)

// Recursion is a collection of wizard items composing a wizard circuit
// for recursion. The recursion operates over a wizard proof for a
// protocol featuring the [vortex.Compile] such that the runtime only
// goes through the vortex commitments and stops just before the opening.
//
// The [Recursion] takes over at this moment and the reason is that it
// allows us to combine the self-recursion (a.k.a vortex verifier in
// wizard) with the plonk-in-wizard verifier. This allows for more
// efficiency.
type Recursion struct {

	// Name is a name used to prefix all the wizard items generated by the
	// present [Recursion].
	Name string

	// InputCompiledIOP is the input compiled-IOP whose proofs are to be
	// recursed.
	InputCompiledIOP *wizard.CompiledIOP

	// Round is an optional parameter that allows the caller to specify
	// which round of the input proof they want to use. If not specified,
	// the initial round is used.
	Round int

	// PlonkCtx is the [PlonkInWizard] context that we use to verify the
	// non-vortex part of the input wizard proof. Namely, it runs all its
	// verifier actions and the corresponding circuit assignments.
	PlonkCtx *plonkinternal.CompilationCtx

	// PcsCtx represents the compilation context to pass to the self-recursion
	// context. For clarity, this is not the compilation context of the
	// input proof but the "translated" one that is built by the recursion.
	PcsCtx []*vortex.Ctx
}

// Witness represents the witness for a single recursion
type Witness struct {

	// Proof is the wizard proof to recurse
	Proof wizard.Proof

	// Pub is the list of the public inputs for the proof
	Pub []field.Element

	// FinalFS is the final Fiat-Shamir state of the protocol
	FinalFS field.Element

	// CommittedMatrices are the list of the Reed-Solomon matrices
	// for each committed round. They are needed by the prover of
	// the prover of the self-recursion.
	CommittedMatrices []vCom.EncodedMatrix

	// SisHashes is the list of the SIS hashes of the vortex columns
	// for each committed round. They are needed by the prover of
	// the prover of the self-recursion.
	SisHashes [][]field.Element

	// Trees are the list of the commitment merkle trees. They are needed
	// by the prover of the self-recursion.
	Trees []*smt.Tree
}

// GetStoppingRound returns the number of rounds to pass to [wizard.RunProverUntil]
// in order to reach the end of the vortex commitment phase and stop just
// before the opening.
func (r *Recursion) GetStoppingRound() int {
	qName := r.InputCompiledIOP.PcsCtxs.(*vortex.Ctx).Query.QueryID
	return r.InputCompiledIOP.QueriesParams.Round(qName)
}

// DefineRecursionOf builds a recursion sub-circuit into 'comp' for verifying
// 'inputComp' and returns the recursion context. 'inputComp' is expected to
// be compiled with the [vortex.Compile] compiler with the options
// [MarkAsSelfRecursed] and without the option [ReplaceByMiMC].
//
// To assign the recursion, use [Assign] and make sure the input compiled
// IOP is run using [wizard.RunProverUntil] passing the return value of
// [GetStoppingRound].
func DefineRecursionOf(name string, comp, inputComp *wizard.CompiledIOP, withoutGkr bool, maxNumProof int) *Recursion {

	var (
		plonkCircuit = AllocRecursionCircuit(inputComp, withoutGkr)
		plonkCtx     = plonkinternal.PlonkCheck(comp, name, 0, plonkCircuit, maxNumProof)
		vortexCtxs   = make([]*vortex.Ctx, maxNumProof)
		numYs        = len(plonkCircuit.Ys)
		numComs      = len(plonkCircuit.Commitments)
		// pubInputOffset corresponds to the positions of the public inputs
		// in the plonk-in-wizard public witness. They are at
		// 		pubInputOffset:pubInputOffset+numPubs
		pubInputOffset = 1 + numYs + numComs
	)

	for i := 0; i < maxNumProof; i++ {

		translator := &compTranslator{
			Prefix: name + "-" + strconv.Itoa(i),
			Target: comp,
		}

		dstVortexCtx := createNewPcsCtx(translator, inputComp)
		vortexCtxs[i] = dstVortexCtx

		for k := range inputComp.PublicInputs {

			comp.InsertPublicInput(
				addPrefixToID(translator.Prefix, inputComp.PublicInputs[k].Name),
				accessors.NewFromPublicColumn(plonkCtx.Columns.PI[i], pubInputOffset+k),
			)
		}
	}

	rec := &Recursion{
		Name:             name,
		PcsCtx:           vortexCtxs,
		PlonkCtx:         plonkCtx,
		InputCompiledIOP: inputComp,
	}

	comp.RegisterVerifierAction(0, &ConsistencyCheck{Ctx: rec})
	comp.RegisterProverAction(1, AssignVortexUAlpha{Ctxs: rec})
	comp.RegisterProverAction(2, AssignVortexOpenedCols{Ctxs: rec})

	// Importantly, this must happen after the "vortex" actions are registered
	// otherwise the items to self-recurse are not well-defined.
	for i := range rec.PcsCtx {
		selfrecursion.RecurseOverCustomCtx(comp, rec.PcsCtx[i], name+"-"+strconv.Itoa(i))
	}

	return rec
}

// GetMainProverStep returns a prover step assigning the provided witness.
// It can be used for circuits where the only thing happening is the recursion.
func (r *Recursion) GetMainProverStep(wit []Witness) wizard.ProverStep {
	return func(run *wizard.ProverRuntime) {
		r.Assign(run, wit)
	}
}

// Assign assigns the items generated for the recursion of an item. As a first
// steps, the function assigns the Plonk-in-Wizard context. Then, it assigns
// the "merkle-roots" columns of the PCS.
func (r *Recursion) Assign(run *wizard.ProverRuntime, _wit []Witness) {

	var (
		// wit is reallocated because we are going to append to it and it
		// may mutate _wit in unexpected ways.
		wit           = append([]Witness(nil), _wit...)
		nbProofActual = len(wit)
		maxNbProof    = len(r.PcsCtx)
		fullWitnesses = make([]witness.Witness, len(r.PcsCtx))
		err           error
	)

	// When we have less proofs than the max
	for i := 0; i < maxNbProof; i++ {
		if i >= nbProofActual {
			wit = append(wit, wit[0])
		}
	}

	for i := range wit {

		// Assigns the plonk-in-wizard context. We do so by providing a witness
		var (
			prefix = r.Name + "-" + strconv.Itoa(i)
			assign = AssignRecursionCircuit(r.InputCompiledIOP, wit[i].Proof, wit[i].Pub, wit[i].FinalFS)
		)

		fullWitnesses[i], err = frontend.NewWitness(assign, ecc.BLS12_377.ScalarField())
		if err != nil {
			utils.Panic("could not create witness: %v", err)
		}

		// Uses the assignment to assigns the merkle-roots columns.
		for j := range assign.Commitments {
			colName := addPrefixToID(prefix, assign.MerkleRoots[j].GetColID())
			x := assign.Commitments[j].(field.Element)
			run.AssignColumn(colName, smartvectors.NewConstant(x, 1))
		}

		// Assigns the poly query.
		params := wit[i].Proof.QueriesParams.MustGet(assign.PolyQuery.QueryID).(query.UnivariateEvalParams)
		run.AssignUnivariate(r.PcsCtx[i].Query.QueryID, params.X, params.Ys...)

		// Store the self-recursion artefacts for the vortex prover and the
		// self-recursion prover.
		numRound := max(len(wit[i].CommittedMatrices), len(wit[i].SisHashes), len(wit[i].Trees))
		for round := 0; round < numRound; round++ {

			if round < len(wit[i].CommittedMatrices) && wit[i].CommittedMatrices[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].VortexProverStateName(round), wit[i].CommittedMatrices[round])
			}

			if round < len(wit[i].SisHashes) && wit[i].SisHashes[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].SisHashName(round), wit[i].SisHashes[round])
			}

			if round < len(wit[i].Trees) && wit[i].Trees[round] != nil {
				run.State.InsertNew(r.PcsCtx[i].MerkleTreeName(round), wit[i].Trees[round])
			}
		}
	}

	r.PlonkCtx.GetPlonkProverAction().Run(run, fullWitnesses)
}

// LastVortexCommitRound returns the round at which the last commitment
// is made.
func LastVortexCommitRound(comp *wizard.CompiledIOP) int {
	vortexPCS := comp.PcsCtxs.(*vortex.Ctx)
	query := vortexPCS.Query
	return comp.QueriesParams.Round(query.QueryID)
}

// createNewPcsCtx creates a mirror for a vortex compilation context in to
// comp. The mirror has all its commitments defined at the initial round
// and the "vortex proof" columns are inserted starting at round 1 (after
// vortex.alpha has been sampled).
func createNewPcsCtx(translator *compTranslator, srcComp *wizard.CompiledIOP) *vortex.Ctx {

	srcVortexCtx := srcComp.PcsCtxs.(*vortex.Ctx)

	if !srcVortexCtx.IsSelfrecursed || srcVortexCtx.ReplaceSisByMimc {
		utils.Panic("the input vortex ctx is expected to be selfrecursed or having SIS replaced by MiMC. Please sure the input comp has been last compiled by Vortex with the option [vortex.MarkAsSelfRecursed]")
	}

	dstVortexCtx := &vortex.Ctx{
		RunStateNamePrefix: translator.Prefix,
		BlowUpFactor:       srcVortexCtx.BlowUpFactor,
		DryTreshold:        srcVortexCtx.DryTreshold,
		CommittedRowsCount: srcVortexCtx.CommittedRowsCount,
		NumCols:            srcVortexCtx.NumCols,
		MaxCommittedRound:  srcVortexCtx.MaxCommittedRound,
		NumOpenedCol:       srcVortexCtx.NumOpenedCol,
		VortexParams:       srcVortexCtx.VortexParams,
		SisParams:          srcVortexCtx.SisParams,
		// Although the srcVor
		IsSelfrecursed:               true,
		CommitmentsByRounds:          translator.AddColumnVecVec(srcVortexCtx.CommitmentsByRounds),
		DriedByRounds:                translator.AddColumnVecVec(srcVortexCtx.DriedByRounds),
		PolynomialsTouchedByTheQuery: translator.AddColumnSet(srcVortexCtx.PolynomialsTouchedByTheQuery),
		ShadowCols:                   translator.AddColumnSet(srcVortexCtx.ShadowCols),
		Query:                        translator.AddUniEval(0, srcVortexCtx.Query),
	}

	if srcVortexCtx.ReplaceSisByMimc {
		panic("it should not replace by MiMC")
	}

	translator.Target.QueriesParams.MarkAsIgnored(dstVortexCtx.Query.QueryID)

	if srcVortexCtx.IsCommitToPrecomputed() {
		dstVortexCtx.Items.Precomputeds.PrecomputedColums = translator.AddColumnList(srcVortexCtx.Items.Precomputeds.PrecomputedColums, true, 0)
		dstVortexCtx.Items.Precomputeds.MerkleRoot = translator.AddColumnAtRound(srcVortexCtx.Items.Precomputeds.MerkleRoot, false, 0)
		dstVortexCtx.Items.Precomputeds.CommittedMatrix = srcVortexCtx.Items.Precomputeds.CommittedMatrix
		dstVortexCtx.Items.Precomputeds.DhWithMerkle = srcVortexCtx.Items.Precomputeds.DhWithMerkle
		dstVortexCtx.Items.Precomputeds.Tree = srcVortexCtx.Items.Precomputeds.Tree
	}

	dstVortexCtx.Items.MerkleRoots = translator.AddColumnList(srcVortexCtx.Items.MerkleRoots, false, 0)
	dstVortexCtx.Items.Alpha = translator.AddCoinAtRound(srcVortexCtx.Items.Alpha, 1)
	dstVortexCtx.Items.Ualpha = translator.AddColumnAtRound(srcVortexCtx.Items.Ualpha, false, 1)
	dstVortexCtx.Items.Q = translator.AddCoinAtRound(srcVortexCtx.Items.Q, 2)
	dstVortexCtx.Items.OpenedColumns = translator.AddColumnList(srcVortexCtx.Items.OpenedColumns, false, 2)
	dstVortexCtx.Items.MerkleProofs = translator.AddColumnAtRound(srcVortexCtx.Items.MerkleProofs, false, 2)

	return dstVortexCtx
}
