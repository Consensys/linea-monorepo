package mimc

import (
	"github.com/consensys/linea-monorepo/prover/crypto/mimc"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	sym "github.com/consensys/linea-monorepo/prover/symbolic"
	"github.com/consensys/linea-monorepo/prover/utils"
	"github.com/consensys/linea-monorepo/prover/utils/parallel"
)

// MimcContext is a compilation context storing all the artefacts generated by
// the compilation of MiMC query. Those are: the columns created to emulate the
// evaluation of the MiMC compilation function.
//
// The context also implements the [wizard.ProverAction] interface.
type MimcContext struct {

	// CompiledQueries stores the MiMC queries that have been compiled.
	CompiledQueries []*query.MiMC

	// StackedOldState stores all the old states of the MiMC computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedOldStates ifaces.Column
	// StackedBlocks stores all the blocks of the MiMC computation. For all
	// unique triplets (oldState, blocks, newStates).
	StackedBlocks ifaces.Column
	// StackedNewStates stores all the new states of the MiMC computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedNewStates ifaces.Column
	// SumPow4s stores the values of (prevRound + oldState + ark_i)^4 for all
	// MiMC rounds "i".
	SumPow4s []ifaces.Column
	// RoundResult stores the values of (prevRound + oldState + ark_i)^4 for all
	// MiMC rounds "i". The last value is set to [StackedNewStates].
	RoundResults []ifaces.Column
}

// CompileMiMC compiles all the MiMC queries in the [comp] object. The compiler
// works by creating its own module responsible for checking each unique MiMC
// query statements, taking into account the padding.
func CompileMiMC(comp *wizard.CompiledIOP) {
	_ = defineContext(comp)
}

// defineContext generates the constraints for the MiMC computation and returns
// the compilation context. The function also registers the relevant prover
// actions to assign the generated columns.
//
// The function works by:
//
//   - scanning the [comp] object, looking for uncompiled MiMC queries and collecting
//     their inputs.
//   - declaring the [StackedBlocks], [StackedOldStates] and [StackedNewStates] which
//     are used to stack all the unique triplets provided in the inputs.
//   - declaring the [SumPow4s] and [RoundResults] for all MiMC rounds and the
//     constraints enforcing their correctness.
func defineContext(comp *wizard.CompiledIOP) *MimcContext {

	var (
		ctx        = &MimcContext{}
		round      = 0
		allQueries = comp.QueriesNoParams.AllUnignoredKeys()
		totalSize  = 0
	)

	for _, qName := range allQueries {
		if q_, ok := comp.QueriesNoParams.Data(qName).(query.MiMC); ok {
			comp.QueriesNoParams.MarkAsIgnored(qName)
			round = max(round, comp.QueriesNoParams.Round(qName))
			totalSize += q_.Blocks.Size()
			ctx.CompiledQueries = append(ctx.CompiledQueries, &q_)
		}
	}

	// The compilation has nothing to do if no MiMC queries were found
	if len(ctx.CompiledQueries) == 0 {
		return nil
	}

	totalSize = utils.NextPowerOfTwo(totalSize)

	ctx.StackedOldStates = comp.InsertCommit(round,
		ifaces.ColIDf("MIMC_STACKED_OLD_STATES_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	ctx.StackedBlocks = comp.InsertCommit(round,
		ifaces.ColIDf("MIMC_STACKED_BLOCKS_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	ctx.StackedNewStates = comp.InsertCommit(round,
		ifaces.ColIDf("MIMC_STACKED_NEW_STATES_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	for i := 0; i < len(mimc.Constants); i++ {

		var (
			prev = ctx.StackedBlocks
			ark  = mimc.Constants[i]
		)

		if i > 0 {
			prev = ctx.RoundResults[i-1]
		}

		sp4 := comp.InsertCommit(round,
			ifaces.ColIDf("MIMC_ROUND_%v_SUM_POW4_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			totalSize)

		ctx.SumPow4s = append(ctx.SumPow4s, sp4)

		rr := comp.InsertCommit(round,
			ifaces.ColIDf("MIMC_ROUND_%v_RESULT_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			totalSize)

		ctx.RoundResults = append(ctx.RoundResults, rr)

		comp.InsertGlobal(round,
			ifaces.QueryIDf("MIMC_ROUND_%v_SUM_POW4_COMPUTATION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			sym.Sub(sp4, sym.Pow(sym.Add(prev, ark, ctx.StackedOldStates), 4)))

		comp.InsertGlobal(round,
			ifaces.QueryIDf("MIMC_ROUND_%v_RESULT_COMPUTATION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			sym.Sub(rr, sym.Mul(sym.Pow(sp4, 4), sym.Add(prev, ark, ctx.StackedOldStates))))
	}

	comp.InsertGlobal(round,
		ifaces.QueryIDf("MIMC_STACKED_NEW_STATES_COMPUTATION_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		sym.Sub(ctx.StackedNewStates, ctx.StackedOldStates, ctx.StackedOldStates, ctx.StackedBlocks, ctx.RoundResults[len(mimc.Constants)-1]))

	for i := range ctx.CompiledQueries {

		comp.GenericFragmentedConditionalInclusion(
			round,
			ifaces.QueryIDf("MIMC_QUERY_%v_INCLUSION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			[][]ifaces.Column{
				{
					ctx.StackedBlocks,
					ctx.StackedOldStates,
					ctx.StackedNewStates,
				},
			},
			[]ifaces.Column{
				ctx.CompiledQueries[i].Blocks,
				ctx.CompiledQueries[i].OldState,
				ctx.CompiledQueries[i].NewState,
			},
			nil,
			ctx.CompiledQueries[i].Selector,
		)
	}

	comp.RegisterProverAction(round, ctx)

	return ctx
}

// The Run function implements the [wizard.ProverAction] interface. It starts by
// collecting all the unique triplets provided in the inputs and stacks them into
// a column and then pads the column with (0, 0, H(0, 0)) to match the size of the
// columns. The padding is done on the right.
//
// After, [StackedOldStates], [StackedBlocks] and [StackedNewStates] are assigned
// to the corresponding columns. The function goes and computes the [SumPow4s] and
// [RoundResults] columns.
func (ctx *MimcContext) Run(run *wizard.ProverRuntime) {

	var (
		stackedOldStates = make([]field.Element, 0)
		stackedBlocks    = make([]field.Element, 0)
		stackedNewStates = make([]field.Element, 0)
		totalSize        = ctx.StackedOldStates.Size()
		mimcOfZero       = mimc.BlockCompression(field.NewElement(0), field.NewElement(0))
	)

	for i := range ctx.CompiledQueries {

		var (
			q   = ctx.CompiledQueries[i]
			os  = q.OldState.GetColAssignment(run)
			b   = q.Blocks.GetColAssignment(run)
			ns  = q.NewState.GetColAssignment(run)
			sel smartvectors.SmartVector
		)

		if q.Selector != nil {
			sel = q.Selector.GetColAssignment(run)
		}

		start, stop := smartvectors.CoWindowRange(os, b, ns, sel)

		// tryPushToStacked looks at the selector at position "j" and appends
		// the corresponding triplet (old state, block, new state) to the "stacked"
		// columns if the selector is not nil and is not zero at this position.
		tryPushToStacked := func(j int) {
			if sel != nil && sel.GetPtr(j).IsZero() {
				return
			}

			stackedOldStates = append(stackedOldStates, os.Get(j))
			stackedBlocks = append(stackedBlocks, b.Get(j))
			stackedNewStates = append(stackedNewStates, ns.Get(j))
		}

		for j := start; j < stop; j++ {
			tryPushToStacked(j)
		}

		// The padding is done in the left, the first value is understood
		// by the query as a padding row.
		if start > 0 {
			tryPushToStacked(0)
			continue
		}

		// The padding is done on the right, the last value is understood
		// by the query as a padding row.
		if stop < os.Len() {
			tryPushToStacked(os.Len() - 1)
			continue
		}
	}

	// If the range is not full, we add an extra row of padding. This is handy
	// because it allows us to specify the padding of all intermediate rows
	// as their last value. We can then simplify the code by not having a code
	// path dedicated to handling the padding.
	if len(stackedOldStates) < totalSize {

		stackedOldStates = append(stackedOldStates, field.NewElement(0))
		stackedBlocks = append(stackedBlocks, field.NewElement(0))
		stackedNewStates = append(stackedNewStates, mimcOfZero)
	}

	run.AssignColumn(
		ctx.StackedOldStates.GetColID(),
		smartvectors.RightZeroPadded(stackedOldStates, totalSize))

	run.AssignColumn(
		ctx.StackedBlocks.GetColID(),
		smartvectors.RightZeroPadded(stackedBlocks, totalSize))

	run.AssignColumn(
		ctx.StackedNewStates.GetColID(),
		smartvectors.RightPadded(stackedNewStates, mimcOfZero, totalSize))

	var (
		effectiveSize = len(stackedOldStates)
		sumPow4s      = make([][]field.Element, len(mimc.Constants))
		roundResults  = make([][]field.Element, len(mimc.Constants))
	)

	for i := range sumPow4s {
		sumPow4s[i] = make([]field.Element, effectiveSize)
		roundResults[i] = make([]field.Element, effectiveSize)
	}

	parallel.Execute(effectiveSize, func(start, stop int) {

		for row := start; row < stop; row++ {

			var (
				s = stackedBlocks[row]
				k = stackedOldStates[row]
			)

			for mimcRound := 0; mimcRound < len(mimc.Constants); mimcRound++ {

				ark := mimc.Constants[mimcRound]

				var (
					// sum = (s + k + ark)
					sum field.Element
					// sp4 will be set as sp4 = sum^4.
					sp4 = &sumPow4s[mimcRound][row]
					// rr will be set as rr = sp4^4 * sum
					rr = &roundResults[mimcRound][row]
				)

				// This computes "sum"
				sum.Add(&s, &k)
				sum.Add(&sum, &ark)

				// This computes "sp4"
				sp4.Square(&sum)
				sp4.Square(sp4)

				// This computes "rr"
				rr.Square(sp4)
				rr.Square(rr)
				rr.Mul(rr, &sum)

				s = *rr
			}
		}
	})

	for i := range sumPow4s {

		// As a reminder, the last value of sumPow4s[i] is the padding value. (if need be).
		// If it does not, the function [RightPadded] will simply ditch the provided value.
		run.AssignColumn(
			ctx.SumPow4s[i].GetColID(),
			smartvectors.RightPadded(sumPow4s[i], sumPow4s[i][effectiveSize-1], totalSize))

		run.AssignColumn(
			ctx.RoundResults[i].GetColID(),
			smartvectors.RightPadded(roundResults[i], roundResults[i][effectiveSize-1], totalSize))
	}

}

// uniqueID returns an integer helping to uniquely identify the items generated
// by the compilation of a MiMC query.
func uniqueID(comp *wizard.CompiledIOP) int {
	return len(comp.Columns.AllKeys())
}
