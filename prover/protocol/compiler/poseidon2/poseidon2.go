package poseidon2

import (
	"github.com/consensys/linea-monorepo/prover/crypto/poseidon2"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	sym "github.com/consensys/linea-monorepo/prover/symbolic"
	"github.com/consensys/linea-monorepo/prover/utils"
	"github.com/consensys/linea-monorepo/prover/utils/parallel"
)

// Poseidon2Context is a compilation context storing all the artefacts generated by
// the compilation of Poseidon2 query. Those are: the columns created to emulate the
// evaluation of the Poseidon2 compilation function.
//
// The context also implements the [wizard.ProverAction] interface.
type Poseidon2Context struct {

	// CompiledQueries stores the Poseidon2 queries that have been compiled.
	CompiledQueries []*query.Poseidon2

	// StackedOldState stores all the old states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	// [col](Column stores query values)
	StackedOldStates [8]ifaces.Column
	// StackedBlocks stores all the blocks of the Poseidon2 computation. For all
	// unique triplets (oldState, blocks, newStates).
	StackedBlocks [8]ifaces.Column
	// StackedNewStates stores all the new states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedNewStates [8]ifaces.Column
	// store [col][poseidon2Round](Column stores query values)
	// MatMulM4Tmp stores all the intermediate results of the Poseidon2 matMulM4InPlace computation.
	// Refer to the t01, t23, t0123, t01123, t01233 values of all input chunks:
	// https://github.com/Consensys/gnark-crypto/blob/master/field/koalabear/poseidon2/poseidon2.go#L178
	MatMulM4Tmp [20][]ifaces.Column
	// MatMulM4 stores all the round outputs of the Poseidon2 matMulM4InPlace computation.
	MatMulM4 [16][]ifaces.Column
	// T stores the partial sum of MatMulM4.
	// T[j] = sum_{i = 0,1,2,3} MatMulM4[4*i+j], for j = 0,1,2,3
	T [4][]ifaces.Column
	// MatMulExternal stores all the round outputs of the Poseidon2 matMulExternalInPlace computation.
	// MatMulExternal[4i+j] = MatMulM4[4i+j] + T[j], for i, j = 0,1,2,3
	MatMulExternal [16][]ifaces.Column
	// AddRoundKey stores all the round outputs of the Poseidon2 addRoundKeyInPlace computation.
	// AddRoundKey[i] = MatMulExternal[i] + RoundKeys[round][i]
	AddRoundKey [16][]ifaces.Column
	// SBox stores all the round outputs of the Poseidon2 sBox computation.
	// SBox[i]=AddRoundKey[i] ^3
	SBox [16][]ifaces.Column
	// SBox stores all the SBox sum in the Poseidon2 matMulInternalInPlace computation.
	// sum = âˆ‘ SBox[i]
	SBoxSum []ifaces.Column
	// MatMulInternal stores all the round outputs of the Poseidon2 matMulInternalInPlace computation.
	// mul by diag16:
	// [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24]
	MatMulInternal [16][]ifaces.Column
}

// CompilePoseidon2 compiles all the Poseidon2 queries in the [comp] object. The compiler
// works by creating its own module responsible for checking each unique Poseidon2
// query statements, taking into account the padding.
func CompilePoseidon2(comp *wizard.CompiledIOP) {
	_ = defineContext(comp)
}

// defineMatMulExternalInPlace
func defineMatMulExternalInPlace(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
	matMulM4Tmp := [20]ifaces.Column{}
	matMulM4 := [16]ifaces.Column{}
	t := [4]ifaces.Column{}
	matMulExternal := [16]ifaces.Column{}

	// MatMulExternalInPlace
	// Declare temporary columns for the matrix multiplication.
	for col := 0; col < 20; col++ {
		matMulM4Tmp[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_%v_%v_COL_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.MatMulM4Tmp[col] = append(ctx.MatMulM4Tmp[col], matMulM4Tmp[col])
	}
	for col := 0; col < 16; col++ {
		matMulM4[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulM4_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.MatMulM4[col] = append(ctx.MatMulM4[col], matMulM4[col])
	}
	for col := 0; col < 4; col++ {
		t[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_T_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.T[col] = append(ctx.T[col], t[col])
	}
	for col := 0; col < 16; col++ {
		matMulExternal[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulExternal_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.MatMulExternal[col] = append(ctx.MatMulExternal[col], matMulExternal[col])
	}
	// Insert constraints for the matrix multiplication.
	for chunk := 0; chunk < 4; chunk++ {
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk), sym.Sub(matMulM4Tmp[5*chunk], sym.Add(input[4*chunk], input[4*chunk+1])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+1), sym.Sub(matMulM4Tmp[5*chunk+1], sym.Add(input[4*chunk+2], input[4*chunk+3])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+2), sym.Sub(matMulM4Tmp[5*chunk+2], sym.Add(matMulM4Tmp[5*chunk], matMulM4Tmp[5*chunk+1])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+3), sym.Sub(matMulM4Tmp[5*chunk+3], sym.Add(matMulM4Tmp[5*chunk+2], input[4*chunk+1])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+4), sym.Sub(matMulM4Tmp[5*chunk+4], sym.Add(matMulM4Tmp[5*chunk+2], input[4*chunk+3])))

		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+3), sym.Sub(matMulM4[4*chunk+3], sym.Add(input[4*chunk], input[4*chunk], matMulM4Tmp[5*chunk+4])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+1), sym.Sub(matMulM4[4*chunk+1], sym.Add(input[4*chunk+2], input[4*chunk+2], matMulM4Tmp[5*chunk+3])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk), sym.Sub(matMulM4[4*chunk], sym.Add(matMulM4Tmp[5*chunk], matMulM4Tmp[5*chunk+3])))
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+2), sym.Sub(matMulM4[4*chunk+2], sym.Add(matMulM4Tmp[5*chunk+1], matMulM4Tmp[5*chunk+4])))
	}
	for i := 0; i < 4; i++ {
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_T_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), i), sym.Sub(t[i], sym.Add(matMulM4[i], matMulM4[i+4], matMulM4[i+8], matMulM4[i+12])))
	}
	for i := 0; i < 16; i++ {
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulExternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), i), sym.Sub(matMulExternal[i], sym.Add(matMulM4[i], t[i%4])))
	}
	return matMulExternal[:]
}

// defineRoundInternal abstracts the logic for a partial Poseidon2 round.
func defineRoundInternal(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
	matMulInternal := [16]ifaces.Column{}
	sBoxSum := comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBoxSum_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp)), totalSize)
	ctx.SBoxSum = append(ctx.SBoxSum, sBoxSum)

	// MatMulInternalInPlace
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBoxSum_COMPUTATION_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp)),
		sym.Sub(sBoxSum, sym.Add(input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7], input[8], input[9], input[10], input[11], input[12], input[13], input[14], input[15])))

	for col := 0; col < 16; col++ {
		matMulInternal[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulInternal_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.MatMulInternal[col] = append(ctx.MatMulInternal[col], matMulInternal[col])
	}

	// mul by diag16:
	// [-2, 1, 2, 1/2,
	//  3, 4, -1/2, -3,
	// -4, 1/2^8, 1/2^3, 1/2^24,
	// -1/2^8, -1/2^3, -1/2^4, -1/2^24]
	// matMulInternal[0] = sBoxSum - 2 * input[0]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 0),
		sym.Sub(matMulInternal[0], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(2), input[0]))))
	// matMulInternal[1] = sBoxSum + input[1]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 1),
		sym.Sub(matMulInternal[1], sym.Add(sBoxSum, input[1])))
	// matMulInternal[2] = sBoxSum + 2 * input[2]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 2),
		sym.Sub(matMulInternal[2], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(-2), input[2]))))
	// matMulInternal[3] = sBoxSum + 1/2 * input[3]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 3),
		sym.Sub(matMulInternal[3], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-1)), input[3]))))
	// matMulInternal[4] = sBoxSum + 3 * input[4]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4),
		sym.Sub(matMulInternal[4], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(3), input[4]))))
	// matMulInternal[5] = sBoxSum + 4 * input[5]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5),
		sym.Sub(matMulInternal[5], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(4), input[5]))))
	// matMulInternal[6] = sBoxSum - 1/2 * input[6]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 6),
		sym.Sub(matMulInternal[6], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-1)), input[6]))))
	// matMulInternal[7] = sBoxSum - 3 * input[7]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 7),
		sym.Sub(matMulInternal[7], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(3), input[7]))))
	// matMulInternal[8] = sBoxSum - 4 * input[8]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 8),
		sym.Sub(matMulInternal[8], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(4), input[8]))))
	// matMulInternal[9] = sBoxSum + 1/2^8 * input[9]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 9),
		sym.Sub(matMulInternal[9], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-8)), input[9]))))
	// matMulInternal[10] = sBoxSum + 1/2^3 * input[10]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 10),
		sym.Sub(matMulInternal[10], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-3)), input[10]))))
	// matMulInternal[11] = sBoxSum + 1/2^24 * input[11]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 11),
		sym.Sub(matMulInternal[11], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-24)), input[11]))))
	// matMulInternal[12] = sBoxSum - 1/2^8 * input[12]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 12),
		sym.Sub(matMulInternal[12], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-8)), input[12]))))
	// matMulInternal[13] = sBoxSum - 1/2^3 * input[13]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 13),
		sym.Sub(matMulInternal[13], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-3)), input[13]))))
	// matMulInternal[14] = sBoxSum - 1/2^4 * input[14]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 14),
		sym.Sub(matMulInternal[14], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-4)), input[14]))))
	// matMulInternal[15] = sBoxSum - 1/2^24 * input[15]
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 15),
		sym.Sub(matMulInternal[15], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1<<(32-24)), input[15]))))
	return matMulInternal[:]
}

// defineAddRoundKey abstracts the logic for AddRoundKey
func defineAddRoundKey(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
	addRoundKey := [16]ifaces.Column{}

	// Add Round Key
	for col := 0; col < len(poseidon2.RoundKeys[poseidon2Round-1]); col++ {
		addRoundKey[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_AddRoundKey_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.AddRoundKey[col] = append(ctx.AddRoundKey[col], addRoundKey[col])
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_AddRoundKey_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col),
			sym.Sub(addRoundKey[col], sym.Add(input[col], poseidon2.RoundKeys[poseidon2Round-1][col]))) // Adjust the roundID because the initial round starts from 1, while the round key starts from 0.
	}

	for col := len(poseidon2.RoundKeys[poseidon2Round-1]); col < 16; col++ {
		addRoundKey[col] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_AddRoundKey_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col), totalSize)
		ctx.AddRoundKey[col] = append(ctx.AddRoundKey[col], addRoundKey[col])
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_AddRoundKey_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), col),
			sym.Sub(addRoundKey[col], input[col]))
	}

	return addRoundKey[:] // The output of this round becomes the input for the next one.
}

// defineSBox abstracts the logic for SBox
func defineSBox(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize, index int, input []ifaces.Column, poseidon2Round int) ifaces.Column {
	// S-Box
	sBox := comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBox_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index), totalSize)
	ctx.SBox[index] = append(ctx.SBox[index], sBox)
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBox_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index),
		sym.Sub(sBox, sym.Mul(sym.Square(input[index]), input[index])))

	return sBox // The output of this round becomes the input for the next one.
}

func defineSBoxZero(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) (sBox []ifaces.Column) {
	// Initialize the sBox slice with the required size
	sBox = make([]ifaces.Column, 16)

	// S-Box
	sBox[0] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBox_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 0), totalSize)
	ctx.SBox[0] = append(ctx.SBox[0], sBox[0])
	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBox_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 0),
		sym.Sub(sBox[0], sym.Mul(sym.Square(input[0]), input[0])))

	for index := 1; index < 16; index++ {
		sBox[index] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBox_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index), totalSize)
		ctx.SBox[index] = append(ctx.SBox[index], sBox[index])
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBox_COMPUTATION_%v_%v_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index),
			sym.Sub(sBox[index], input[index]))

	}

	return sBox // The output of this round becomes the input for the next one.
}

// defineContext generates the constraints for the Poseidon2 computation and returns
// the compilation context. The function also registers the relevant prover
// actions to assign the generated columns.
//
// The function works by:
//
//   - scanning the [comp] object, looking for uncompiled Poseidon2 queries and collecting
//     their inputs.
//   - declaring the [StackedBlocks], [StackedOldStates] and [StackedNewStates] which
//     are used to stack all the unique triplets provided in the inputs.
//   - declaring the [SumPow4s] and [RoundResults] for all Poseidon2 rounds and the
//     constraints enforcing their correctness.
func defineContext(comp *wizard.CompiledIOP) *Poseidon2Context {

	var (
		ctx             = &Poseidon2Context{}
		protocolRoundID = 0
		allQueries      = comp.QueriesNoParams.AllUnignoredKeys()
		totalSize       = 0
	)

	for _, qName := range allQueries {
		if q_, ok := comp.QueriesNoParams.Data(qName).(query.Poseidon2); ok {
			comp.QueriesNoParams.MarkAsIgnored(qName)
			protocolRoundID = max(protocolRoundID, comp.QueriesNoParams.Round(qName))
			totalSize += q_.Blocks[0].Size()
			ctx.CompiledQueries = append(ctx.CompiledQueries, &q_)
		}
	}
	// The compilation has nothing to do if no Poseidon2 queries were found
	if len(ctx.CompiledQueries) == 0 {
		return nil
	}

	totalSize = utils.NextPowerOfTwo(totalSize)

	for col := 0; col < 8; col++ {
		ctx.StackedOldStates[col] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_OLD_STATES_%v_%v_%v", comp.SelfRecursionCount, uniqueID(comp), col),
			totalSize)

		ctx.StackedBlocks[col] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_BLOCKS_%v_%v_%v", comp.SelfRecursionCount, uniqueID(comp), col),
			totalSize)

		ctx.StackedNewStates[col] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_NEW_STATES_%v_%v_%v", comp.SelfRecursionCount, uniqueID(comp), col),
			totalSize)
	}

	var input, output, copy_input []ifaces.Column
	input = append(input, ctx.StackedOldStates[:]...)
	input = append(input, ctx.StackedBlocks[:]...)
	output = append(input, ctx.StackedNewStates[:]...)

	copy_input = append(copy_input, input[8:]...) // saved to feed forward later

	// 3. Define the constraints for the Poseidon2 permutation rounds.
	// poseidon2Round 0
	// Initial matMulExternalInPlace
	input = defineMatMulExternalInPlace(comp, ctx, protocolRoundID, totalSize, input, 0)

	// poseidon2Round 1 - 3
	for poseidon2Round := 1; poseidon2Round < 4; poseidon2Round++ {
		input = defineAddRoundKey(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
		for col := 0; col < 16; col++ {
			input[col] = defineSBox(comp, ctx, protocolRoundID, totalSize, col, input, poseidon2Round)
		}
		input = defineMatMulExternalInPlace(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
	}

	// poseidon2Round 4 - 24
	for poseidon2Round := 4; poseidon2Round < 25; poseidon2Round++ {
		input = defineAddRoundKey(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)

		// input[0] = defineSBox(comp, ctx, round, totalSize, 0, input, i)
		// for col := 0; col < 16; col++ {
		// 	input[col] = defineSBox(comp, ctx, round, totalSize, col, input, i)
		// }
		input = defineSBoxZero(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
		input = defineRoundInternal(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
	}

	// poseidon2Round 24 - 27
	for poseidon2Round := 25; poseidon2Round < 28; poseidon2Round++ {
		input = defineAddRoundKey(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
		for col := 0; col < 16; col++ {
			input[col] = defineSBox(comp, ctx, protocolRoundID, totalSize, col, input, poseidon2Round)
		}
		input = defineMatMulExternalInPlace(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
	}

	for i := range copy_input {
		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_Feed_Forward_COMPUTATION_%v_%v_%v", comp.SelfRecursionCount, uniqueID(comp), i),
			sym.Sub(output[i], sym.Add(input[i+8], copy_input[i])))
	}

	for i := range ctx.CompiledQueries {

		for col := 0; col < 8; col++ {
			comp.GenericFragmentedConditionalInclusion(
				protocolRoundID,
				ifaces.QueryIDf("Poseidon2_QUERY_%v_INCLUSION_%v_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp), col),
				[][]ifaces.Column{
					{
						ctx.StackedBlocks[col],
						ctx.StackedOldStates[col],
						ctx.StackedNewStates[col],
					},
				},
				[]ifaces.Column{
					ctx.CompiledQueries[i].Blocks[col],
					ctx.CompiledQueries[i].OldState[col],
					ctx.CompiledQueries[i].NewState[col],
				},
				nil,
				ctx.CompiledQueries[i].Selector,
			)
		}
	}

	comp.RegisterProverAction(protocolRoundID, ctx)

	return ctx
}

// The Run function implements the [wizard.ProverAction] interface. It starts by
// collecting all the unique triplets provided in the inputs and stacks them into
// a column and then pads the column with (0, 0, H(0, 0)) to match the size of the
// columns. The padding is done on the right.
//
// After, [StackedOldStates], [StackedBlocks] and [StackedNewStates] are assigned
// to the corresponding columns. The function goes and computes the poseidon2 intermediate values.
func (ctx *Poseidon2Context) Run(run *wizard.ProverRuntime) {

	var (
		zeroBlock field.Octuplet
		// [col][queries]
		stackedOldStates = make([][]field.Element, 8)
		stackedBlocks    = make([][]field.Element, 8)
		stackedNewStates = make([][]field.Element, 8)
		totalSize        = ctx.StackedOldStates[0].Size()
		poseidon2OfZero  = poseidon2.Poseidon2BlockCompression(zeroBlock, zeroBlock)
	)
	for i := range ctx.CompiledQueries {

		var (
			q         = ctx.CompiledQueries[i]
			os, b, ns [8]smartvectors.SmartVector
			sel       smartvectors.SmartVector
		)

		if q.Selector != nil {
			sel = q.Selector.GetColAssignment(run)
		}

		for col := 0; col < 8; col++ {
			os[col] = q.OldState[col].GetColAssignment(run)
			b[col] = q.Blocks[col].GetColAssignment(run)
			ns[col] = q.NewState[col].GetColAssignment(run)

			start, stop := smartvectors.CoWindowRange(os[col], b[col], ns[col], sel)
			// fmt.Printf("os[col]=-%v\n", os[col].Pretty())
			// fmt.Printf("b[col]=-%v\n", b[col].Pretty())
			// fmt.Printf("ns[col]=-%v\n", ns[col])

			// tryPushToStacked looks at the selector at position "j" and appends
			// the corresponding triplet (old state, block, new state) to the "stacked"
			// columns if the selector is not nil and is not zero at this position.
			tryPushToStacked := func(j int) {
				if sel != nil && sel.GetPtr(j).IsZero() {
					return
				}

				stackedOldStates[col] = append(stackedOldStates[col], os[col].Get(j))
				stackedBlocks[col] = append(stackedBlocks[col], b[col].Get(j))
				stackedNewStates[col] = append(stackedNewStates[col], ns[col].Get(j))
			}

			for j := start; j < stop; j++ {
				tryPushToStacked(j)
			}

			// The padding is done in the left, the first value is understood
			// by the query as a padding row.
			if start > 0 {
				tryPushToStacked(0)
				continue
			}

			// The padding is done on the right, the last value is understood
			// by the query as a padding row.
			if stop < os[col].Len() {
				tryPushToStacked(os[col].Len() - 1)
				continue
			}
		}
	}

	// If the range is not full, we add an extra row of padding. This is handy
	// because it allows us to specify the padding of all intermediate rows
	// as their last value. We can then simplify the code by not having a code
	// path dedicated to handling the padding.
	for col := 0; col < 8; col++ {
		if len(stackedOldStates[col]) < totalSize {

			stackedOldStates[col] = append(stackedOldStates[col], field.NewElement(0))
			stackedBlocks[col] = append(stackedBlocks[col], field.NewElement(0))
			stackedNewStates[col] = append(stackedNewStates[col], poseidon2OfZero[col])
		}

		run.AssignColumn(
			ctx.StackedOldStates[col].GetColID(),
			smartvectors.RightZeroPadded(stackedOldStates[col], totalSize))

		run.AssignColumn(
			ctx.StackedBlocks[col].GetColID(),
			smartvectors.RightZeroPadded(stackedBlocks[col], totalSize))

		run.AssignColumn(
			ctx.StackedNewStates[col].GetColID(),
			smartvectors.RightPadded(stackedNewStates[col], poseidon2OfZero[col], totalSize))
	}

	var (
		effectiveSize = len(stackedOldStates[0])

		// col, round, query
		matMulM4Tmp = make([][][]field.Element, 20) //col, round, query: [20][][effectiveSize]
		matMulM4    = make([][][]field.Element, 16) //col, round, query: [16][][effectiveSize]

		t              = make([][][]field.Element, 4)  //col, round, query: [4][][effectiveSize]
		matMulExternal = make([][][]field.Element, 16) //col, round, query: [16][][effectiveSize]

		addRoundKey = make([][][]field.Element, 16) //col, round, query: [16][][effectiveSize]

		sBox = make([][][]field.Element, 16) //col, round, query: [16][][effectiveSize]

		sBoxSum = make([][]field.Element, 28) // round, query: [][]

		matMulInternal = make([][][]field.Element, 16) //col, round, query: [16][][effectiveSize]

		/// Transposed values
		// round, query, col

		tMatMulM4Tmp = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][20]
		tMatMulM4    = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][16]

		tT              = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][4]
		tMatMulExternal = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][16]

		tAddRoundKey = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][16]

		tSBox = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][16]

		tMatMulInternal = make([][][]field.Element, 28) //round, query, col: [][effectiveSize][16]
	)

	for col := range matMulM4Tmp {
		matMulM4Tmp[col] = make([][]field.Element, 28)
		for round := 0; round < 28; round++ {
			matMulM4Tmp[col][round] = make([]field.Element, effectiveSize)
		}

	}

	for col := range matMulM4 {
		matMulM4[col] = make([][]field.Element, 28)
		matMulExternal[col] = make([][]field.Element, 28)
		addRoundKey[col] = make([][]field.Element, 28)

		sBox[col] = make([][]field.Element, 28)
		matMulInternal[col] = make([][]field.Element, 28)

		for round := 0; round < 28; round++ {
			matMulM4[col][round] = make([]field.Element, effectiveSize)
			matMulExternal[col][round] = make([]field.Element, effectiveSize)
			addRoundKey[col][round] = make([]field.Element, effectiveSize)

			sBox[col][round] = make([]field.Element, effectiveSize)
			matMulInternal[col][round] = make([]field.Element, effectiveSize)
		}
	}
	for col := range t {
		t[col] = make([][]field.Element, 28)
		for round := 0; round < 28; round++ {
			t[col][round] = make([]field.Element, effectiveSize)
		}
	}
	for round := 0; round < 28; round++ {
		sBoxSum[round] = make([]field.Element, effectiveSize)
	}

	for round := 0; round < 28; round++ {
		tMatMulM4Tmp[round] = make([][]field.Element, effectiveSize)
		tMatMulM4[round] = make([][]field.Element, effectiveSize)       //[][effectiveSize][16]
		tT[round] = make([][]field.Element, effectiveSize)              //[][effectiveSize][4]
		tMatMulExternal[round] = make([][]field.Element, effectiveSize) //[][effectiveSize][16]
		tAddRoundKey[round] = make([][]field.Element, effectiveSize)    //[][effectiveSize][16]
		tSBox[round] = make([][]field.Element, effectiveSize)           //[][effectiveSize][16]
		tMatMulInternal[round] = make([][]field.Element, effectiveSize) //[][effectiveSize][16]

		for query := 0; query < effectiveSize; query++ {
			tMatMulM4Tmp[round][query] = make([]field.Element, 20)
			tMatMulM4[round][query] = make([]field.Element, 16)       //[][effectiveSize][16]
			tT[round][query] = make([]field.Element, 4)               //[][effectiveSize][4]
			tMatMulExternal[round][query] = make([]field.Element, 16) //[][effectiveSize][16]
			tAddRoundKey[round][query] = make([]field.Element, 16)    //[][effectiveSize][16]
			tSBox[round][query] = make([]field.Element, 16)           //[][effectiveSize][16]
			tMatMulInternal[round][query] = make([]field.Element, 16) //[][effectiveSize][16]

		}
	}

	parallel.Execute(effectiveSize, func(start, stop int) {

		for query := start; query < stop; query++ {

			input := make([]field.Element, 16)
			for col := 0; col < 8; col++ {
				input[col] = stackedOldStates[col][query]
				input[col+8] = stackedBlocks[col][query]
			}
			// poseidon2Round 0
			tMatMulM4Tmp[0][query], tMatMulM4[0][query], tT[0][query], tMatMulExternal[0][query] = matMulExternalInPlace(input)
			input = tMatMulExternal[0][query]

			// poseidon2Round 1 - 3
			for poseidon2Round := 1; poseidon2Round < 4; poseidon2Round++ {
				tAddRoundKey[poseidon2Round][query] = addRoundKeyCompute(poseidon2Round-1, input)
				for col := 0; col < 16; col++ {
					tSBox[poseidon2Round][query][col] = sBoxCompute(col, tAddRoundKey[poseidon2Round][query])
				}
				tMatMulM4Tmp[poseidon2Round][query], tMatMulM4[poseidon2Round][query], tT[poseidon2Round][query], tMatMulExternal[poseidon2Round][query] = matMulExternalInPlace(tSBox[poseidon2Round][query])
				input = tMatMulExternal[poseidon2Round][query]
			}

			// poseidon2Round 4 - 24
			for poseidon2Round := 4; poseidon2Round < 25; poseidon2Round++ {
				tAddRoundKey[poseidon2Round][query] = addRoundKeyCompute(poseidon2Round-1, input)
				tSBox[poseidon2Round][query] = tAddRoundKey[poseidon2Round][query]
				tSBox[poseidon2Round][query][0] = sBoxCompute(0, tAddRoundKey[poseidon2Round][query])
				sBoxSum[poseidon2Round][query], tMatMulInternal[poseidon2Round][query] = matMulInternalInPlace(tSBox[poseidon2Round][query])
				input = tMatMulInternal[poseidon2Round][query]
			}

			// poseidon2Round 24 - 27
			for poseidon2Round := 25; poseidon2Round < 28; poseidon2Round++ {
				tAddRoundKey[poseidon2Round][query] = addRoundKeyCompute(poseidon2Round-1, input)
				for col := 0; col < 16; col++ {
					tSBox[poseidon2Round][query][col] = sBoxCompute(col, tAddRoundKey[poseidon2Round][query])
				}
				tMatMulM4Tmp[poseidon2Round][query], tMatMulM4[poseidon2Round][query], tT[poseidon2Round][query], tMatMulExternal[poseidon2Round][query] = matMulExternalInPlace(tSBox[poseidon2Round][query])
				input = tMatMulExternal[poseidon2Round][query]
			}
		}
	})

	// data conversation
	for col := 0; col < 20; col++ {
		for round := 0; round < 28; round++ {
			for query := 0; query < effectiveSize; query++ {
				matMulM4Tmp[col][round][query] = tMatMulM4Tmp[round][query][col]
			}
		}
	}
	for col := 0; col < 16; col++ {
		for round := 0; round < 28; round++ {
			for query := 0; query < effectiveSize; query++ {
				matMulM4[col][round][query] = tMatMulM4[round][query][col]
				matMulExternal[col][round][query] = tMatMulExternal[round][query][col]
				addRoundKey[col][round][query] = tAddRoundKey[round][query][col]
				sBox[col][round][query] = tSBox[round][query][col]
				matMulInternal[col][round][query] = tMatMulInternal[round][query][col]

			}
		}
	}
	for col := range t {
		for round := 0; round < 28; round++ {
			for query := 0; query < effectiveSize; query++ {
				t[col][round][query] = tT[round][query][col]
			}
		}
	}

	// AssignColumns
	for col := 0; col < 20; col++ {
		for round := 0; round < 4; round++ {
			run.AssignColumn(
				ctx.MatMulM4Tmp[col][round].GetColID(),
				smartvectors.RightPadded(matMulM4Tmp[col][round], matMulM4Tmp[col][round][effectiveSize-1], totalSize))
		}
		for round := 25; round < 28; round++ {
			run.AssignColumn(
				ctx.MatMulM4Tmp[col][round-21].GetColID(),                                                              // we didn't assign 0 elements, need to adjust the round position
				smartvectors.RightPadded(matMulM4Tmp[col][round], matMulM4Tmp[col][round][effectiveSize-1], totalSize)) // we compute and store the elements to their round position.
		}
	}

	for col := 0; col < 16; col++ {
		for round := 0; round < 4; round++ {
			run.AssignColumn(
				ctx.MatMulM4[col][round].GetColID(),
				smartvectors.RightPadded(matMulM4[col][round], matMulM4[col][round][effectiveSize-1], totalSize))

			run.AssignColumn(
				ctx.MatMulExternal[col][round].GetColID(),
				smartvectors.RightPadded(matMulExternal[col][round], matMulExternal[col][round][effectiveSize-1], totalSize))
		}
		for round := 25; round < 28; round++ {
			run.AssignColumn(
				ctx.MatMulM4[col][round-21].GetColID(),
				smartvectors.RightPadded(matMulM4[col][round], matMulM4[col][round][effectiveSize-1], totalSize))

			run.AssignColumn(
				ctx.MatMulExternal[col][round-21].GetColID(),
				smartvectors.RightPadded(matMulExternal[col][round], matMulExternal[col][round][effectiveSize-1], totalSize))
		}

		for round := 1; round < 28; round++ {
			run.AssignColumn(
				ctx.AddRoundKey[col][round-1].GetColID(),
				smartvectors.RightPadded(addRoundKey[col][round], addRoundKey[col][round][effectiveSize-1], totalSize))

			run.AssignColumn(
				ctx.SBox[col][round-1].GetColID(),
				smartvectors.RightPadded(sBox[col][round], sBox[col][round][effectiveSize-1], totalSize))
		}

		for round := 4; round < 25; round++ {
			run.AssignColumn(
				ctx.MatMulInternal[col][round-4].GetColID(),
				smartvectors.RightPadded(matMulInternal[col][round], matMulInternal[col][round][effectiveSize-1], totalSize))

		}
	}
	for col := range t {
		for round := 0; round < 4; round++ {
			run.AssignColumn(
				ctx.T[col][round].GetColID(),
				smartvectors.RightPadded(t[col][round], t[col][round][effectiveSize-1], totalSize))
		}

		for round := 25; round < 28; round++ {
			run.AssignColumn(
				ctx.T[col][round-21].GetColID(),
				smartvectors.RightPadded(t[col][round], t[col][round][effectiveSize-1], totalSize))
		}
	}

	for round := 4; round < 25; round++ {
		run.AssignColumn(
			ctx.SBoxSum[round-4].GetColID(),
			smartvectors.RightPadded(sBoxSum[round], sBoxSum[round][effectiveSize-1], totalSize))
	}

}

// uniqueID returns an integer helping to uniquely identify the items generated
// by the compilation of a Poseidon2 query.
func uniqueID(comp *wizard.CompiledIOP) int {
	return len(comp.Columns.AllKeys())
}
