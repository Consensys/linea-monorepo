package poseidon2

import (
	"github.com/consensys/linea-monorepo/prover/crypto/poseidon2"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/utils"
	"github.com/consensys/linea-monorepo/prover/utils/parallel"
)

const internalPackedSize = 2
const externalPackedSize = 1

// Poseidon2Context is a compilation context storing all the artefacts generated by
// the compilation of Poseidon2 query. Those are: the columns created to emulate the
// evaluation of the Poseidon2 compilation function.
//
// The context also implements the [wizard.ProverAction] interface.
type Poseidon2Context struct {
	// CompiledQueries stores the Poseidon2 queries that have been compiled.
	CompiledQueries []*query.Poseidon2

	// Stacked data columns are organized by block location index (each ifaces.Column stores query values).
	//
	// StackedOldState stores all the old states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedOldStates [blockSize]ifaces.Column
	// StackedBlocks stores all the blocks of the Poseidon2 computation. For all
	// unique triplets (oldState, blocks, newStates).
	StackedBlocks [blockSize]ifaces.Column
	// StackedNewStates stores all the new states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedNewStates [blockSize]ifaces.Column

	// Interm stores the intermediate values of the Poseidon2 computation. This
	// internal to the compiler.
	Interm [][]ifaces.Column
}

// CompilePoseidon2 compiles all the Poseidon2 queries in the [comp] object. The compiler
// works by creating its own module responsible for checking each unique Poseidon2
// query statements, taking into account the padding.
func CompilePoseidon2(comp *wizard.CompiledIOP) {
	_ = defineContext(comp)
}

// defineContext generates the constraints for the Poseidon2 computation and returns
// the compilation context. The function also registers the relevant prover
// actions to assign the generated columns.
//
// The function works by:
//
//   - scanning the [comp] object, looking for uncompiled Poseidon2 queries and collecting
//     their inputs.
//   - declaring the [StackedBlocks], [StackedOldStates] and [StackedNewStates] which
//     are used to stack all the unique triplets provided in the inputs.
//   - declaring the intermediate computations for all Poseidon2 rounds and the
//     constraints enforcing their correctness.
func defineContext(comp *wizard.CompiledIOP) *Poseidon2Context {

	var (
		ctx             = &Poseidon2Context{}
		protocolRoundID = 0
		allQueries      = comp.QueriesNoParams.AllUnignoredKeys()
		totalSize       = 0
	)

	for _, qName := range allQueries {
		if q_, ok := comp.QueriesNoParams.Data(qName).(query.Poseidon2); ok {
			comp.QueriesNoParams.MarkAsIgnored(qName)
			protocolRoundID = max(protocolRoundID, comp.QueriesNoParams.Round(qName))
			totalSize += q_.Blocks[0].Size()
			ctx.CompiledQueries = append(ctx.CompiledQueries, &q_)
		}
	}
	// The compilation has nothing to do if no Poseidon2 queries were found
	if len(ctx.CompiledQueries) == 0 {
		return nil
	}

	totalSize = utils.NextPowerOfTwo(totalSize)

	// Define stacked input/output columns
	for block := 0; block < blockSize; block++ {
		ctx.StackedOldStates[block] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_OLD_STATES_SelfRecursionCount_%v_ID_%v_BLOCK_%v", comp.SelfRecursionCount, uniqueID(comp), block),
			totalSize, true)

		ctx.StackedBlocks[block] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_BLOCKS_SelfRecursionCount_%v_ID_%v_BLOCK_%v", comp.SelfRecursionCount, uniqueID(comp), block),
			totalSize, true)

		ctx.StackedNewStates[block] = comp.InsertCommit(protocolRoundID,
			ifaces.ColIDf("Poseidon2_STACKED_NEW_STATES_SelfRecursionCount_%v_ID_%v_BLOCK_%v", comp.SelfRecursionCount, uniqueID(comp), block),
			totalSize, true)
	}

	input := make([]ifaces.Column, width)
	copy(input[:blockSize], ctx.StackedOldStates[:])
	copy(input[blockSize:], ctx.StackedBlocks[:])

	output := make([]ifaces.Column, blockSize)
	copy(output, ctx.StackedNewStates[:])

	// Create a copy for the feed-forward step
	feedForwardInput := make([]ifaces.Column, blockSize)
	copy(feedForwardInput, ctx.StackedBlocks[:])

	ctx.Interm = checkPoseidon2BlockCompressionExpression(
		comp,
		asExprs(ctx.StackedOldStates[:]),
		asExprs(ctx.StackedBlocks[:]),
		asExprs(ctx.StackedNewStates[:]),
	)

	for i := range ctx.CompiledQueries {

		for block := 0; block < blockSize; block++ {
			comp.GenericFragmentedConditionalInclusion(
				protocolRoundID,
				ifaces.QueryIDf("Poseidon2_QUERY_%v_INCLUSION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", i, comp.SelfRecursionCount, uniqueID(comp), block),
				[][]ifaces.Column{
					{
						ctx.StackedBlocks[block],
						ctx.StackedOldStates[block],
						ctx.StackedNewStates[block],
					},
				},
				[]ifaces.Column{
					ctx.CompiledQueries[i].Blocks[block],
					ctx.CompiledQueries[i].OldState[block],
					ctx.CompiledQueries[i].NewState[block],
				},
				nil,
				ctx.CompiledQueries[i].Selector,
			)
		}
	}

	comp.RegisterProverAction(protocolRoundID, ctx)

	return ctx
}

// // defineExternalRound defines constraints for a single external Poseidon2 round.
// func defineExternalRound(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
// 	// Add Round Key
// 	input = defineAddRoundKey(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
// 	// S-Box
// 	for block := 0; block < width; block++ {
// 		input[block] = defineSBox(comp, ctx, protocolRoundID, totalSize, block, input, poseidon2Round)
// 	}
// 	// External Matrix Multiplication
// 	return defineMatMulExternal(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
// }

// // defineInternalRound defines constraints for a single internal Poseidon2 round.
// func defineInternalRound(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
// 	// Add Round Key
// 	input = defineAddRoundKey(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
// 	// S-Box (only on the first element)
// 	for block := 0; block < width; block++ {
// 		input[block] = defineSBox(comp, ctx, protocolRoundID, totalSize, block, input, poseidon2Round)
// 	}
// 	// Internal Matrix Multiplication
// 	return defineMatMulInternal(comp, ctx, protocolRoundID, totalSize, input, poseidon2Round)
// }

// // External Matrix Multiplication
// func defineMatMulExternal(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
// 	matMulM4Tmp := [matMulM4TmpSize]ifaces.Column{}
// 	matMulM4 := [width]ifaces.Column{}
// 	t := [tSize]ifaces.Column{}
// 	matMulExternal := [width]ifaces.Column{}

// 	// MatMulExternalInPlace
// 	// Declare temporary columns for the matrix multiplication.
// 	for block := 0; block < matMulM4TmpSize; block++ {
// 		matMulM4Tmp[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.MatMulM4Tmp[block] = append(ctx.MatMulM4Tmp[block], matMulM4Tmp[block])
// 	}
// 	for block := 0; block < width; block++ {
// 		matMulM4[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulM4_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.MatMulM4[block] = append(ctx.MatMulM4[block], matMulM4[block])
// 	}
// 	for block := 0; block < tSize; block++ {
// 		t[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_T_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.T[block] = append(ctx.T[block], t[block])
// 	}
// 	for block := 0; block < width; block++ {
// 		matMulExternal[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulExternal_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.MatMulExternal[block] = append(ctx.MatMulExternal[block], matMulExternal[block])
// 	}
// 	// Insert constraints for the matrix multiplication.
// 	for chunk := 0; chunk < 4; chunk++ {
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk), sym.Sub(matMulM4Tmp[5*chunk], sym.Add(input[4*chunk], input[4*chunk+1])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+1), sym.Sub(matMulM4Tmp[5*chunk+1], sym.Add(input[4*chunk+2], input[4*chunk+3])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+2), sym.Sub(matMulM4Tmp[5*chunk+2], sym.Add(matMulM4Tmp[5*chunk], matMulM4Tmp[5*chunk+1])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+3), sym.Sub(matMulM4Tmp[5*chunk+3], sym.Add(matMulM4Tmp[5*chunk+2], input[4*chunk+1])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4Tmp_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5*chunk+4), sym.Sub(matMulM4Tmp[5*chunk+4], sym.Add(matMulM4Tmp[5*chunk+2], input[4*chunk+3])))

// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+3), sym.Sub(matMulM4[4*chunk+3], sym.Add(input[4*chunk], input[4*chunk], matMulM4Tmp[5*chunk+4])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+1), sym.Sub(matMulM4[4*chunk+1], sym.Add(input[4*chunk+2], input[4*chunk+2], matMulM4Tmp[5*chunk+3])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk), sym.Sub(matMulM4[4*chunk], sym.Add(matMulM4Tmp[5*chunk], matMulM4Tmp[5*chunk+3])))
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulM4_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4*chunk+2), sym.Sub(matMulM4[4*chunk+2], sym.Add(matMulM4Tmp[5*chunk+1], matMulM4Tmp[5*chunk+4])))
// 	}
// 	for block := 0; block < tSize; block++ {
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_T_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), sym.Sub(t[block], sym.Add(matMulM4[block], matMulM4[block+4], matMulM4[block+8], matMulM4[block+12])))
// 	}
// 	for block := 0; block < width; block++ {
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulExternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), sym.Sub(matMulExternal[block], sym.Add(matMulM4[block], t[block%4])))
// 	}
// 	return matMulExternal[:]
// }

// // Internal Matrix Multiplication
// func defineMatMulInternal(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
// 	matMulInternal := [width]ifaces.Column{}
// 	sBoxSum := comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBoxSum_SelfRecursionCount_%v_ID_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp)), totalSize)
// 	ctx.SBoxSum = append(ctx.SBoxSum, sBoxSum)

// 	// MatMulInternalInPlace
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBoxSum_COMPUTATION_SelfRecursionCount_%v_ID_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp)),
// 		sym.Sub(sBoxSum, sym.Add(input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7], input[8], input[9], input[10], input[11], input[12], input[13], input[14], input[15])))

// 	for block := 0; block < width; block++ {
// 		matMulInternal[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_MatMulInternal_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.MatMulInternal[block] = append(ctx.MatMulInternal[block], matMulInternal[block])
// 	}

// 	// mul by diag16:
// 	// [-2, 1, 2, 1/2,
// 	//  3, 4, -1/2, -3,
// 	// -4, 1/2^8, 1/2^3, 1/2^24,
// 	// -1/2^8, -1/2^3, -1/2^4, -1/2^24]
// 	// matMulInternal[0] = sBoxSum - 2 * input[0]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 0),
// 		sym.Sub(matMulInternal[0], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(2), input[0]))))
// 	// matMulInternal[1] = sBoxSum + input[1]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 1),
// 		sym.Sub(matMulInternal[1], sym.Add(sBoxSum, input[1])))
// 	// matMulInternal[2] = sBoxSum + 2 * input[2]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 2),
// 		sym.Sub(matMulInternal[2], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(2), input[2]))))
// 	// matMulInternal[3] = sBoxSum + 1/2 * input[3]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 3),
// 		sym.Sub(matMulInternal[3], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1065353217), input[3]))))
// 	// matMulInternal[4] = sBoxSum + 3 * input[4]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 4),
// 		sym.Sub(matMulInternal[4], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(3), input[4]))))
// 	// matMulInternal[5] = sBoxSum + 4 * input[5]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 5),
// 		sym.Sub(matMulInternal[5], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(4), input[5]))))
// 	// matMulInternal[6] = sBoxSum - 1/2 * input[6]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 6),
// 		sym.Sub(matMulInternal[6], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1065353217), input[6]))))
// 	// matMulInternal[7] = sBoxSum - 3 * input[7]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 7),
// 		sym.Sub(matMulInternal[7], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(3), input[7]))))
// 	// matMulInternal[8] = sBoxSum - 4 * input[8]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 8),
// 		sym.Sub(matMulInternal[8], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(4), input[8]))))
// 	// matMulInternal[9] = sBoxSum + 1/2^8 * input[9]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 9),
// 		sym.Sub(matMulInternal[9], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(2122383361), input[9]))))
// 	// matMulInternal[10] = sBoxSum + 1/2^3 * input[10]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 10),
// 		sym.Sub(matMulInternal[10], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(1864368129), input[10]))))
// 	// matMulInternal[11] = sBoxSum + 1/2^24 * input[11]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 11),
// 		sym.Sub(matMulInternal[11], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(127), input[11]))))
// 	// matMulInternal[12] = sBoxSum - 1/2^8 * input[12]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 12),
// 		sym.Sub(matMulInternal[12], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(2122383361), input[12]))))
// 	// matMulInternal[13] = sBoxSum - 1/2^3 * input[13]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 13),
// 		sym.Sub(matMulInternal[13], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1864368129), input[13]))))
// 	// matMulInternal[14] = sBoxSum - 1/2^4 * input[14]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 14),
// 		sym.Sub(matMulInternal[14], sym.Sub(sBoxSum, sym.Mul(sym.NewConstant(1997537281), input[14]))))
// 	// matMulInternal[15] = sBoxSum - 1/2^24 * input[15]
// 	comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_MatMulInternal_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), 15),
// 		sym.Sub(matMulInternal[15], sym.Add(sBoxSum, sym.Mul(sym.NewConstant(127), input[15]))))
// 	return matMulInternal[:]
// }

// // Add Round Key
// func defineAddRoundKey(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize int, input []ifaces.Column, poseidon2Round int) []ifaces.Column {
// 	addRoundKey := [width]ifaces.Column{}

// 	for block := 0; block < len(poseidon2.RoundKeys[poseidon2Round-1]); block++ {
// 		addRoundKey[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_AddRoundKey_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.AddRoundKey[block] = append(ctx.AddRoundKey[block], addRoundKey[block])
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_AddRoundKey_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block),
// 			sym.Sub(addRoundKey[block], sym.Add(input[block], poseidon2.RoundKeys[poseidon2Round-1][block]))) // Adjust the roundID because the initial round starts from 1, while the round key starts from 0.
// 	}

// 	for block := len(poseidon2.RoundKeys[poseidon2Round-1]); block < 16; block++ {
// 		addRoundKey[block] = comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_AddRoundKey_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block), totalSize)
// 		ctx.AddRoundKey[block] = append(ctx.AddRoundKey[block], addRoundKey[block])
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_AddRoundKey_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), block),
// 			sym.Sub(addRoundKey[block], input[block]))
// 	}

// 	return addRoundKey[:]
// }

// // S-Box
// func defineSBox(comp *wizard.CompiledIOP, ctx *Poseidon2Context, protocolRoundID, totalSize, index int, input []ifaces.Column, poseidon2Round int) ifaces.Column {
// 	sBox := comp.InsertCommit(protocolRoundID, ifaces.ColIDf("Poseidon2_ROUND_%v_SBox_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index), totalSize)
// 	ctx.SBox[index] = append(ctx.SBox[index], sBox)

// 	if poseidon2Round < fullRounds-partialRounds && poseidon2Round > partialRounds && index != 0 {
// 		// Except for the first element, running in the internal rounds
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBox_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index),
// 			sym.Sub(sBox, input[index]))
// 	} else {
// 		comp.InsertGlobal(protocolRoundID, ifaces.QueryIDf("Poseidon2_ROUND_%v_SBox_COMPUTATION_SelfRecursionCount_%v_ID_%v_BLOCK_%v", poseidon2Round, comp.SelfRecursionCount, uniqueID(comp), index),
// 			sym.Sub(sBox, sym.Mul(sym.Square(input[index]), input[index])))
// 	}

// 	return sBox
// }

// The Run function implements the [wizard.ProverAction] interface. It starts by
// collecting all the unique triplets provided in the inputs and stacks them into
// a column and then pads the column with (0, 0, H(0, 0)) to match the size of the
// columns. The padding is done on the right.
//
// After, [StackedOldStates], [StackedBlocks] and [StackedNewStates] are assigned
// to the corresponding columns. The function goes and computes the poseidon2 intermediate values.
func (ctx *Poseidon2Context) Run(run *wizard.ProverRuntime) {

	var (
		zeroBlock field.Octuplet
		// Stacked data columns are organized by block location index, then by query index
		stackedOldStates = make([][]field.Element, blockSize)
		stackedBlocks    = make([][]field.Element, blockSize)
		stackedNewStates = make([][]field.Element, blockSize)
		totalSize        = ctx.StackedOldStates[0].Size()
		poseidon2OfZero  = poseidon2.Poseidon2BlockCompression(zeroBlock, zeroBlock)
	)

	for i := range ctx.CompiledQueries {

		var (
			q         = ctx.CompiledQueries[i]
			os, b, ns [blockSize]smartvectors.SmartVector
			sel       smartvectors.SmartVector
		)

		if q.Selector != nil {
			sel = q.Selector.GetColAssignment(run)
		}

		for block := 0; block < blockSize; block++ {
			os[block] = q.OldState[block].GetColAssignment(run)
			b[block] = q.Blocks[block].GetColAssignment(run)
			ns[block] = q.NewState[block].GetColAssignment(run)

			start, stop := smartvectors.CoWindowRange(os[block], b[block], ns[block], sel)

			// tryPushToStacked looks at the selector at position "j" and appends
			// the corresponding triplet (old state, block, new state) to the "stacked"
			// columns if the selector is not nil and is not zero at this position.
			tryPushToStacked := func(j int) {
				if sel != nil && sel.GetPtr(j).IsZero() {
					return
				}

				stackedOldStates[block] = append(stackedOldStates[block], os[block].Get(j))
				stackedBlocks[block] = append(stackedBlocks[block], b[block].Get(j))
				stackedNewStates[block] = append(stackedNewStates[block], ns[block].Get(j))
			}

			for j := start; j < stop; j++ {
				tryPushToStacked(j)
			}

			// The padding is done in the left, the first value is understood
			// by the query as a padding row.
			if start > 0 {
				tryPushToStacked(0)
				continue
			}

			// The padding is done on the right, the last value is understood
			// by the query as a padding row.
			if stop < os[block].Len() {
				tryPushToStacked(os[block].Len() - 1)
				continue
			}
		}
	}

	// If the range is not full, we add an extra row of padding. This is handy
	// because it allows us to specify the padding of all intermediate rows
	// as their last value. We can then simplify the code by not having a code
	// path dedicated to handling the padding.
	for block := 0; block < blockSize; block++ {
		if len(stackedOldStates[block]) < totalSize {
			stackedOldStates[block] = append(stackedOldStates[block], field.NewElement(0))
			stackedBlocks[block] = append(stackedBlocks[block], field.NewElement(0))
			stackedNewStates[block] = append(stackedNewStates[block], poseidon2OfZero[block])
		}

		run.AssignColumn(
			ctx.StackedOldStates[block].GetColID(),
			smartvectors.RightZeroPadded(stackedOldStates[block], totalSize))
		run.AssignColumn(
			ctx.StackedBlocks[block].GetColID(),
			smartvectors.RightZeroPadded(stackedBlocks[block], totalSize))
		run.AssignColumn(
			ctx.StackedNewStates[block].GetColID(),
			smartvectors.RightPadded(stackedNewStates[block], poseidon2OfZero[block], totalSize))
	}

	var (
		effectiveSize      = len(stackedOldStates[0])
		intermediateStates = make([][][]field.Element, fullRounds)
	)

	for i := range intermediateStates {
		intermediateStates[i] = make([][]field.Element, width)
		for j := range intermediateStates[i] {
			// The last iteration of the loop computes the dummy value.
			intermediateStates[i][j] = make([]field.Element, effectiveSize+1)
		}
	}

	parallel.Execute(effectiveSize+1, func(start, stop int) {
		for row := start; row < stop; row++ {

			// If the row is the last one, we leave zeroes in the state
			state := make([]field.Element, width)
			if row < effectiveSize {
				for col := 0; col < blockSize; col++ {
					state[col] = stackedOldStates[col][row]
					state[col+blockSize] = stackedBlocks[col][row]
				}
			}

			_, _, _, state = matMulExternalInPlace(state)

			// external rounds
			for round := 1; round < 1+partialRounds; round++ {
				state = addRoundKeyCompute(round-1, state)
				for col := 0; col < width; col++ {
					state[col] = sBoxCompute(col, round, state)
				}
				_, _, _, state = matMulExternalInPlace(state)
				for col := 0; col < width; col++ {
					intermediateStates[round][col][row] = state[col]
				}
			}

			// internal rounds
			for round := 1 + partialRounds; round < fullRounds-partialRounds; round++ {
				state = addRoundKeyCompute(round-1, state)
				for col := 0; col < 16; col++ {
					state[col] = sBoxCompute(col, round, state)
				}
				for col := 0; col < 16; col++ {
					intermediateStates[round][col][row] = state[col]
				}
				_, state = matMulInternalInPlace(state)

			}

			// external rounds
			for round := fullRounds - partialRounds; round < fullRounds; round++ {
				state = addRoundKeyCompute(round-1, state)
				for col := 0; col < width; col++ {
					state[col] = sBoxCompute(col, round, state)
				}
				_, _, _, state = matMulExternalInPlace(state)
				for col := 0; col < width; col++ {
					intermediateStates[round][col][row] = state[col]
				}
			}
		}
	})
	counter := 0
	for round := 1; round < fullRounds-1; round++ {
		if round >= 1+partialRounds && round < fullRounds-partialRounds {

			if round%internalPackedSize == 0 {
				for col := 0; col < 16; col++ {
					run.AssignColumn(
						ctx.Interm[counter][col].GetColID(),
						smartvectors.RightPadded(
							intermediateStates[round][col][:effectiveSize],
							intermediateStates[round][col][effectiveSize],
							totalSize,
						),
					)
				}
			} else {
				for col := 0; col < 1; col++ {
					run.AssignColumn(
						ctx.Interm[counter][col].GetColID(),
						smartvectors.RightPadded(
							intermediateStates[round][col][:effectiveSize],
							intermediateStates[round][col][effectiveSize],
							totalSize,
						),
					)
				}
			}

			counter++

		} else {

			for col := 0; col < width; col++ {
				run.AssignColumn(
					ctx.Interm[counter][col].GetColID(),
					smartvectors.RightPadded(
						intermediateStates[round][col][:effectiveSize],
						intermediateStates[round][col][effectiveSize],
						totalSize,
					),
				)
			}
			counter++

		}

	}
}

// uniqueID returns an integer helping to uniquely identify the items generated
// by the compilation of a Poseidon2 query.
func uniqueID(comp *wizard.CompiledIOP) int {
	return len(comp.Columns.AllKeys())
}
