package poseidon2

import (
	"github.com/consensys/linea-monorepo/prover/crypto/poseidon2"
	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	sym "github.com/consensys/linea-monorepo/prover/symbolic"
	"github.com/consensys/linea-monorepo/prover/utils"
	"github.com/consensys/linea-monorepo/prover/utils/parallel"
)

// Poseidon2Context is a compilation context storing all the artefacts generated by
// the compilation of Poseidon2 query. Those are: the columns created to emulate the
// evaluation of the Poseidon2 compilation function.
//
// The context also implements the [wizard.ProverAction] interface.
type Poseidon2Context struct {

	// CompiledQueries stores the Poseidon2 queries that have been compiled.
	CompiledQueries []*query.Poseidon2

	// StackedOldState stores all the old states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedOldStates ifaces.Column
	// StackedBlocks stores all the blocks of the Poseidon2 computation. For all
	// unique triplets (oldState, blocks, newStates).
	StackedBlocks ifaces.Column
	// StackedNewStates stores all the new states of the Poseidon2 computation. For
	// all unique triplets (oldState, blocks, newStates).
	StackedNewStates ifaces.Column
	// SumPow4s stores the values of (prevRound + oldState + ark_i)^4 for all
	// Poseidon2 rounds "i".
	SumPow4s []ifaces.Column
	// RoundResult stores the values of (prevRound + oldState + ark_i)^4 for all
	// Poseidon2 rounds "i". The last value is set to [StackedNewStates].
	RoundResults []ifaces.Column
}

// CompilePoseidon2 compiles all the Poseidon2 queries in the [comp] object. The compiler
// works by creating its own module responsible for checking each unique Poseidon2
// query statements, taking into account the padding.
func CompilePoseidon2(comp *wizard.CompiledIOP) {
	_ = defineContext(comp)
}

// defineContext generates the constraints for the Poseidon2 computation and returns
// the compilation context. The function also registers the relevant prover
// actions to assign the generated columns.
//
// The function works by:
//
//   - scanning the [comp] object, looking for uncompiled Poseidon2 queries and collecting
//     their inputs.
//   - declaring the [StackedBlocks], [StackedOldStates] and [StackedNewStates] which
//     are used to stack all the unique triplets provided in the inputs.
//   - declaring the [SumPow4s] and [RoundResults] for all Poseidon2 rounds and the
//     constraints enforcing their correctness.
func defineContext(comp *wizard.CompiledIOP) *Poseidon2Context {

	var (
		ctx        = &Poseidon2Context{}
		round      = 0
		allQueries = comp.QueriesNoParams.AllUnignoredKeys()
		totalSize  = 0
	)

	for _, qName := range allQueries {
		if q_, ok := comp.QueriesNoParams.Data(qName).(query.Poseidon2); ok {
			comp.QueriesNoParams.MarkAsIgnored(qName)
			round = max(round, comp.QueriesNoParams.Round(qName))
			totalSize += q_.Blocks.Size()
			ctx.CompiledQueries = append(ctx.CompiledQueries, &q_)
		}
	}

	// The compilation has nothing to do if no Poseidon2 queries were found
	if len(ctx.CompiledQueries) == 0 {
		return nil
	}

	totalSize = utils.NextPowerOfTwo(totalSize)

	ctx.StackedOldStates = comp.InsertCommit(round,
		ifaces.ColIDf("Poseidon2_STACKED_OLD_STATES_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	ctx.StackedBlocks = comp.InsertCommit(round,
		ifaces.ColIDf("Poseidon2_STACKED_BLOCKS_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	ctx.StackedNewStates = comp.InsertCommit(round,
		ifaces.ColIDf("Poseidon2_STACKED_NEW_STATES_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		totalSize)

	for i := 0; i < len(poseidon2.Constants); i++ {

		var (
			prev = ctx.StackedBlocks
			ark  = poseidon2.Constants[i]
		)

		if i > 0 {
			prev = ctx.RoundResults[i-1]
		}

		sp4 := comp.InsertCommit(round,
			ifaces.ColIDf("Poseidon2_ROUND_%v_SUM_POW4_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			totalSize)

		ctx.SumPow4s = append(ctx.SumPow4s, sp4)

		rr := comp.InsertCommit(round,
			ifaces.ColIDf("Poseidon2_ROUND_%v_RESULT_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			totalSize)

		ctx.RoundResults = append(ctx.RoundResults, rr)

		comp.InsertGlobal(round,
			ifaces.QueryIDf("Poseidon2_ROUND_%v_SUM_POW4_COMPUTATION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			sym.Sub(sp4, sym.Pow(sym.Add(prev, ark, ctx.StackedOldStates), 4)))

		comp.InsertGlobal(round,
			ifaces.QueryIDf("Poseidon2_ROUND_%v_RESULT_COMPUTATION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			sym.Sub(rr, sym.Mul(sym.Pow(sp4, 4), sym.Add(prev, ark, ctx.StackedOldStates))))
	}

	comp.InsertGlobal(round,
		ifaces.QueryIDf("Poseidon2_STACKED_NEW_STATES_COMPUTATION_%v_%v", comp.SelfRecursionCount, uniqueID(comp)),
		sym.Sub(ctx.StackedNewStates, ctx.StackedOldStates, ctx.StackedOldStates, ctx.StackedBlocks, ctx.RoundResults[len(poseidon2.Constants)-1]))

	for i := range ctx.CompiledQueries {

		comp.GenericFragmentedConditionalInclusion(
			round,
			ifaces.QueryIDf("Poseidon2_QUERY_%v_INCLUSION_%v_%v", i, comp.SelfRecursionCount, uniqueID(comp)),
			[][]ifaces.Column{
				{
					ctx.StackedBlocks,
					ctx.StackedOldStates,
					ctx.StackedNewStates,
				},
			},
			[]ifaces.Column{
				ctx.CompiledQueries[i].Blocks,
				ctx.CompiledQueries[i].OldState,
				ctx.CompiledQueries[i].NewState,
			},
			nil,
			ctx.CompiledQueries[i].Selector,
		)
	}

	comp.RegisterProverAction(round, ctx)

	return ctx
}

// The Run function implements the [wizard.ProverAction] interface. It starts by
// collecting all the unique triplets provided in the inputs and stacks them into
// a column and then pads the column with (0, 0, H(0, 0)) to match the size of the
// columns. The padding is done on the right.
//
// After, [StackedOldStates], [StackedBlocks] and [StackedNewStates] are assigned
// to the corresponding columns. The function goes and computes the [SumPow4s] and
// [RoundResults] columns.
func (ctx *Poseidon2Context) Run(run *wizard.ProverRuntime) {

	var (
		stackedOldStates = make([]field.Element, 0)
		stackedBlocks    = make([]field.Element, 0)
		stackedNewStates = make([]field.Element, 0)
		totalSize        = ctx.StackedOldStates.Size()
		poseidon2OfZero  = poseidon2.BlockCompression(field.NewElement(0), field.NewElement(0))
	)

	for i := range ctx.CompiledQueries {

		var (
			q   = ctx.CompiledQueries[i]
			os  = q.OldState.GetColAssignment(run)
			b   = q.Blocks.GetColAssignment(run)
			ns  = q.NewState.GetColAssignment(run)
			sel smartvectors.SmartVector
		)

		if q.Selector != nil {
			sel = q.Selector.GetColAssignment(run)
		}

		start, stop := smartvectors.CoWindowRange(os, b, ns, sel)

		// tryPushToStacked looks at the selector at position "j" and appends
		// the corresponding triplet (old state, block, new state) to the "stacked"
		// columns if the selector is not nil and is not zero at this position.
		tryPushToStacked := func(j int) {
			if sel != nil && sel.GetPtr(j).IsZero() {
				return
			}

			stackedOldStates = append(stackedOldStates, os.Get(j))
			stackedBlocks = append(stackedBlocks, b.Get(j))
			stackedNewStates = append(stackedNewStates, ns.Get(j))
		}

		for j := start; j < stop; j++ {
			tryPushToStacked(j)
		}

		// The padding is done in the left, the first value is understood
		// by the query as a padding row.
		if start > 0 {
			tryPushToStacked(0)
			continue
		}

		// The padding is done on the right, the last value is understood
		// by the query as a padding row.
		if stop < os.Len() {
			tryPushToStacked(os.Len() - 1)
			continue
		}
	}

	// If the range is not full, we add an extra row of padding. This is handy
	// because it allows us to specify the padding of all intermediate rows
	// as their last value. We can then simplify the code by not having a code
	// path dedicated to handling the padding.
	if len(stackedOldStates) < totalSize {

		stackedOldStates = append(stackedOldStates, field.NewElement(0))
		stackedBlocks = append(stackedBlocks, field.NewElement(0))
		stackedNewStates = append(stackedNewStates, poseidon2OfZero)
	}

	run.AssignColumn(
		ctx.StackedOldStates.GetColID(),
		smartvectors.RightZeroPadded(stackedOldStates, totalSize))

	run.AssignColumn(
		ctx.StackedBlocks.GetColID(),
		smartvectors.RightZeroPadded(stackedBlocks, totalSize))

	run.AssignColumn(
		ctx.StackedNewStates.GetColID(),
		smartvectors.RightPadded(stackedNewStates, poseidon2OfZero, totalSize))

	var (
		effectiveSize = len(stackedOldStates)
		sumPow4s      = make([][]field.Element, len(poseidon2.Constants))
		roundResults  = make([][]field.Element, len(poseidon2.Constants))
	)

	for i := range sumPow4s {
		sumPow4s[i] = make([]field.Element, effectiveSize)
		roundResults[i] = make([]field.Element, effectiveSize)
	}

	parallel.Execute(effectiveSize, func(start, stop int) {

		for row := start; row < stop; row++ {

			var (
				s = stackedBlocks[row]
				k = stackedOldStates[row]
			)

			for poseidon2Round := 0; poseidon2Round < len(poseidon2.Constants); poseidon2Round++ {

				ark := poseidon2.Constants[poseidon2Round]

				var (
					// sum = (s + k + ark)
					sum field.Element
					// sp4 will be set as sp4 = sum^4.
					sp4 = &sumPow4s[poseidon2Round][row]
					// rr will be set as rr = sp4^4 * sum
					rr = &roundResults[poseidon2Round][row]
				)

				// This computes "sum"
				sum.Add(&s, &k)
				sum.Add(&sum, &ark)

				// This computes "sp4"
				sp4.Square(&sum)
				sp4.Square(sp4)

				// This computes "rr"
				rr.Square(sp4)
				rr.Square(rr)
				rr.Mul(rr, &sum)

				s = *rr
			}
		}
	})

	for i := range sumPow4s {

		// As a reminder, the last value of sumPow4s[i] is the padding value. (if need be).
		// If it does not, the function [RightPadded] will simply ditch the provided value.
		run.AssignColumn(
			ctx.SumPow4s[i].GetColID(),
			smartvectors.RightPadded(sumPow4s[i], sumPow4s[i][effectiveSize-1], totalSize))

		run.AssignColumn(
			ctx.RoundResults[i].GetColID(),
			smartvectors.RightPadded(roundResults[i], roundResults[i][effectiveSize-1], totalSize))
	}

}

// uniqueID returns an integer helping to uniquely identify the items generated
// by the compilation of a Poseidon2 query.
func uniqueID(comp *wizard.CompiledIOP) int {
	return len(comp.Columns.AllKeys())
}
