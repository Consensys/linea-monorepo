package testtools

import (
	"strconv"

	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
)

// InclusionTestcase represents a lookup relationship and and its assignment.
// The instances are used to generate testcases.
type InclusionTestcase struct {
	// Name is an identifier for the testcase
	Name string
	// TableFilter lists the table filters for each segments
	TableFilter []smartvectors.SmartVector
	// Table lists the tables by fragment, then by column
	Table [][]smartvectors.SmartVector
	// SFilters lists the filter columns for each segment subjected to the
	// lookup relationship.
	SFilters []smartvectors.SmartVector
	// S lists the segments by fragment, then by column
	S [][]smartvectors.SmartVector
	// Q is the lookup query that was generated. It should not be provided by
	// the caller but rather generated by the [GetDefineFunc] call.
	Q query.Inclusion
	// MustFail tells if the provided testcase should panic or not.
	MustFailFlag bool
}

// ListOfInclusionTestcasesPositive lists standard inclusion testcases
// that are supposed to pass.
var ListOfInclusionTestcasesPositive = []InclusionTestcase{
	{
		Name: "positive/small-range/no-filter/single-column",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				RandomSmallNumbers(16, 8),
			},
		},
	},
	{
		Name: "positive/small-range/no-filter/multi-t",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
			},
			{
				Counting(16),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				RandomSmallNumbers(16, 16),
			},
		},
	},
	{
		Name: "positive/small-range/no-filter/multi-t-with-filter",
		TableFilter: []smartvectors.SmartVector{
			smartvectors.NewConstant(field.Zero(), 8),
			nil,
		},
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
			},
			{
				Counting(16),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				Counting(16),
			},
		},
	},
	{
		Name: "positive/rand-values/filter-is-zero",
		Table: [][]smartvectors.SmartVector{
			RandomMatrix(16, 3),
		},
		S: [][]smartvectors.SmartVector{
			RandomMatrix(16, 3),
		},
		SFilters: []smartvectors.SmartVector{
			smartvectors.NewConstant(field.Zero(), 16),
		},
	},
	{
		Name: "positive/xor-values",
		Table: [][]smartvectors.SmartVector{
			XorTable(2),
		},
		S: [][]smartvectors.SmartVector{
			{
				smartvectors.ForTest(0b00, 0b10, 0b11, 0b01),
				smartvectors.ForTest(0b00, 0b10, 0b11, 0b01),
				smartvectors.ForTest(0b00, 0b00, 0b00, 0b00),
			},
			{
				smartvectors.ForTest(0b00, 0b10, 0b11, 0b01),
				smartvectors.ForTest(0b10, 0b11, 0b01, 0b00),
				smartvectors.ForTest(0b10, 0b01, 0b10, 0b01),
			},
		},
	},
}

var ListOfInclusionTestcasesNegative = []InclusionTestcase{
	{
		Name: "negative/t-filter-is-zero",
		TableFilter: []smartvectors.SmartVector{
			smartvectors.NewConstant(field.Zero(), 8),
			smartvectors.NewConstant(field.Zero(), 16),
		},
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
			},
			{
				Counting(16),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				Counting(16),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/full-random-multicolumn",
		Table: [][]smartvectors.SmartVector{
			RandomMatrix(16, 3),
		},
		S: [][]smartvectors.SmartVector{
			RandomMatrix(16, 3),
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/full-random-single-column",
		Table: [][]smartvectors.SmartVector{
			{
				RandomVec(16),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				RandomVec(16),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/one-value-does-not-match",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				smartvectors.ForTest(0, 9, 2, 3, 4, 5, 1, 2),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/one-value-does-not-match-2-cols",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				smartvectors.ForTest(0, 1, 2, 3, 4, 5, 1, 2),
				smartvectors.ForTest(0, 2, 2, 3, 4, 5, 1, 2),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/one-value-does-not-match-2-cols-swapped",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				smartvectors.ForTest(0, 2, 2, 3, 4, 5, 1, 2),
				smartvectors.ForTest(0, 1, 2, 3, 4, 5, 1, 2),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/one-value-does-not-match-2-fragments",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				smartvectors.ForTest(0, 2, 2, 3, 4, 5, 1, 2),
				smartvectors.ForTest(0, 1, 2, 3, 4, 5, 1, 2),
			},
			{
				Counting(4),
				Counting(4),
			},
		},
		MustFailFlag: true,
	},
	{
		Name: "negative/one-value-does-not-match-2-fragments-swapped",
		Table: [][]smartvectors.SmartVector{
			{
				Counting(8),
				Counting(8),
			},
		},
		S: [][]smartvectors.SmartVector{
			{
				Counting(4),
				Counting(4),
			},
			{
				smartvectors.ForTest(0, 2, 2, 3, 4, 5, 1, 2),
				smartvectors.ForTest(0, 1, 2, 3, 4, 5, 1, 2),
			},
		},
		MustFailFlag: true,
	},
}

// Define declares all the columns and queries involved in the testcase.
func (t *InclusionTestcase) Define(comp *wizard.CompiledIOP) {

	var (
		tableFilter = make([]ifaces.Column, len(t.TableFilter))
		table       = make([][]ifaces.Column, len(t.Table))
		sFilter     = make([]ifaces.Column, len(t.SFilters))
		s           = make([][]ifaces.Column, len(t.S))
	)

	for i := range table {

		tableFilter[i] = comp.InsertCommit(
			0,
			formatName[ifaces.ColID]("Inclusion", t.Name, "TableFilter", i),
			t.TableFilter[i].Len(),
		)

		table[i] = make([]ifaces.Column, len(t.Table[i]))
		for j := range table[i] {
			table[i][j] = comp.InsertCommit(
				0,
				formatName[ifaces.ColID]("Inclusion", t.Name, "Table", i, j),
				t.Table[i][j].Len(),
			)
		}
	}

	for i := range s {

		sFilter[i] = comp.InsertCommit(
			0,
			formatName[ifaces.ColID]("Inclusion", t.Name, "SFilters", i),
			t.SFilters[i].Len(),
		)

		s[i] = make([]ifaces.Column, len(t.S[i]))
		for j := range s[i] {
			s[i][j] = comp.InsertCommit(
				0,
				formatName[ifaces.ColID]("Inclusion", t.Name, "S", i, j),
				t.S[i][j].Len(),
			)
		}
	}

	for i := range s {
		qName := ifaces.QueryID("Inclusion_" + t.Name + "_" + strconv.Itoa(i))
		t.Q = query.NewInclusion(
			qName,
			s[i],
			table,
			sFilter[i],
			tableFilter,
		)
		comp.QueriesNoParams.AddToRound(0, qName, t.Q)
	}
}

// Assign assigns the testcase to the compiled IOP
func (t *InclusionTestcase) Assign(run *wizard.ProverRuntime) {

	for i := range t.Table {

		run.AssignColumn(
			formatName[ifaces.ColID]("Inclusion", t.Name, "TableFilter", i),
			t.TableFilter[i],
		)

		for j := range t.Table[i] {
			run.AssignColumn(
				formatName[ifaces.ColID]("Inclusion", t.Name, "Table", i, j),
				t.Table[i][j],
			)
		}
	}

	for i := range t.S {

		run.AssignColumn(
			formatName[ifaces.ColID]("Inclusion", t.Name, "SFilters", i),
			t.SFilters[i],
		)

		for j := range t.S[i] {
			run.AssignColumn(
				formatName[ifaces.ColID]("Inclusion", t.Name, "S", i, j),
				t.S[i][j],
			)
		}
	}
}

func (t *InclusionTestcase) MustFail() bool {
	return t.MustFailFlag
}
