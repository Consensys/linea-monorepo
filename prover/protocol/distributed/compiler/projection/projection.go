package dist_projection

import (
	"github.com/consensys/linea-monorepo/prover/maths/common/poly"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/coin"
	"github.com/consensys/linea-monorepo/prover/protocol/column"
	"github.com/consensys/linea-monorepo/prover/protocol/distributed"
	"github.com/consensys/linea-monorepo/prover/protocol/distributed/namebaseddiscoverer"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/protocol/wizardutils"
	"github.com/consensys/linea-monorepo/prover/symbolic"
)

// Used for deriving names of queries and coins
const (
	distProjectionStr        = "DISTRIBUTED_PROJECTION"
	MaxNumOfQueriesPerModule = 10
)

type DistributeProjectionCtx struct {
	DistProjectionInput []*query.DistributedProjectionInput
	EvalCoins           []coin.Info
	// The module name for which we are processing the distributed projection query
	TargetModuleName string
	// Query stores the [query.DistributedProjection] generated by the compilation
	Query query.DistributedProjection
	// LastRoundPerm indicates the highest round at which a compiled projection
	// occurs.
	LastRoundProjection int
}

func NewDistributeProjectionCtx(
	targetModuleName namebaseddiscoverer.ModuleName,
	initialComp, moduleComp *wizard.CompiledIOP,
	disc distributed.ModuleDiscoverer,
) *DistributeProjectionCtx {
	var (
		p = &DistributeProjectionCtx{
			DistProjectionInput: make([]*query.DistributedProjectionInput, 0, MaxNumOfQueriesPerModule),
			EvalCoins:           make([]coin.Info, 0, MaxNumOfQueriesPerModule),
			TargetModuleName:    targetModuleName,
			LastRoundProjection: getLastRoundPerm(initialComp),
		}
		numRounds = initialComp.NumRounds()
		qId       = p.QueryID()
	)
	if p.LastRoundProjection < 0 {
		return p
	}

	/*
	   Handles the projection checks
	*/
	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for queryInRound, qName := range queries {

			// Skip if it was already compiled
			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			q_, ok := initialComp.QueriesNoParams.Data(qName).(query.Projection)
			if !ok {
				continue
			}
			var (
				onlyA     = (disc.FindModule(q_.Inp.ColumnA[0]) == targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) != targetModuleName)
				onlyB     = (disc.FindModule(q_.Inp.ColumnA[0]) != targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) == targetModuleName)
				bothAAndB = (disc.FindModule(q_.Inp.ColumnA[0]) == targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) == targetModuleName)
			)
			if bothAAndB {
				p.push(moduleComp, q_, round, queryInRound, true, true)
				initialComp.QueriesNoParams.MarkAsIgnored(qName)
				// Todo: Add panic if other cols are from other modules
			} else if onlyA {
				p.push(moduleComp, q_, round, queryInRound, true, false)
				initialComp.QueriesNoParams.MarkAsIgnored(qName)
			} else if onlyB {
				p.push(moduleComp, q_, round, queryInRound, false, true)
				initialComp.QueriesNoParams.MarkAsIgnored(qName)
			} else {
				continue
			}
		}
	}
	// We register the grand product query in round one because
	// alphas, betas, and the query param are assigned in round one
	p.Query = moduleComp.InsertDistributedProjection(p.LastRoundProjection+1, qId, p.DistProjectionInput)

	moduleComp.RegisterProverAction(p.LastRoundProjection+1, p)
	return p

}

// push appends a new DistributedProjectionInput to the DistProjectionInput slice
func (p *DistributeProjectionCtx) push(comp *wizard.CompiledIOP, q query.Projection, round, queryInRound int, isA, isB bool) {
	var (
		isMultiColumn = len(q.Inp.ColumnA) > 1
		alphaName     = getCoinName("MERGING_COIN", round, queryInRound)
		betaName      = getCoinName("EVAL_COIN", round, queryInRound)
		alpha         coin.Info
		beta          coin.Info
	)
	// Register alpha and beta
	if isMultiColumn {
		if comp.Coins.Exists(alphaName) {
			alpha = comp.Coins.Data(alphaName)
		} else {
			alpha = comp.InsertCoin(p.LastRoundProjection+1, alphaName, coin.Field)
		}
	}

	if comp.Coins.Exists(betaName) {
		beta = comp.Coins.Data(betaName)
	} else {
		beta = comp.InsertCoin(p.LastRoundProjection+1, betaName, coin.Field)
	}
	p.EvalCoins = append(p.EvalCoins, beta)
	if isA && isB {
		fA, _, _ := wizardutils.AsExpr(q.Inp.FilterA)
		fB, _, _ := wizardutils.AsExpr(q.Inp.FilterB)
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     wizardutils.RandLinCombColSymbolic(alpha, q.Inp.ColumnA),
			ColumnB:     wizardutils.RandLinCombColSymbolic(alpha, q.Inp.ColumnB),
			FilterA:     fA,
			FilterB:     fB,
			SizeA:       q.Inp.FilterA.Size(),
			SizeB:       q.Inp.FilterB.Size(),
			EvalCoin:    beta.Name,
			IsAInModule: true,
			IsBInModule: true,
		})
	} else if isA {
		fA, _, _ := wizardutils.AsExpr(q.Inp.FilterA)
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     wizardutils.RandLinCombColSymbolic(alpha, q.Inp.ColumnA),
			ColumnB:     symbolic.NewConstant(1),
			FilterA:     fA,
			FilterB:     symbolic.NewConstant(1),
			SizeA:       q.Inp.FilterA.Size(),
			EvalCoin:    beta.Name,
			IsAInModule: true,
			IsBInModule: false,
		})
	} else if isB {
		fB, _, _ := wizardutils.AsExpr(q.Inp.FilterB)
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     symbolic.NewConstant(1),
			ColumnB:     wizardutils.RandLinCombColSymbolic(alpha, q.Inp.ColumnB),
			FilterA:     symbolic.NewConstant(1),
			FilterB:     fB,
			SizeB:       q.Inp.FilterB.Size(),
			EvalCoin:    beta.Name,
			IsAInModule: false,
			IsBInModule: true,
		})
	} else {
		panic("Invalid distributed projection query while initial pushing")
	}
}

func (p *DistributeProjectionCtx) computeQueryParam(run *wizard.ProverRuntime) field.Element {
	var (
		queryParam = field.Zero()
		elemParam  = field.Zero()
	)
	for elemIndex, inp := range p.DistProjectionInput {
		if inp.IsAInModule && inp.IsBInModule {
			var (
				colABoard    = inp.ColumnA.Board()
				colBBoard    = inp.ColumnB.Board()
				filterABorad = inp.FilterA.Board()
				filterBBoard = inp.FilterB.Board()
				colA         = column.EvalExprColumn(run, colABoard).IntoRegVecSaveAlloc()
				colB         = column.EvalExprColumn(run, colBBoard).IntoRegVecSaveAlloc()
				filterA      = column.EvalExprColumn(run, filterABorad).IntoRegVecSaveAlloc()
				filterB      = column.EvalExprColumn(run, filterBBoard).IntoRegVecSaveAlloc()
			)
			hornerA := poly.CmptHorner(colA, filterA, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			hornerB := poly.CmptHorner(colB, filterB, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			elemParam = hornerB[0]
			elemParam.Neg(&elemParam)
			elemParam.Add(&elemParam, &hornerA[0])
		} else if inp.IsAInModule && !inp.IsBInModule {
			var (
				colABoard    = inp.ColumnA.Board()
				filterABorad = inp.FilterA.Board()
				colA         = column.EvalExprColumn(run, colABoard).IntoRegVecSaveAlloc()
				filterA      = column.EvalExprColumn(run, filterABorad).IntoRegVecSaveAlloc()
			)
			hornerA := poly.CmptHorner(colA, filterA, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			elemParam = hornerA[0]
		} else if !inp.IsAInModule && inp.IsBInModule {
			var (
				colBBoard    = inp.ColumnB.Board()
				filterBBorad = inp.FilterB.Board()
				colB         = column.EvalExprColumn(run, colBBoard).IntoRegVecSaveAlloc()
				filterB      = column.EvalExprColumn(run, filterBBorad).IntoRegVecSaveAlloc()
			)
			hornerB := poly.CmptHorner(colB, filterB, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			elemParam = hornerB[0]
			elemParam.Neg(&elemParam)
		} else {
			panic("Invalid distributed projection query encountered during param evaluation")
		}
		queryParam.Add(&queryParam, &elemParam)
	}
	return queryParam
}

func (p *DistributeProjectionCtx) Run(run *wizard.ProverRuntime) {
	run.AssignDistributedProjection(p.Query.ID, query.DistributedProjectionParams{
		HornerVal: p.computeQueryParam(run),
	})
}

// deriveName constructs a name for the DistributeProjectionCtx context
func deriveName[R ~string](q ifaces.QueryID, ss ...any) R {
	ss = append([]any{distProjectionStr, q}, ss...)
	return wizardutils.DeriveName[R](ss...)
}

// QueryID formats and returns a name of the [query.DistributedProjection] generated by the current context
func (p *DistributeProjectionCtx) QueryID() ifaces.QueryID {
	return deriveName[ifaces.QueryID](ifaces.QueryID(p.TargetModuleName))
}

func getCoinName(name string, round, queryInRound int) coin.Name {
	return deriveName[coin.Name](distProjectionStr, name, round, queryInRound)
}

// getLastRoundPerm scans the initialComp and looks for uncompiled projection queries. It returns
// the highest round found for a matched projection query. It returns -1 if no queries are found.
func getLastRoundPerm(initialComp *wizard.CompiledIOP) int {

	var (
		lastRound = -1
		numRounds = initialComp.NumRounds()
	)

	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for _, qName := range queries {

			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			_, ok := initialComp.QueriesNoParams.Data(qName).(query.Projection)
			if !ok {
				continue
			}

			lastRound = max(lastRound, round)
		}
	}

	return lastRound
}
