package dist_projection

import (
	"math/big"

	"github.com/consensys/linea-monorepo/prover/crypto/mimc"
	"github.com/consensys/linea-monorepo/prover/maths/common/poly"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/accessors"
	"github.com/consensys/linea-monorepo/prover/protocol/coin"
	"github.com/consensys/linea-monorepo/prover/protocol/column"
	"github.com/consensys/linea-monorepo/prover/protocol/distributed"
	"github.com/consensys/linea-monorepo/prover/protocol/distributed/constants"
	discoverer "github.com/consensys/linea-monorepo/prover/protocol/distributed/namebaseddiscoverer"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/protocol/wizardutils"
	"github.com/consensys/linea-monorepo/prover/symbolic"
	"github.com/consensys/linea-monorepo/prover/utils"
)

// Used for deriving names of queries and coins
const (
	distProjectionStr        = "DISTRIBUTED_PROJECTION"
	MaxNumOfQueriesPerModule = 10
)

type DistributeProjectionCtx struct {
	// List of all projection queries alloted to the segments
	DistProjectionInput []*query.DistributedProjectionInput
	// List of Evaluation Coins per query
	EvalCoins []coin.Info
	// The module name for which we are processing the distributed projection query
	TargetModuleName string
	// Query stores the [query.DistributedProjection] generated by the compilation
	Query query.DistributedProjection
	// LastRoundPerm indicates the highest round at which a compiled projection
	// occurs.
	LastRoundProjection int
	// number of segments per module
	NumSegmentsPerModule int
	// original projection queries to extract filters
	QIds []query.Projection
}

// NewDistributeProjectionCtx processes all the projection queries from the initialComp
// and registers DistributedProjection queries to the target module using the module
// discoverer
func NewDistributeProjectionCtx(
	targetModuleName discoverer.ModuleName,
	initialComp, moduleComp *wizard.CompiledIOP,
	disc distributed.ModuleDiscoverer,
	numSegmentPerModule int,
) *DistributeProjectionCtx {
	var (
		p = &DistributeProjectionCtx{
			DistProjectionInput:  make([]*query.DistributedProjectionInput, 0, MaxNumOfQueriesPerModule),
			EvalCoins:            make([]coin.Info, 0, MaxNumOfQueriesPerModule),
			TargetModuleName:     targetModuleName,
			LastRoundProjection:  getLastRoundProjection(initialComp),
			NumSegmentsPerModule: numSegmentPerModule,
			QIds:                 make([]query.Projection, 0, MaxNumOfQueriesPerModule),
		}
		numRounds = initialComp.NumRounds()
		qId       = p.QueryID()
	)
	if p.LastRoundProjection < 0 {
		return p
	}

	/*
	   Handles the projection checks
	*/
	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for queryInRound, qName := range queries {

			// Skip if it was already compiled
			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			q_, ok := initialComp.QueriesNoParams.Data(qName).(query.Projection)
			if !ok {
				continue
			}
			var (
				onlyA     = (disc.FindModule(q_.Inp.ColumnA[0]) == targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) != targetModuleName)
				onlyB     = (disc.FindModule(q_.Inp.ColumnA[0]) != targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) == targetModuleName)
				bothAAndB = (disc.FindModule(q_.Inp.ColumnA[0]) == targetModuleName) && (disc.FindModule(q_.Inp.ColumnB[0]) == targetModuleName)
			)
			if bothAAndB {
				check(q_.Inp.ColumnA, disc, targetModuleName)
				check(q_.Inp.ColumnB, disc, targetModuleName)
				p.push(moduleComp, q_, round, queryInRound, true, true)
			} else if onlyA {
				check(q_.Inp.ColumnA, disc, targetModuleName)
				p.push(moduleComp, q_, round, queryInRound, true, false)
			} else if onlyB {
				check(q_.Inp.ColumnB, disc, targetModuleName)
				p.push(moduleComp, q_, round, queryInRound, false, true)
			} else {
				continue
			}
		}
	}
	// We register the grand product query in round one because
	// alphas, betas, and the query param are assigned in round one
	p.Query = moduleComp.InsertDistributedProjection(p.LastRoundProjection+1, qId, p.DistProjectionInput)

	moduleComp.RegisterProverAction(p.LastRoundProjection+1, p)

	// declare [query.LogDerivSumParams] as [wizard.PublicInput]
	moduleComp.PublicInputs = append(moduleComp.PublicInputs,
		wizard.PublicInput{
			Name: constants.DistributedProjectionPublicInput,
			Acc:  accessors.NewDistributedProjectionAccessor(p.Query),
		})
	return p

}

// Check verifies if all columns of the projection query belongs to the same module or not
func check(cols []ifaces.Column,
	disc distributed.ModuleDiscoverer,
	targetModuleName discoverer.ModuleName,
) error {
	for _, col := range cols {
		if disc.FindModule(col) != targetModuleName {
			utils.Panic("unsupported projection query, colName: %v, target: %v", col.GetColID(), targetModuleName)
		}
	}
	return nil
}

// push appends a new DistributedProjectionInput to the DistProjectionInput slice
func (p *DistributeProjectionCtx) push(comp *wizard.CompiledIOP, q query.Projection, round, queryInRound int, isA, isB bool) {
	var (
		isMultiColumn = len(q.Inp.ColumnA) > 1
		alphaName_    = p.getCoinName("MERGING_COIN", round, queryInRound)
		alphaName     = coin.Namef("%v_%v", alphaName_, "FieldFromSeed")
		betaName_     = p.getCoinName("EVAL_COIN", round, queryInRound)
		betaName      = coin.Namef("%v_%v", betaName_, "FieldFromSeed")
		alpha         coin.Info
		beta          coin.Info
	)
	// Register alpha and beta
	if isMultiColumn {
		if comp.Coins.Exists(alphaName) {
			alpha = comp.Coins.Data(alphaName)
		} else {
			alpha = comp.InsertCoin(p.LastRoundProjection+1, alphaName, coin.FieldFromSeed)
		}
	}
	if comp.Coins.Exists(betaName) {
		beta = comp.Coins.Data(betaName)
	} else {
		beta = comp.InsertCoin(p.LastRoundProjection+1, betaName, coin.FieldFromSeed)
	}
	p.EvalCoins = append(p.EvalCoins, beta)
	p.QIds = append(p.QIds, q)
	// Push the DistributedProjectionInput
	if isA && isB {
		fA, _, _ := wizardutils.AsExpr(comp.Columns.GetHandle(q.Inp.FilterA.GetColID()))
		fB, _, _ := wizardutils.AsExpr(comp.Columns.GetHandle(q.Inp.FilterB.GetColID()))
		var (
			colA = make([]ifaces.Column, 0, len(q.Inp.ColumnA))
			colB = make([]ifaces.Column, 0, len(q.Inp.ColumnB))
		)
		for i := 0; i < len(q.Inp.ColumnA); i++ {
			colA = append(colA, comp.Columns.GetHandle(q.Inp.ColumnA[i].GetColID()))
		}
		for i := 0; i < len(q.Inp.ColumnB); i++ {
			colB = append(colB, comp.Columns.GetHandle(q.Inp.ColumnB[i].GetColID()))
		}
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     wizardutils.RandLinCombColSymbolic(alpha, colA),
			ColumnB:     wizardutils.RandLinCombColSymbolic(alpha, colB),
			FilterA:     fA,
			FilterB:     fB,
			SizeA:       comp.Columns.GetSize(q.Inp.FilterA.GetColID()),
			SizeB:       comp.Columns.GetSize(q.Inp.FilterB.GetColID()),
			EvalCoin:    beta.Name,
			IsAInModule: true,
			IsBInModule: true,
		})
	} else if isA {
		fA, _, _ := wizardutils.AsExpr(comp.Columns.GetHandle(q.Inp.FilterA.GetColID()))
		var (
			colA = make([]ifaces.Column, 0, len(q.Inp.ColumnA))
		)
		for i := 0; i < len(q.Inp.ColumnA); i++ {
			colA = append(colA, comp.Columns.GetHandle(q.Inp.ColumnA[i].GetColID()))
		}
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     wizardutils.RandLinCombColSymbolic(alpha, colA),
			ColumnB:     symbolic.NewConstant(1),
			FilterA:     fA,
			FilterB:     symbolic.NewConstant(1),
			SizeA:       comp.Columns.GetSize(q.Inp.FilterA.GetColID()),
			EvalCoin:    beta.Name,
			IsAInModule: true,
			IsBInModule: false,
		})
	} else if isB {
		fB, _, _ := wizardutils.AsExpr(comp.Columns.GetHandle(q.Inp.FilterB.GetColID()))
		var (
			colB = make([]ifaces.Column, 0, len(q.Inp.ColumnB))
		)
		for i := 0; i < len(q.Inp.ColumnB); i++ {
			colB = append(colB, comp.Columns.GetHandle(q.Inp.ColumnB[i].GetColID()))
		}
		p.DistProjectionInput = append(p.DistProjectionInput, &query.DistributedProjectionInput{
			ColumnA:     symbolic.NewConstant(1),
			ColumnB:     wizardutils.RandLinCombColSymbolic(alpha, colB),
			FilterA:     symbolic.NewConstant(1),
			FilterB:     fB,
			SizeB:       comp.Columns.GetSize(q.Inp.FilterB.GetColID()),
			EvalCoin:    beta.Name,
			IsAInModule: false,
			IsBInModule: true,
		})
	} else {
		panic("Invalid distributed projection query while initial pushing")
	}
}

// Run implements [wizard.ProverAction] interface
func (p *DistributeProjectionCtx) Run(run *wizard.ProverRuntime) {
	p.assignSumNumOnes(run)
	run.AssignDistributedProjection(p.Query.ID, query.DistributedProjectionParams{
		ScaledHorner:      p.computeScaledHorner(run),
		HashCumSumOnePrev: p.computeHashPrev(),
		HashCumSumOneCurr: p.computeHashCurr(),
	})
}

// assignSumNumOnes assigns the cumulative number of ones in the previous segments as well as the current segment
func (p *DistributeProjectionCtx) assignSumNumOnes(run *wizard.ProverRuntime) {
	var (
		initialRuntime = run.ParentRuntime
		segId          = run.ProverID
		one            = field.One()
		bigOne         = big.NewInt(1)
	)
	for elemIndex, inp := range p.DistProjectionInput {
		if inp.IsAInModule && inp.IsBInModule {
			var (
				fA              = initialRuntime.GetColumn(p.QIds[elemIndex].Inp.FilterA.GetColID())
				fB              = initialRuntime.GetColumn(p.QIds[elemIndex].Inp.FilterB.GetColID())
				segSizeA        = utils.NextPowerOfTwo(fA.Len() / p.NumSegmentsPerModule)
				segSizeB        = utils.NextPowerOfTwo(fB.Len() / p.NumSegmentsPerModule)
				numOnesCurrA    = field.Zero()
				numOnesCurrB    = field.Zero()
				cumSumOnesPrevA = *big.NewInt(0)
				cumSumOnesPrevB = *big.NewInt(0)
			)
			if segId == 0 {
				var (
					fACurr = fA.SubVector(segId*segSizeA, (segId+1)*segSizeA).IntoRegVecSaveAlloc()
					fBCurr = fB.SubVector(segId*segSizeB, (segId+1)*segSizeB).IntoRegVecSaveAlloc()
				)
				for i := 0; i < len(fACurr); i++ {
					if fACurr[i] == one {
						numOnesCurrA.Add(&numOnesCurrA, &one)
					}
				}
				for i := 0; i < len(fBCurr); i++ {
					if fBCurr[i] == one {
						numOnesCurrB.Add(&numOnesCurrB, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsA = cumSumOnesPrevA
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsB = cumSumOnesPrevB
				p.DistProjectionInput[elemIndex].CurrNumOnesA = numOnesCurrA
				p.DistProjectionInput[elemIndex].CurrNumOnesB = numOnesCurrB
			} else {
				var (
					fAPrev = fA.SubVector(0, segId*segSizeA).IntoRegVecSaveAlloc()
					fBPrev = fB.SubVector(0, segId*segSizeB).IntoRegVecSaveAlloc()
					fACurr = fA.SubVector(segId*segSizeA, (segId+1)*segSizeA).IntoRegVecSaveAlloc()
					fBCurr = fB.SubVector(segId*segSizeB, (segId+1)*segSizeB).IntoRegVecSaveAlloc()
				)
				for i := 0; i < len(fAPrev); i++ {
					if fAPrev[i] == one {
						cumSumOnesPrevA.Add(&cumSumOnesPrevA, bigOne)
					}
				}
				for i := 0; i < len(fBPrev); i++ {
					if fBPrev[i] == one {
						cumSumOnesPrevB.Add(&cumSumOnesPrevB, bigOne)
					}
				}
				for i := 0; i < len(fACurr); i++ {
					if fACurr[i] == one {
						numOnesCurrA.Add(&numOnesCurrA, &one)
					}
				}
				for i := 0; i < len(fBCurr); i++ {
					if fBCurr[i] == one {
						numOnesCurrB.Add(&numOnesCurrB, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsA = cumSumOnesPrevA
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsB = cumSumOnesPrevB
				p.DistProjectionInput[elemIndex].CurrNumOnesA = numOnesCurrA
				p.DistProjectionInput[elemIndex].CurrNumOnesB = numOnesCurrB
			}
		}
		if inp.IsAInModule && !inp.IsBInModule {
			var (
				fA              = initialRuntime.GetColumn(p.QIds[elemIndex].Inp.FilterA.GetColID())
				segSizeA        = utils.NextPowerOfTwo(fA.Len() / p.NumSegmentsPerModule)
				numOnesCurrA    = field.Zero()
				cumSumOnesPrevA = *big.NewInt(0)
			)
			if segId == 0 {
				var (
					fACurr = fA.SubVector(segId*segSizeA, (segId+1)*segSizeA).IntoRegVecSaveAlloc()
				)

				for i := 0; i < len(fACurr); i++ {
					if fACurr[i] == one {
						numOnesCurrA.Add(&numOnesCurrA, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsA = cumSumOnesPrevA
				p.DistProjectionInput[elemIndex].CurrNumOnesA = numOnesCurrA
			} else {
				var (
					fAPrev = fA.SubVector(0, segId*segSizeA).IntoRegVecSaveAlloc()
					fACurr = fA.SubVector(segId*segSizeA, (segId+1)*segSizeA).IntoRegVecSaveAlloc()
				)
				for i := 0; i < len(fAPrev); i++ {
					if fAPrev[i] == one {
						cumSumOnesPrevA.Add(&cumSumOnesPrevA, bigOne)
					}
				}
				for i := 0; i < len(fACurr); i++ {
					if fACurr[i] == one {
						numOnesCurrA.Add(&numOnesCurrA, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsA = cumSumOnesPrevA
				p.DistProjectionInput[elemIndex].CurrNumOnesA = numOnesCurrA
			}
		}
		if !inp.IsAInModule && inp.IsBInModule {
			var (
				fB              = initialRuntime.GetColumn(p.QIds[elemIndex].Inp.FilterB.GetColID())
				segSizeB        = utils.NextPowerOfTwo(fB.Len() / p.NumSegmentsPerModule)
				numOnesCurrB    field.Element
				cumSumOnesPrevB = *big.NewInt(0)
			)
			if segId == 0 {
				var (
					fBCurr = fB.SubVector(segId*segSizeB, (segId+1)*segSizeB).IntoRegVecSaveAlloc()
				)

				for i := 0; i < len(fBCurr); i++ {
					if fBCurr[i] == one {
						numOnesCurrB.Add(&numOnesCurrB, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsB = cumSumOnesPrevB
				p.DistProjectionInput[elemIndex].CurrNumOnesB = numOnesCurrB
			} else {
				var (
					fBPrev = fB.SubVector(0, segId*segSizeB).IntoRegVecSaveAlloc()
					fBCurr = fB.SubVector(segId*segSizeB, (segId+1)*segSizeB).IntoRegVecSaveAlloc()
				)
				for i := 0; i < len(fBPrev); i++ {
					if fBPrev[i] == one {
						cumSumOnesPrevB.Add(&cumSumOnesPrevB, bigOne)
					}
				}
				for i := 0; i < len(fBCurr); i++ {
					if fBCurr[i] == one {
						numOnesCurrB.Add(&numOnesCurrB, &one)
					}
				}
				p.DistProjectionInput[elemIndex].CumulativeNumOnesPrevSegmentsB = cumSumOnesPrevB
				p.DistProjectionInput[elemIndex].CurrNumOnesB = numOnesCurrB
			}
		}
	}
}

// computeScaledHorner computes the parameter of the DistributedProjection query
func (p *DistributeProjectionCtx) computeScaledHorner(run *wizard.ProverRuntime) field.Element {
	var (
		queryParam = field.Zero()
	)
	for elemIndex, inp := range p.DistProjectionInput {
		var (
			elemParam = field.Zero()
		)
		if inp.IsAInModule && inp.IsBInModule {
			var (
				colABoard                      = inp.ColumnA.Board()
				colBBoard                      = inp.ColumnB.Board()
				filterABorad                   = inp.FilterA.Board()
				filterBBoard                   = inp.FilterB.Board()
				colA                           = column.EvalExprColumn(run, colABoard).IntoRegVecSaveAlloc()
				colB                           = column.EvalExprColumn(run, colBBoard).IntoRegVecSaveAlloc()
				filterA                        = column.EvalExprColumn(run, filterABorad).IntoRegVecSaveAlloc()
				filterB                        = column.EvalExprColumn(run, filterBBoard).IntoRegVecSaveAlloc()
				multA, multB, hornerA, hornerB field.Element
			)
			// Add hornerA after scaling
			hornerATrace := poly.GetHornerTrace(colA, filterA, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			multA = run.GetRandomCoinField(p.EvalCoins[elemIndex].Name)
			multA.Exp(multA, &inp.CumulativeNumOnesPrevSegmentsA)
			hornerA = hornerATrace[0]
			hornerA.Mul(&hornerA, &multA)
			elemParam.Add(&elemParam, &hornerA)
			// Subtract hornerB after scaling
			hornerBTrace := poly.GetHornerTrace(colB, filterB, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			hornerB = hornerBTrace[0]
			multB = run.GetRandomCoinField(p.EvalCoins[elemIndex].Name)
			multB.Exp(multB, &inp.CumulativeNumOnesPrevSegmentsB)
			hornerB.Mul(&hornerB, &multB)
			elemParam.Sub(&elemParam, &hornerB)
		} else if inp.IsAInModule && !inp.IsBInModule {
			var (
				colABoard      = inp.ColumnA.Board()
				filterABorad   = inp.FilterA.Board()
				colA           = column.EvalExprColumn(run, colABoard).IntoRegVecSaveAlloc()
				filterA        = column.EvalExprColumn(run, filterABorad).IntoRegVecSaveAlloc()
				multA, hornerA field.Element
			)
			// Add hornerA after scaling
			hornerATrace := poly.GetHornerTrace(colA, filterA, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			multA = run.GetRandomCoinField(p.EvalCoins[elemIndex].Name)
			multA.Exp(multA, &inp.CumulativeNumOnesPrevSegmentsA)
			hornerA = hornerATrace[0]
			hornerA.Mul(&hornerA, &multA)
			elemParam.Add(&elemParam, &hornerA)
		} else if !inp.IsAInModule && inp.IsBInModule {
			var (
				colBBoard      = inp.ColumnB.Board()
				filterBBorad   = inp.FilterB.Board()
				colB           = column.EvalExprColumn(run, colBBoard).IntoRegVecSaveAlloc()
				filterB        = column.EvalExprColumn(run, filterBBorad).IntoRegVecSaveAlloc()
				multB, hornerB field.Element
			)
			// Subtract hornerB after scaling
			hornerBTrace := poly.GetHornerTrace(colB, filterB, run.GetRandomCoinField(p.EvalCoins[elemIndex].Name))
			hornerB = hornerBTrace[0]
			multB = run.GetRandomCoinField(p.EvalCoins[elemIndex].Name)
			multB.Exp(multB, &inp.CumulativeNumOnesPrevSegmentsB)
			hornerB.Mul(&hornerB, &multB)
			elemParam.Sub(&elemParam, &hornerB)
		} else {
			panic("Invalid distributed projection query encountered during param evaluation")
		}
		queryParam.Add(&queryParam, &elemParam)
	}
	return queryParam
}

// computeHashPrev computes the hash of the cumulative number of ones in the previous segments
func (p *DistributeProjectionCtx) computeHashPrev() field.Element {
	var (
		oldState = field.Zero()
	)
	for _, inp := range p.DistProjectionInput {
		if inp.IsAInModule && inp.IsBInModule {
			sumA := field.NewElement(inp.CumulativeNumOnesPrevSegmentsA.Uint64())
			oldState = mimc.BlockCompression(oldState, sumA)
			sumB := field.NewElement(inp.CumulativeNumOnesPrevSegmentsB.Uint64())
			oldState = mimc.BlockCompression(oldState, sumB)
		} else if inp.IsAInModule && !inp.IsBInModule {
			sumA := field.NewElement(inp.CumulativeNumOnesPrevSegmentsA.Uint64())
			oldState = mimc.BlockCompression(oldState, sumA)
		} else if !inp.IsAInModule && inp.IsBInModule {
			sumB := field.NewElement(inp.CumulativeNumOnesPrevSegmentsB.Uint64())
			oldState = mimc.BlockCompression(oldState, sumB)
		} else {
			panic("Invalid distributed projection query encountered during previous hash computation")
		}
	}
	return oldState
}

// computeHashCurr computes the hash of the cumulative number of ones in the current segment
func (p *DistributeProjectionCtx) computeHashCurr() field.Element {
	var (
		oldState = field.Zero()
	)
	for _, inp := range p.DistProjectionInput {
		if inp.IsAInModule && inp.IsBInModule {
			sumA := field.NewElement(inp.CumulativeNumOnesPrevSegmentsA.Uint64())
			sumA.Add(&sumA, &inp.CurrNumOnesA)
			oldState = mimc.BlockCompression(oldState, sumA)
			sumB := field.NewElement(inp.CumulativeNumOnesPrevSegmentsB.Uint64())
			sumB.Add(&sumB, &inp.CurrNumOnesB)
			oldState = mimc.BlockCompression(oldState, sumB)
		} else if inp.IsAInModule && !inp.IsBInModule {
			sumA := field.NewElement(inp.CumulativeNumOnesPrevSegmentsA.Uint64())
			sumA.Add(&sumA, &inp.CurrNumOnesA)
			oldState = mimc.BlockCompression(oldState, sumA)
		} else if !inp.IsAInModule && inp.IsBInModule {
			sumB := field.NewElement(inp.CumulativeNumOnesPrevSegmentsB.Uint64())
			sumB.Add(&sumB, &inp.CurrNumOnesB)
			oldState = mimc.BlockCompression(oldState, sumB)
		} else {
			panic("Invalid distributed projection query encountered during current hash computation")
		}
	}
	return oldState
}

// deriveName constructs a name for the DistributeProjectionCtx context
func deriveName[R ~string](q ifaces.QueryID, ss ...any) R {
	ss = append([]any{distProjectionStr, q}, ss...)
	return wizardutils.DeriveName[R](ss...)
}

// QueryID formats and returns a name of the [query.DistributedProjection] generated by the current context
func (p *DistributeProjectionCtx) QueryID() ifaces.QueryID {
	return deriveName[ifaces.QueryID](ifaces.QueryID(p.TargetModuleName))
}

func (p *DistributeProjectionCtx) getCoinName(name string, round, queryInRound int) coin.Name {
	return deriveName[coin.Name](p.QueryID(), name, round, queryInRound)
}

// getLastRoundProjection scans the initialComp and looks for uncompiled projection queries. It returns
// the highest round found for a matched projection query. It returns -1 if no queries are found.
func getLastRoundProjection(initialComp *wizard.CompiledIOP) int {

	var (
		lastRound = -1
		numRounds = initialComp.NumRounds()
	)

	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for _, qName := range queries {

			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			_, ok := initialComp.QueriesNoParams.Data(qName).(query.Projection)
			if !ok {
				continue
			}

			lastRound = max(lastRound, round)
		}
	}

	return lastRound
}
