package dist_permutation

import (
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/coin"
	"github.com/consensys/linea-monorepo/prover/protocol/column"
	"github.com/consensys/linea-monorepo/prover/protocol/distributed"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/query"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/protocol/wizardutils"
	"github.com/consensys/linea-monorepo/prover/symbolic"
)

// Used for deriving names of queries and coins
const grandProductStr = "GRAND_PRODUCT"

// PermutationIntoGrandProductCtx is a compilation context object storing artefacts
// specific to a target module when compiling the [query.Permutation] into a
// [query.GrandProduct]. We store the randomised symbolic products of A and B of
// permutation queries combinedly into the Numerators and the Denominators of the
// GrandProduct query.
type PermutationIntoGrandProductCtx struct {
	// GdProdInputs collect all the inputs of the permutation queries from the target
	// module that are used as input of the [GrandProduct] query. The term stored
	// are of the form $Ai + \beta_i$ or $Bi + \beta_i$.
	GdProdInputs map[int]*query.GrandProductInput
	// The module name for which we are processing the grand product query
	TargetModuleName string
	// Query stores the [query.GrandProduct] generated by the compilation
	Query query.GrandProduct
	// LastRoundPerm indicates the highest round at which a compiled permutation
	// occurs.
	LastRoundPerm int
}

// NewPermutationIntoGrandProductCtx processes all permutation queries specific to a
// target module into a grand product query. It stores the randomised symbolic products
// of A and B of permutation queries combinedly into the Numerators and the Denominators
// of the GrandProduct query.
//
// Parameters:
//   - s: The compilation settings
//   - initialComp: The initial compiledIOP
//   - moduleComp: The compiledIOP for the target module
//   - disc: The [distributed.ModuleDiscoverer] object used to detect the queries belonging
//     to the current module.
//
// Returns:
// - The function returns a [PermutationIntoGrandProductCtx] collecting all the compilation
// artefacts.
func NewPermutationIntoGrandProductCtx(
	s Settings,
	initialComp, moduleComp *wizard.CompiledIOP,
	disc distributed.ModuleDiscoverer,
) *PermutationIntoGrandProductCtx {

	var (
		p = &PermutationIntoGrandProductCtx{
			GdProdInputs:     make(map[int]*query.GrandProductInput),
			TargetModuleName: s.TargetModuleName,
			LastRoundPerm:    getLastRoundPerm(initialComp),
		}
		numRounds        = initialComp.NumRounds()
		qId              = p.QueryID()
		targetModuleName = p.TargetModuleName
	)

	if p.LastRoundPerm < 0 {
		return p
	}

	/*
	   Handles the lookups and permutations checks
	*/
	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for queryInRound, qName := range queries {
			// Skip if it was already compiled
			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			q_, ok := initialComp.QueriesNoParams.Data(qName).(query.Permutation)
			if !ok {
				continue
			}

			for k := range q_.A {
				if disc.FindModule(q_.A[k][0]) == targetModuleName {
					p.push(moduleComp, q_.A[k], round, queryInRound, true)
				}
			}

			for k := range q_.B {
				if disc.FindModule(q_.B[k][0]) == targetModuleName {
					p.push(moduleComp, q_.B[k], round, queryInRound, false)
				}
			}
		}
	}
	// We register the grand product query in round one because
	// alphas, betas, and the query param are assigned in round one
	p.Query = moduleComp.InsertGrandProduct(p.LastRoundPerm+1, qId, p.GdProdInputs)

	moduleComp.RegisterProverAction(p.LastRoundPerm+1, p)

	return p
}

// push processes a permutation query and adds its symbolic factors to the Numerators or Denominators
// based on the provided flags. It also inserts coins for alpha and beta for each permutation query.
//
// Parameters:
// - comp: The compiled IOP for the target module
// - aOrB: The side of permutation query to be processed
// - round: The round number of the permutation query
// - queryInRound: The index of the permutation query within the round
// - isNumerator: A flag indicating whether to add the symbolic factor to the Numerators
func (p *PermutationIntoGrandProductCtx) push(comp *wizard.CompiledIOP, aOrb []ifaces.Column, round, queryInRound int, isNumerator bool) {

	var (
		isMultiColumn = len(aOrb) > 1
		alphaName     = getCoinName("ALPHA", round, queryInRound)
		betaName      = getCoinName("BETA", round, queryInRound)
		alpha         coin.Info
		beta          coin.Info
	)

	if isMultiColumn {
		if comp.Coins.Exists(alphaName) {
			alpha = comp.Coins.Data(alphaName)
		} else {
			// alpha has to be different for different queries for a particular round for the soundness of z-packing
			alpha = comp.InsertCoin(p.LastRoundPerm+1, alphaName, coin.Field)
		}
	}

	// beta has to be different for different queries for a particular round for the soundness of z-packing
	if comp.Coins.Exists(betaName) {
		beta = comp.Coins.Data(betaName)
	} else {
		beta = comp.InsertCoin(p.LastRoundPerm+1, betaName, coin.Field)
	}

	var (
		factor = computeFactor(aOrb, alpha, beta)
		size   = aOrb[0].Size()
	)

	ce, ok := p.GdProdInputs[size]
	if !ok {
		ce = &query.GrandProductInput{
			Size: size,
		}

		p.GdProdInputs[size] = ce
	}

	if isNumerator {
		ce.Numerators = append(ce.Numerators, factor)
	} else {
		ce.Denominators = append(ce.Denominators, factor)
	}
}

// computeFactor computes the symbolic factor for a permutation query based on the given parameters.
// It iterates through the fragments of the query, computes the linear combination of columns with alpha
// (if multi-column) or directly uses the column as a variable, adds the beta value and returns the result.
//
// Parameters:
// - aOrB: A 2D slice of Column interfaces representing the fragments of the permutation query.
// - isMultiColumn: A boolean indicating whether the permutation query is multi-column.
// - alpha: A pointer to a CoinInfo struct representing the alpha coin for the permutation query.
// - beta: A pointer to a CoinInfo struct representing the beta coin for the permutation query.
//
// Returns:
// - A pointer to a symbolic.Expression representing the computed factor for the permutation query.
func computeFactor(aOrB []ifaces.Column, alpha, beta coin.Info) *symbolic.Expression {
	if len(aOrB) > 1 {
		return symbolic.Add(beta, wizardutils.RandLinCombColSymbolic(alpha, aOrB))
	}
	return symbolic.Add(beta, aOrB[0])
}

// computeQueryParam computes the query parameter for the grand product query.
// It multiplies the products of the Numerators and Denominators, evaluates the resulting symbolic expressions,
// Parameters:
// - run: The prover runtime.
// - name: The query ID specific to the target module.
//
// Returns:
// - A pointer to the PermutationIntoGrandProductCtx instance with the updated ParamY field.
func (p *PermutationIntoGrandProductCtx) computeQueryParam(run *wizard.ProverRuntime) field.Element {

	var y field.Element

	for _, ce := range p.GdProdInputs {

		var (
			numNumerators   = len(ce.Numerators)
			numDenominators = len(ce.Denominators)
			numProd         = symbolic.NewConstant(1)
			denProd         = symbolic.NewConstant(1)
		)

		// Multiply all Numerators
		for i := 0; i < numNumerators; i++ {
			numProd = symbolic.Mul(numProd, ce.Numerators[i])
		}
		// Multiply all Denominators
		for j := 0; j < numDenominators; j++ {
			denProd = symbolic.Mul(denProd, ce.Denominators[j])
		}

		// Evaluate the symbolic expressions for Numerator and Denominator products
		var (
			numProdFrVec = column.EvalExprColumn(run, numProd.Board()).IntoRegVecSaveAlloc()
			denProdFrVec = column.EvalExprColumn(run, denProd.Board()).IntoRegVecSaveAlloc()
			numProdFr    = numProdFrVec[0]
			denProdFr    = denProdFrVec[0]
		)

		// Multiply all field elements in the Numerator product vector
		if len(numProdFrVec) > 1 {
			for i := 1; i < len(numProdFrVec); i++ {
				numProdFr.Mul(&numProdFr, &numProdFrVec[i])
			}
		}
		// Multiply all field elements in the Denominator product vector
		if len(denProdFrVec) > 1 {
			for j := 1; j < len(denProdFrVec); j++ {
				denProdFr.Mul(&denProdFr, &denProdFrVec[j])
			}
		}

		// Invert the Denominator product field element
		denProdFr.Inverse(&denProdFr)

		// Compute the final query parameter Y
		numProdFr.Mul(&numProdFr, &denProdFr)
		y.Mul(&y, &numProdFr)
	}

	return y
}

// Run executes the grand product query by assigning the computed parameter Y to the prover runtime.
//
// Parameters:
// - run: The prover runtime where the grand product query will be executed.
//
// The function does not return any value. It directly assigns the computed parameter Y to the prover runtime
// using the AssignGrandProduct method of the runtime.
func (p *PermutationIntoGrandProductCtx) Run(run *wizard.ProverRuntime) {
	run.AssignGrandProduct(p.QueryID(), p.computeQueryParam(run))
}

// deriveName constructs a name for the PermutationIntoGrandProduct context
func deriveName[R ~string](q ifaces.QueryID, ss ...any) R {
	ss = append([]any{grandProductStr, q}, ss...)
	return wizardutils.DeriveName[R](ss...)
}

// QueryID formats and returns a name of the [query.GrandProduct] generated by the current context
func (p *PermutationIntoGrandProductCtx) QueryID() ifaces.QueryID {
	return deriveName[ifaces.QueryID](ifaces.QueryID(p.TargetModuleName))
}

// getCoinName returns a pre-formatted for the coins \alpha and \beta that are used
// to construct the GrandProduct operands. The function takes a string (expectedly either
// "ALPHA" or "BETA") and two integers identifying the query.
func getCoinName(name string, round, queryInRound int) coin.Name {
	return deriveName[coin.Name](grandProductStr, name, round, queryInRound)
}

// getLastRoundPerm scans the initialComp and looks for uncompiled permutation queries. It returns
// the highest round found for a matched permutation query. It returns -1 if no queries are found.
func getLastRoundPerm(initialComp *wizard.CompiledIOP) int {

	var (
		lastRound = -1
		numRounds = initialComp.NumRounds()
	)

	for round := 0; round < numRounds; round++ {
		queries := initialComp.QueriesNoParams.AllKeysAt(round)
		for _, qName := range queries {

			if initialComp.QueriesNoParams.IsIgnored(qName) {
				continue
			}

			_, ok := initialComp.QueriesNoParams.Data(qName).(query.Permutation)
			if !ok {
				continue
			}

			lastRound = max(lastRound, round)
		}
	}

	return lastRound
}
