/*
Descriptions:
context for Byte32cmp, checklimbs
verifiercol for fieldModulus
*/
package byte32cmp

import (
	"fmt"
	"math/big"

	"github.com/consensys/linea-monorepo/prover/maths/common/smartvectors"
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"github.com/consensys/linea-monorepo/prover/protocol/column/verifiercol"
	"github.com/consensys/linea-monorepo/prover/protocol/dedicated/bigrange"
	"github.com/consensys/linea-monorepo/prover/protocol/ifaces"
	"github.com/consensys/linea-monorepo/prover/protocol/wizard"
	"github.com/consensys/linea-monorepo/prover/symbolic"
	"github.com/consensys/linea-monorepo/prover/utils"
)

// byte32cmp context
type BytesCmpCtx struct {
	// The compiled IOP
	Comp *wizard.CompiledIOP
	// Number of limbs needed to represent a Byte32 value
	NumLimbs int
	// Number of bits per each limb
	BitPerLimbs int
	// Name if the Name of parent context joined with a specifier.
	Name string
	// Round of the module
	Round int
	// ColumnA, allegedly the column with larger values
	ColumnA ifaces.Column
	// ColumnB, allegedly the column with smaller values
	ColumnB ifaces.Column
	// Column containing the limbs of ColumnA
	ColumnAlimbs []ifaces.Column
	// Column containing the limbs of ColumnB
	ColumnBlimbs []ifaces.Column
	// Column containing the limbs of the field Modulus
	ModulusLimbs []ifaces.Column
	// Flags when comparing modulus with ColumnA
	GCmpModulusColA []ifaces.Column
	LCmpModulusColA []ifaces.Column
	ECmpModulusColA []ifaces.Column
	// Flags when comparing ColumnA with ColumnB
	GCmpColAColB []ifaces.Column
	LCmpColAColB []ifaces.Column
	ECmpColAColB []ifaces.Column
	// ActiveRow works as a filter
	ActiveRow *symbolic.Expression
}

// Defines all the columns of Byte32cmpCtx and registers all the required constraint
func (bcp *BytesCmpCtx) Define(comp *wizard.CompiledIOP, numLimbs, bitPerLimbs int, name string) {
	if bcp.ColumnA.Size() != bcp.ColumnB.Size() {
		utils.Panic("The size of columnA and columnB are different, %v vs %v", bcp.ColumnA.Size(), bcp.ColumnB.Size())
	}

	bcp.Comp = comp
	bcp.NumLimbs = numLimbs
	bcp.BitPerLimbs = bitPerLimbs
	bcp.Name = name
	// Specify the sizes of columns
	bcp.ColumnAlimbs = make([]ifaces.Column, numLimbs)
	bcp.ColumnBlimbs = make([]ifaces.Column, numLimbs)
	bcp.GCmpModulusColA = make([]ifaces.Column, numLimbs)
	bcp.LCmpModulusColA = make([]ifaces.Column, numLimbs)
	bcp.ECmpModulusColA = make([]ifaces.Column, numLimbs)
	bcp.GCmpColAColB = make([]ifaces.Column, numLimbs)
	bcp.LCmpColAColB = make([]ifaces.Column, numLimbs)
	bcp.ECmpColAColB = make([]ifaces.Column, numLimbs)
	bcp.ModulusLimbs = make([]ifaces.Column, numLimbs)

	// Define the columns and insert range constraints
	bcp.defineColumns()
	// Define the flags
	bcp.defineFlags()
	// Queries for the comparison of modulus limbs with that of ColumnA
	// This proves that modulus is strictly greater than each element of ColumnA
	bcp.cmpLimbs(true)
	// Queries for the comparison of limbs of ColumnA and ColumnB
	// This proves that all the elements of ColumnA are strictly greater than that of ColumnB
	bcp.cmpLimbs(false)
}

// Size returns the size of the bytes cmp module
func (bcp *BytesCmpCtx) Size() int {
	return bcp.ColumnA.Size()
}

// Compute Modulus Limbs
func (bcp *BytesCmpCtx) computeModulusLimbs() []field.Element {
	moduluslimbsWitness := make([]field.Element, bcp.NumLimbs)
	for i := 0; i < bcp.NumLimbs; i++ {
		l := uint64(0)
		for k := i * bcp.BitPerLimbs; k < (i+1)*bcp.BitPerLimbs; k++ {
			extractedBit := field.Modulus().Bit(k)
			l |= uint64(extractedBit) << (k % bcp.BitPerLimbs)
		}
		moduluslimbsWitness[i].SetUint64(l)
	}
	return moduluslimbsWitness
}

func (bcp *BytesCmpCtx) defineColumns() {

	for i := 0; i < bcp.NumLimbs; i++ {
		// Declare the limbs for columnA
		bcp.ColumnAlimbs[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_COLUMN_A_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)
		// Enforces the range over the limbs of columnA
		bcp.Comp.InsertRange(
			bcp.Round,
			ifaces.QueryIDf("BYTE32CMP_LIMB_RANGE_COLUMN_A_%v_LIMB_%v", bcp.Name, i),
			bcp.ColumnAlimbs[i],
			1<<bcp.BitPerLimbs,
		)
		// Declare the limbs for ColumnB
		bcp.ColumnBlimbs[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_COLUMN_B_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)
		// Enforces the range over the limbs of columnB
		bcp.Comp.InsertRange(
			bcp.Round,
			ifaces.QueryIDf("BYTE32CMP_LIMB_RANGE_COLUMN_B_%v_LIMB_%v", bcp.Name, i),
			bcp.ColumnBlimbs[i],
			1<<bcp.BitPerLimbs,
		)
		// Accessing the Modulus limbs
		moduluslimbsWitness := bcp.computeModulusLimbs()
		// Assign the modulus limbs. The reason we remove the name from the
		// constant col is because this column never originates from compilation
		// This choices makes the generated bytes comparison wizard distributable.
		bcp.ModulusLimbs[i] = verifiercol.NewConstantCol(moduluslimbsWitness[i], bcp.Size(), bcp.Name)
	}

	// Build the linear combination with powers of 2^bitPerLimbs.
	// The limbs are in "little-endian" order. Namely, the first
	// limb encodes the least significant bits first.
	pow2 := symbolic.NewConstant(1 << bcp.BitPerLimbs)
	accA := ifaces.ColumnAsVariable(bcp.ColumnAlimbs[bcp.NumLimbs-1])
	accB := ifaces.ColumnAsVariable(bcp.ColumnBlimbs[bcp.NumLimbs-1])
	for i := bcp.NumLimbs - 2; i >= 0; i-- {
		accA = symbolic.Mul(accA, pow2)
		accA = symbolic.Add(accA, bcp.ColumnAlimbs[i])
		accB = symbolic.Mul(accB, pow2)
		accB = symbolic.Add(accB, bcp.ColumnBlimbs[i])
	}

	// Declare the global constraint for columnA and columnB
	bcp.Comp.InsertGlobal(bcp.Round, ifaces.QueryIDf("GLOBAL_BYTE32CMP_ACCUMULATION_COLUMN_A_%v", bcp.Name), symbolic.Sub(accA, bcp.ColumnA))
	bcp.Comp.InsertGlobal(bcp.Round, ifaces.QueryIDf("GLOBAL_BYTE32CMP_ACCUMULATION_COLUMN_B_%v", bcp.Name), symbolic.Sub(accB, bcp.ColumnB))
}

func (bcp *BytesCmpCtx) defineFlags() {
	for i := 0; i < bcp.NumLimbs; i++ {
		// Declare gCmpModulusColA
		bcp.GCmpModulusColA[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_G_MOD_COL_A_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)

		// Declare lCmpModulusColA
		bcp.LCmpModulusColA[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_L_MOD_COL_A_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)

		// Declare eCmpModulusColA
		bcp.ECmpModulusColA[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_E_MOD_COL_A_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)

		// Declare gCmpColAColB
		bcp.GCmpColAColB[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_G_COL_A_COL_B_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)

		// Declare lCmpColAColB
		bcp.LCmpColAColB[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_L_COL_A_COL_B_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)

		// Declare eCmpColAColB
		bcp.ECmpColAColB[i] = bcp.Comp.InsertCommit(
			bcp.Round,
			ifaces.ColIDf("BYTE32CMP_COL_A_COL_B_%v_LIMB_%v", bcp.Name, i),
			bcp.Size(),
			true,
		)
	}
}

func (bcp *BytesCmpCtx) cmpLimbs(isCmpWithModulus bool) {
	var (
		g         = make([]*symbolic.Expression, bcp.NumLimbs)
		l         = make([]*symbolic.Expression, bcp.NumLimbs)
		e         = make([]*symbolic.Expression, bcp.NumLimbs)
		gMinusl   = make([]*symbolic.Expression, bcp.NumLimbs)
		colALimbs = make([]*symbolic.Expression, bcp.NumLimbs)
		colBLimbs = make([]*symbolic.Expression, bcp.NumLimbs)
		name_     string
	)
	// If comparing with the modulus, then colA is modulus and colB is bcp.columnA
	// If not comparing with the modulus, then colA is bcp.columnA and colB is bcp.columnB
	if isCmpWithModulus {
		name_ = "MOD_COL_A"
		for i := 0; i < bcp.NumLimbs; i++ {
			g[i] = ifaces.ColumnAsVariable(bcp.GCmpModulusColA[i])
			l[i] = ifaces.ColumnAsVariable(bcp.LCmpModulusColA[i])
			e[i] = ifaces.ColumnAsVariable(bcp.ECmpModulusColA[i])
			colALimbs[i] = ifaces.ColumnAsVariable(bcp.ModulusLimbs[i])
			colBLimbs[i] = ifaces.ColumnAsVariable(bcp.ColumnAlimbs[i])
		}
	} else {
		name_ = "COL_A_COL_B"
		for i := 0; i < bcp.NumLimbs; i++ {
			g[i] = ifaces.ColumnAsVariable(bcp.GCmpColAColB[i])
			l[i] = ifaces.ColumnAsVariable(bcp.LCmpColAColB[i])
			e[i] = ifaces.ColumnAsVariable(bcp.ECmpColAColB[i])
			colALimbs[i] = ifaces.ColumnAsVariable(bcp.ColumnAlimbs[i])
			colBLimbs[i] = ifaces.ColumnAsVariable(bcp.ColumnBlimbs[i])
		}
	}

	// declare gMinusL
	for i := 0; i < bcp.NumLimbs; i++ {
		gMinusl[i] = symbolic.Sub(g[i], l[i])
	}

	// Declare the sequential limb check query (considering g, l, e follow little endian order)
	// If there are three limbs (numLimbs = 3) for each element of colA and colB, this will look like
	// expr = activeRow[i]*{1 - ((g1[i]-l1[i])+e1[i]*((g2[i]-l2[i])+e2[i]*(g3[i]-l3[i]-e3[i])))}
	// (here g1 is MSB and g3 is LSB)
	// To give an example: suppose MSB of colA is more than MSB of colB. Then we have g1 = 1, l1 = 0, e1 = 0
	// (the rest of the values are irrelevant). The expr boils down to zero as expected.
	acc := gMinusl[0]
	acc = symbolic.Sub(acc, e[0])
	for i := 1; i < bcp.NumLimbs; i++ {
		acc = symbolic.Mul(acc, e[i])
		acc = symbolic.Add(acc, gMinusl[i])
	}
	// acc = 1 - acc
	acc = symbolic.Sub(symbolic.NewConstant(1), acc)

	// Filtering by the activeRows
	acc = symbolic.Mul(acc, bcp.ActiveRow)

	// Declare the global constraint
	bcp.Comp.InsertGlobal(bcp.Round, ifaces.QueryIDf("GLOBAL_BYTE32CMP_SEQUENTIAL_LIMB_CHECK_%v_%v", name_, bcp.Name), acc)

	for i := 1; i < bcp.NumLimbs; i++ {
		// Range query on (g[i](colALimbs[i]-colBLimbs[i]) + l[i](colBLimbs[i]-colALimbs[i]))
		summand1 := symbolic.Mul(g[i], symbolic.Sub(colALimbs[i], colBLimbs[i]))
		summand2 := symbolic.Mul(l[i], symbolic.Sub(colBLimbs[i], colALimbs[i]))
		expr1 := symbolic.Add(summand1, summand2)
		// Filtering by the activeRows
		expr1 = symbolic.Mul(expr1, bcp.ActiveRow)
		name2 := fmt.Sprintf("GLOBAL_BYTE32CMP_%v_BIGRANGE_%v_%v_", name_, bcp.Name, i)
		// As we compare modulus limbs, we need total number of bits 256
		bigrange.BigRange(bcp.Comp, expr1, 16, 16, name2)

		// Sanity of g, l, and e, when active they should sum up to 1 (law of tricotomy)
		expr2 := symbolic.Add(g[i], l[i], e[i])
		expr2 = symbolic.Sub(symbolic.NewConstant(1), expr2)
		expr2 = symbolic.Mul(expr2, bcp.ActiveRow)
		bcp.Comp.InsertGlobal(bcp.Round, ifaces.QueryIDf("GLOBAL_BYTE32CMP_GLE_SUM_%v_%v_%v", name_, bcp.Name, i), expr2)
	}

}

// assigns the columns of Byte32CmpCtx
func (bcp *BytesCmpCtx) assign(
	run *wizard.ProverRuntime,
	colA, colB smartvectors.SmartVector,
) {
	var (
		colALimbs    = make([][]field.Element, bcp.NumLimbs)
		colBLimbs    = make([][]field.Element, bcp.NumLimbs)
		gCmpModColA  = make([][]field.Element, bcp.NumLimbs)
		lCmpModColA  = make([][]field.Element, bcp.NumLimbs)
		eCmpModColA  = make([][]field.Element, bcp.NumLimbs)
		gCmpColAColB = make([][]field.Element, bcp.NumLimbs)
		lCmpColAColB = make([][]field.Element, bcp.NumLimbs)
		eCmpColAColB = make([][]field.Element, bcp.NumLimbs)
	)
	// Accessing the Modulus limbs
	moduluslimbsWitness := bcp.computeModulusLimbs()

	// Assigning the size of the var columns
	for i := 0; i < bcp.NumLimbs; i++ {
		colALimbs[i] = make([]field.Element, bcp.Size())
		colBLimbs[i] = make([]field.Element, bcp.Size())
		gCmpModColA[i] = make([]field.Element, bcp.Size())
		lCmpModColA[i] = make([]field.Element, bcp.Size())
		eCmpModColA[i] = make([]field.Element, bcp.Size())
		gCmpColAColB[i] = make([]field.Element, bcp.Size())
		lCmpColAColB[i] = make([]field.Element, bcp.Size())
		eCmpColAColB[i] = make([]field.Element, bcp.Size())
	}

	for j := 0; j < bcp.Size(); j++ {
		colAValFr := colA.Get(j)
		colBValFr := colB.Get(j)
		if colAValFr == field.Zero() && colBValFr == field.Zero() {
			continue
		}
		var colAVal, colBVal big.Int
		colAValFr.BigInt(&colAVal)
		colBValFr.BigInt(&colBVal)

		for i := 0; i < bcp.NumLimbs; i++ {
			limbA := uint64(0)
			limbB := uint64(0)
			for k := i * bcp.BitPerLimbs; k < (i+1)*bcp.BitPerLimbs; k++ {
				extractedBitA := colAVal.Bit(k)
				extractedBitB := colBVal.Bit(k)
				limbA |= uint64(extractedBitA) << (k % bcp.BitPerLimbs)
				limbB |= uint64(extractedBitB) << (k % bcp.BitPerLimbs)
			}
			// To assign limbs
			colALimbs[i][j].SetUint64(limbA)
			colBLimbs[i][j].SetUint64(limbB)
			// To assign flags comparing Modulus and ColumnA
			switch {
			case limbA == moduluslimbsWitness[i].Uint64():
				gCmpModColA[i][j] = field.Zero()
				lCmpModColA[i][j] = field.Zero()
				eCmpModColA[i][j] = field.One()
			case moduluslimbsWitness[i].Uint64() > limbA:
				gCmpModColA[i][j] = field.One()
				lCmpModColA[i][j] = field.Zero()
				eCmpModColA[i][j] = field.Zero()
			case moduluslimbsWitness[i].Uint64() < limbA:
				gCmpModColA[i][j] = field.Zero()
				lCmpModColA[i][j] = field.One()
				eCmpModColA[i][j] = field.Zero()
			}
			// To assign flags comparing ColumnA and ColumnB
			switch {
			case limbA == limbB:
				gCmpColAColB[i][j] = field.Zero()
				lCmpColAColB[i][j] = field.Zero()
				eCmpColAColB[i][j] = field.One()
			case limbA > limbB:
				gCmpColAColB[i][j] = field.One()
				lCmpColAColB[i][j] = field.Zero()
				eCmpColAColB[i][j] = field.Zero()
			case limbA < limbB:
				gCmpColAColB[i][j] = field.Zero()
				lCmpColAColB[i][j] = field.One()
				eCmpColAColB[i][j] = field.Zero()
			}

		}

	}
	// assign the computed columns
	for i := 0; i < bcp.NumLimbs; i++ {
		run.AssignColumn(bcp.ColumnAlimbs[i].GetColID(), smartvectors.NewRegular(colALimbs[i]))
		run.AssignColumn(bcp.ColumnBlimbs[i].GetColID(), smartvectors.NewRegular(colBLimbs[i]))
		run.AssignColumn(bcp.GCmpModulusColA[i].GetColID(), smartvectors.NewRegular(gCmpModColA[i]))
		run.AssignColumn(bcp.LCmpModulusColA[i].GetColID(), smartvectors.NewRegular(lCmpModColA[i]))
		run.AssignColumn(bcp.ECmpModulusColA[i].GetColID(), smartvectors.NewRegular(eCmpModColA[i]))
		run.AssignColumn(bcp.GCmpColAColB[i].GetColID(), smartvectors.NewRegular(gCmpColAColB[i]))
		run.AssignColumn(bcp.LCmpColAColB[i].GetColID(), smartvectors.NewRegular(lCmpColAColB[i]))
		run.AssignColumn(bcp.ECmpColAColB[i].GetColID(), smartvectors.NewRegular(eCmpColAColB[i]))

	}
}
