// Code generated by bavard DO NOT EDIT

package ringsis_64_16

import (
	"github.com/consensys/linea-monorepo/prover/maths/field"
	"math/big"
)

// PrecomputeTwiddlesCoset precomputes twiddlesCoset from twiddles and coset table
// it then return all elements in the correct order for the unrolled FFT.
func PrecomputeTwiddlesCoset(generator, shifter field.Element) []field.Element {
	toReturn := make([]field.Element, 63)
	var r, s field.Element
	e := new(big.Int)

	s = shifter

	for k := 0; k < 5; k++ {
		s.Square(&s)
	}

	toReturn[0] = s

	s = shifter

	for k := 0; k < 4; k++ {
		s.Square(&s)
	}

	toReturn[1] = s

	r.Exp(generator, e.SetUint64(uint64(1<<4*1)))
	toReturn[2].Mul(&r, &s)

	s = shifter

	for k := 0; k < 3; k++ {
		s.Square(&s)
	}

	toReturn[3] = s

	r.Exp(generator, e.SetUint64(uint64(1<<3*2)))
	toReturn[4].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<3*1)))
	toReturn[5].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<3*3)))
	toReturn[6].Mul(&r, &s)

	s = shifter

	for k := 0; k < 2; k++ {
		s.Square(&s)
	}

	toReturn[7] = s

	r.Exp(generator, e.SetUint64(uint64(1<<2*4)))
	toReturn[8].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*2)))
	toReturn[9].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*6)))
	toReturn[10].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*1)))
	toReturn[11].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*5)))
	toReturn[12].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*3)))
	toReturn[13].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<2*7)))
	toReturn[14].Mul(&r, &s)

	s = shifter

	for k := 0; k < 1; k++ {
		s.Square(&s)
	}

	toReturn[15] = s

	r.Exp(generator, e.SetUint64(uint64(1<<1*8)))
	toReturn[16].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*4)))
	toReturn[17].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*12)))
	toReturn[18].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*2)))
	toReturn[19].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*10)))
	toReturn[20].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*6)))
	toReturn[21].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*14)))
	toReturn[22].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*1)))
	toReturn[23].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*9)))
	toReturn[24].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*5)))
	toReturn[25].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*13)))
	toReturn[26].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*3)))
	toReturn[27].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*11)))
	toReturn[28].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*7)))
	toReturn[29].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<1*15)))
	toReturn[30].Mul(&r, &s)

	s = shifter

	for k := 0; k < 0; k++ {
		s.Square(&s)
	}

	toReturn[31] = s

	r.Exp(generator, e.SetUint64(uint64(1<<0*16)))
	toReturn[32].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*8)))
	toReturn[33].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*24)))
	toReturn[34].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*4)))
	toReturn[35].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*20)))
	toReturn[36].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*12)))
	toReturn[37].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*28)))
	toReturn[38].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*2)))
	toReturn[39].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*18)))
	toReturn[40].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*10)))
	toReturn[41].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*26)))
	toReturn[42].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*6)))
	toReturn[43].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*22)))
	toReturn[44].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*14)))
	toReturn[45].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*30)))
	toReturn[46].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*1)))
	toReturn[47].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*17)))
	toReturn[48].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*9)))
	toReturn[49].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*25)))
	toReturn[50].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*5)))
	toReturn[51].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*21)))
	toReturn[52].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*13)))
	toReturn[53].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*29)))
	toReturn[54].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*3)))
	toReturn[55].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*19)))
	toReturn[56].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*11)))
	toReturn[57].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*27)))
	toReturn[58].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*7)))
	toReturn[59].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*23)))
	toReturn[60].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*15)))
	toReturn[61].Mul(&r, &s)

	r.Exp(generator, e.SetUint64(uint64(1<<0*31)))
	toReturn[62].Mul(&r, &s)

	return toReturn
}
