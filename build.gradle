import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

import java.time.Duration

plugins {
  alias(libs.plugins.spotless)
  alias(libs.plugins.docker)
}

task compileAll

// to allow to have unused vars/imports,etc for faster debugging/prototyping
// instead of deleting and re-adding code all the time
def allowCompilationWarnings = System.getenv('LINEA_DEV_ALLOW_WARNINGS') != null

allprojects {
  repositories {
    mavenCentral()
    mavenLocal()
  }

  apply plugin: 'java' // do not add kotlin plugin here, it will add unnecessary Kotlin runtime dependencies
  apply plugin: 'jacoco'

  tasks.withType(KotlinCompile).configureEach {
    compileAll.dependsOn it
    compilerOptions {
      allWarningsAsErrors = !allowCompilationWarnings
    }
  }

  tasks.withType(JavaCompile).configureEach {
    compileAll.dependsOn it
    options.encoding = 'UTF-8'
    options.deprecation = true
    options.compilerArgs.addAll([
      '-parameters',
      '-Xlint:cast',
      '-Xlint:overloads',
      '-Xlint:divzero',
      '-Xlint:finally',
      '-Xlint:static',
      '-Xlint:deprecation',
    ])
    if (!allowCompilationWarnings) {
      options.compilerArgs.addAll(['-Werror'])
    }

    if (!project.path.contains("testing-tools")) {
      // testing tools have 100+ errors because of this
      // skipping them for now
      options.compilerArgs.addAll(['-Xlint:rawtypes'])
    }
  }

  jacoco {
    toolVersion = '0.8.11'
    if (project.tasks.findByName('integrationTest')) {
      applyTo integrationTest
    }
    if (project.tasks.findByName('acceptanceTest')) {
      applyTo acceptanceTest
    }
  }

  jacocoTestReport {
    dependsOn test
  }

  tasks.withType(Javadoc).configureEach {
    exclude '**/generated/**'
  }

  tasks.withType(Test).configureEach {
    testLogging {
      events = [
        //TestLogEvent.STARTED,
        //TestLogEvent.PASSED,
        TestLogEvent.FAILED,
        TestLogEvent.SKIPPED,
        TestLogEvent.STANDARD_ERROR
      ]
      exceptionFormat TestExceptionFormat.FULL
      showCauses true
      showExceptions true
      showStackTraces true
      // set showStandardStreams if you need to see test logs
      showStandardStreams false
    }
    systemProperty("L1_RPC_URL", "http://localhost:8445")
    systemProperty("L2_RPC_URL", "http://localhost:8545")
    systemProperty("L1_GENESIS", "docker/config/l1-node/el/genesis.json")
    systemProperty("L2_GENESIS", "docker/config/linea-local-dev-genesis-PoA-besu.json")

    systemProperties["junit.jupiter.execution.timeout.default"] = "5 m" // 5 minutes
    systemProperties["junit.jupiter.execution.parallel.enabled"] = true
    systemProperties["junit.jupiter.execution.parallel.mode.default"] = "concurrent"
    systemProperties["junit.jupiter.execution.parallel.mode.classes.default"] = "concurrent"
    maxParallelForks = Math.max(Runtime.runtime.availableProcessors(), 9)
  }

  tasks.withType(Test).matching { it.name == 'integrationTest' }.configureEach {
    outputs.cacheIf { false }
    outputs.upToDateWhen { false }
  }

  afterEvaluate { subproject ->
    if (hasJavaOrKotlinPlugins(subproject)) {
      subproject.apply plugin: 'com.diffplug.spotless'

      subproject.spotless {
        if (hasKotlinPlugin(subproject)) {
          kotlin {
            // by default the target is every '.kt' and '.kts` file in the java sourcesets
            //ktfmt()
            ktlint(libs.versions.ktlint.get().toString())
                .editorConfigOverride([
                  'ktlint_standard_discouraged-comment-location': 'disabled',
                  'ktlint_standard_property-naming': 'disabled',
                  'ktlint_standard_function-naming': 'disabled',
                  'ktlint_standard_function-signature': 'disabled',
                  // 'ktlint_function_signature_rule_force_multiline_when_parameter_count_greater_or_equal_than': '1'
                ])
          }
        }
        // spotless check applied to build.gradle (groovy) files
        groovyGradle {
          target '*.gradle'
          greclipse("4.32")
          leadingTabsToSpaces(2)
          endWithNewline()
        }

        java {
          target 'src/**/*.java'
          // Do not use 'targetExclude' with wildcard patterns, it will add minutes to the build
          removeUnusedImports()
          trimTrailingWhitespace()
          endWithNewline()
          googleJavaFormat(libs.versions.googleJavaFormat.get())
        }

        // Below this line are currently only license header tasks
        // format 'groovy', { target '**/src/*/groovy/**/*.groovy' }
        // format 'bash', { target '**/*.sh' }
        // format 'sol', { target '**/*.sol' }
      }
    }
  }
}

task jacocoRootReport(type: JacocoReport) {
  // Define a project list will all subprojects excluding 'tracer' (TODO: fix to include tracer)
  def reportProjects = subprojects.findAll { subproject ->
    // Get the path of the subproject relative to the root dir (e.g., "tracer/lib-a")
    def relativePath = rootProject.relativePath(subproject.projectDir)
    // Include only if the path does NOT start with "tracer"
    return !relativePath.startsWith('tracer')
  }

  additionalSourceDirs.from files(reportProjects.sourceSets.main.allSource.srcDirs)
  sourceDirectories.from files(reportProjects.sourceSets.main.allSource.srcDirs)
  classDirectories.from files(reportProjects.sourceSets.main.output)

  // Exclude the tracer folder from the execution data scan (TODO: fix to include tracer)
  executionData.from fileTree(dir: '.', includes: ['**/jacoco/*.exec'], excludes: ['tracer/**'])
  reports {
    xml.required = true
    // xml.enabled = true FIXME: deprecated, breaking latest versions of gradle.
    csv.required = true
    html.destination file("build/reports/jacocoHtml")
  }
  onlyIf = { true }
}

/** Returns true if the given Besu version is available in Maven local and the distribution exists */
def isBesuAndDistributionAvailableInMavenLocal = { String version ->
  if (version == null || version.isEmpty()) return false
  def mavenLocalPom = new File(System.getProperty('user.home'), ".m2/repository/org/hyperledger/besu/bom/${version}/bom-${version}.pom")
  if (!mavenLocalPom.exists()) {
    logger.lifecycle("isBesuAndDistributionAvailableInMavenLocal: besu:${version} is not in maven local")
  }
  def besuDistTar = rootProject.file("tmp/hyperledger-besu/build/distributions/besu-${version}.tar.gz")
  if (!besuDistTar.exists()) {
    logger.lifecycle("isBesuAndDistributionAvailableInMavenLocal: besu-${version}.tar.gz distribution doesn't exist")
  }
  return (mavenLocalPom.exists() && besuDistTar.exists())
}

/** Returns true if the given Besu version is available in Maven local or any of the maven repos */
def isBesuAvailableInMaven = { String version, checkRemoteOnly = false ->
  if (version == null || version.isEmpty()) return false

  if (!checkRemoteOnly) {
    def mavenLocalPom = new File(System.getProperty('user.home'), ".m2/repository/org/hyperledger/besu/bom/${version}/bom-${version}.pom")
    if (mavenLocalPom.exists()) {
      logger.lifecycle("isBesuAvailableInMaven: Besu ${version} found at maven local")
      return true
    }
  }

  def candidates = [
    "https://artifacts.consensys.net/public/linea-besu/maven/org/hyperledger/besu/bom/${version}/bom-${version}.pom",
    "https://repo.maven.apache.org/maven2/org/hyperledger/besu/bom/${version}/bom-${version}.pom",
    "https://hyperledger.jfrog.io/hyperledger/besu-maven/org/hyperledger/besu/bom/${version}/bom-${version}.pom",
  ]
  def connectTimeoutMs = 5000
  def readTimeoutMs = 5000
  for (def pomUrl : candidates) {
    try {
      def conn = (java.net.HttpURLConnection) new URL(pomUrl).openConnection()
      conn.setConnectTimeout(connectTimeoutMs)
      conn.setReadTimeout(readTimeoutMs)
      conn.setRequestMethod('HEAD')
      if (conn.getResponseCode() == 200) {
        logger.lifecycle("isBesuAvailableInMaven: Besu ${version} found at maven repo: ${pomUrl}")
        return true
      }
    } catch (Exception ignored) {
      // try next candidate
    }
  }
  return false
}

/** Tries to download the Besu distribution tar.gz from the Linea Besu Maven repo into tmp/hyperledger-besu/build/distributions/. Returns true if downloaded. */
def downloadBesuDistributionFromMaven = { String version, Boolean checkOnly = false ->
  if (version == null || version.isEmpty()) return false
  def destDir = rootProject.file("tmp/hyperledger-besu/build/distributions")
  def destFile = new File(destDir, "besu-${version}.tar.gz")
  if (destFile.exists()) {
    logger.lifecycle("downloadBesuDistributionFromMaven: Found existing besu distribution at ${destFile}, skipping download")
    return true
  }
  def baseUrl = "https://artifacts.consensys.net/public/linea-besu/raw/names/linea-besu.tar.gz/versions/"
  def url = "${baseUrl}${version}/besu-${version}.tar.gz"
  try {
    def conn = (java.net.HttpURLConnection) new URL(url).openConnection()
    conn.setConnectTimeout(10000)
    conn.setReadTimeout(60000)
    if (checkOnly) {
      conn.setRequestMethod('HEAD')
      if (conn.getResponseCode() == 200) {
        logger.lifecycle("downloadBesuDistributionFromMaven: Found besu distribution from Maven (${url})")
        return true
      }
      return false
    } else {
      destDir.mkdirs()
      conn.setRequestMethod('GET')

      if (conn.getResponseCode() != 200) {
        logger.lifecycle("downloadBesuDistributionFromMaven: Could not find and download besu distribution from Maven (${url})")
        return false
      }
      conn.getInputStream().withStream { input ->
        destFile.withOutputStream { it << input }
      }
      logger.lifecycle("downloadBesuDistributionFromMaven: Downloaded besu-${version}.tar.gz from Maven to ${destFile}")
      return true
    }
  } catch (Exception e) {
    logger.lifecycle("downloadBesuDistributionFromMaven: Failed to download besu distribution from Maven (${url}): ${e.message}")
    if (destFile.exists()) {
      destFile.delete()
      logger.lifecycle("downloadBesuDistributionFromMaven: Removed partial/corrupt file so next run can retry: ${destFile}")
    }
    return false
  }
}

def besuCommit = releases.versions.besuCommit.get()
def besuCommitShort = besuCommit.take(7)
def checkoutAndResolveVersionScript = """
    set -e
    BESU_DIR='${rootProject.layout.projectDirectory.asFile.absolutePath}/tmp/hyperledger-besu'
    BESU_COMMIT='${besuCommit}'
    SHORT_COMMIT='${besuCommitShort}'
    if [ ! -d "\$BESU_DIR/.git" ]; then
      echo "Cloning https://github.com/hyperledger/besu into \$BESU_DIR"
      mkdir -p "\$(dirname "\$BESU_DIR")"
      git clone --no-checkout https://github.com/hyperledger/besu.git "\$BESU_DIR"
      cd "\$BESU_DIR" && git checkout "\$BESU_COMMIT"
    else
      (cd "\$BESU_DIR" && git reset --hard && git fetch origin && git checkout "\$BESU_COMMIT")
    fi
    BASE_TAG=\$(cd "\$BESU_DIR" && git describe --tags --abbrev=0 "\$BESU_COMMIT" 2>/dev/null || true)
    if [ -n "\$BASE_TAG" ]; then
      BESU_VERSION="\${BASE_TAG}-develop-\${SHORT_COMMIT}"
    else
      BESU_VERSION="0.0.0-develop-\${SHORT_COMMIT}"
    fi
    echo "Resolved besuVersion: \$BESU_VERSION"
    echo "\$BESU_VERSION"
"""

tasks.register('checkoutAndResolveVersion') {
  group = 'Build'
  description = 'Clone/fetch hyperledger/besu at besuCommit and resolve besu version = latest release tag + "-" + 7-char commit'
  doLast {
    def outputStream = new ByteArrayOutputStream()
    exec {
      workingDir = rootProject.layout.projectDirectory.asFile
      commandLine 'bash', '-c', checkoutAndResolveVersionScript
      standardOutput = outputStream
    }
    def resolvedBesuVer = outputStream.toString().trim().readLines().last()
    rootProject.ext.resolvedBesuVer = resolvedBesuVer
    logger.lifecycle("Resolved besu version: ${resolvedBesuVer}")
  }
}

tasks.register('checkoutAndBuildBesu', Exec) {
  group = 'Build'
  description = 'Build Besu at the resolved version (distTar publishToMavenLocal)'
  workingDir = rootProject.layout.projectDirectory.asFile

  def publishToMaven = project.hasProperty('publishToMaven') ? project.publishToMaven.toBoolean() : false
  def publishGradleTaskName = publishToMaven ? "publish" : "publishToMavenLocal"

  dependsOn checkoutAndResolveVersion

  onlyIf {
    def resolvedBesuVer = rootProject.ext.get('resolvedBesuVer')
    if (publishToMaven) {
      return !isBesuAvailableInMaven.call(resolvedBesuVer, true) || !downloadBesuDistributionFromMaven.call(resolvedBesuVer, true)
    }
    if (isBesuAndDistributionAvailableInMavenLocal.call(resolvedBesuVer)) return false
    if (isBesuAvailableInMaven.call(resolvedBesuVer) && downloadBesuDistributionFromMaven.call(resolvedBesuVer)) return false
    return true
  }
  doFirst {
    environment 'RESOLVED_BESU_VERSION', rootProject.ext.resolvedBesuVer
    environment 'CLOUDSMITH_USER', project.hasProperty('cloudsmithUser') ? project.cloudsmithUser : ''
    environment 'CLOUDSMITH_API_KEY', project.hasProperty('cloudsmithApiKey') ? project.cloudsmithApiKey : ''
  }
  commandLine 'bash', '-c', """
    set -e
    BESU_DIR='${rootProject.layout.projectDirectory.asFile.absolutePath}/tmp/hyperledger-besu'
    echo "Injecting Cloudsmith publish to "\$BESU_DIR"/build.gradle"
    java ./linea-besu/scripts/InjectLines.java "\$BESU_DIR"/build.gradle
    echo "Building Besu with version \$RESOLVED_BESU_VERSION (distTar ${publishGradleTaskName})"
    (cd "\$BESU_DIR" && ./gradlew -Prelease.releaseVersion=\$RESOLVED_BESU_VERSION -Pversion=\$RESOLVED_BESU_VERSION distTar ${publishGradleTaskName})
  """
}

tasks.register('buildAndUpdateBesuVersionInLibsVersions') {
  group = 'Build'
  description = 'Updates gradle/libs.versions.toml besu field to the locally-built besu version'
  dependsOn checkoutAndBuildBesu
  doLast {
    def localBesuVersion = rootProject.ext.resolvedBesuVer
    def libsVersionsFile = rootProject.file('gradle/libs.versions.toml')
    def content = libsVersionsFile.text
    content = content.replaceFirst(/besu\s*=\s*"[^"]*"/, "besu = \"${localBesuVersion}\"")
    libsVersionsFile.text = content
    logger.lifecycle("Updated gradle/libs.versions.toml: besu = \"${localBesuVersion}\"")
  }
}

dockerCompose {
  localStack {
    startedServices = [
      "postgres",
      "sequencer",
      "maru",
      "l1-node-genesis-generator",
      "l2-genesis-initialization",
      "l1-el-node",
      "l1-cl-node",
      // For debug
      // "l1-blockscout",
      // "l2-blockscout"
    ]
    composeAdditionalArgs = [
      "--profile",
      "l1",
      "--profile",
      "l2"
    ]
    useComposeFiles = [
      "${project.rootDir.path}/docker/compose-tracing-v2.yml"
    ]
    waitForHealthyStateTimeout = Duration.ofMinutes(3)
    waitForTcpPorts = false
    stopContainers = false
    removeOrphans = true
    // this is to avoid recreating the containers
    // specially l1-node-genesis-generator which corrupts the state if run more than once
    // without cleaning the volumes
    noRecreate = true
    projectName = "docker"
  }

  localStackPostgresDbOnly {
    startedServices = ["postgres"]
    useComposeFiles = [
      "${project.rootDir.path}/docker/compose-tracing-v2.yml"
    ]
    waitForHealthyStateTimeout = Duration.ofMinutes(3)
    stopContainers = false
    waitForTcpPorts = true
    removeOrphans = true
    noRecreate = true
    projectName = "docker"
  }

  localStackForStateRecovery {
    startedServices = [
      "postgres",
      "sequencer",
      "l1-node-genesis-generator",
      "l1-el-node",
      "l1-cl-node",
      "blobscan-api",
      "blobscan-indexer",
      "redis",
    ]
    composeAdditionalArgs = [
      "--profile",
      "l1",
      "--profile",
      "l2",
      "--profile",
      "staterecovery"
    ]
    useComposeFiles = [
      "${project.rootDir.path}/docker/compose-tracing-v2-staterecovery-extension.yml"
    ]
    waitForHealthyStateTimeout = Duration.ofMinutes(3)
    waitForTcpPorts = false
    removeOrphans = true
    stopContainers = false
    // this is to avoid recreating the containers
    // specially l1-node-genesis-generator which corrupts the state if run more than once
    // without cleaning the volumes
    noRecreate = true
    projectName = "docker"
  }
}

static Boolean hasKotlinPlugin(Project proj) {
  return proj.plugins.hasPlugin("org.jetbrains.kotlin.jvm")
}

static Boolean hasJavaPlugin(Project proj) {
  return (proj.plugins.hasPlugin("java") || proj.plugins.hasPlugin("java-library"))
}

static Boolean hasJavaOrKotlinPlugins(Project proj) {
  return (hasKotlinPlugin(proj) || hasJavaPlugin(proj))
}
