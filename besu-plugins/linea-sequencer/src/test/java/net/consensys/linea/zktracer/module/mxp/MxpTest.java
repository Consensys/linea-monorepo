/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package net.consensys.linea.zktracer.module.mxp;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import net.consensys.linea.zktracer.EWord;
import net.consensys.linea.zktracer.opcode.OpCode;
import net.consensys.linea.zktracer.opcode.gas.MxpType;
import net.consensys.linea.zktracer.testing.BytecodeCompiler;
import net.consensys.linea.zktracer.testing.BytecodeRunner;
import net.consensys.linea.zktracer.testing.EvmExtension;
import net.consensys.linea.zktracer.testing.ToyAccount;
import net.consensys.linea.zktracer.testing.ToyExecutionEnvironment;
import net.consensys.linea.zktracer.testing.ToyTransaction;
import net.consensys.linea.zktracer.testing.ToyWorld;
import org.apache.tuweni.bytes.Bytes;
import org.hyperledger.besu.crypto.KeyPair;
import org.hyperledger.besu.crypto.SECP256K1;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.TransactionType;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

// https://github.com/Consensys/linea-besu-plugin/issues/197

@ExtendWith(EvmExtension.class)
public class MxpTest {
  private static final Random RAND = new Random(123456789123456L);
  public static final EWord TWO_POW_128 = EWord.of(EWord.ONE.shiftLeft(128));
  public static final EWord TWO_POW_32 = EWord.of(EWord.ONE.shiftLeft(32));

  // Some OpCodes are not interesting with random arguments, so we skip them in random testing part
  final OpCode[] opCodesType1 = new OpCode[] {OpCode.MSIZE};
  final OpCode[] opCodesType2 = new OpCode[] {OpCode.MLOAD, OpCode.MSTORE};
  final OpCode[] opCodesType3 = new OpCode[] {OpCode.MSTORE8};
  final OpCode[] opCodesType4 =
      new OpCode[] {
        OpCode.LOG0,
        OpCode.LOG1,
        OpCode.LOG2,
        OpCode.LOG3,
        OpCode.LOG4,
        OpCode.SHA3,
        OpCode.CODECOPY,
        OpCode.CALLDATACOPY,
        OpCode.EXTCODECOPY,
        OpCode.CREATE,
        OpCode.CREATE2
      }; // OpCode.COPY-type (Type 4) and OpCode.CALL-type (Type 5) are tested via TestCall()
  // instead of TestMxpRandom

  final OpCode[] opCodesHalting = new OpCode[] {OpCode.RETURN, OpCode.REVERT};

  @Test
  void TestMxpSimple() {
    BytecodeRunner.of(
            Bytes.fromHexString(
                "6080604052600160115260885160ff6101ff2060018060018060876102ffa4600080"))
        .run();
  }

  @Test
  void TestMxpSimple2() {
    BytecodeRunner.of(
            Bytes.fromHexString(
                "6080604052600060405161001290610097565b604051809103906000f08015801561002e573d6000803e3d6000fd5b5090508073ffffffffffffffffffffffffffffffffffffffff166326121ff06040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561007957600080fd5b505af115801561008d573d6000803e3d6000fd5b50505050506100a3565b60a2806100f083390190565b603f806100b16000396000f3fe6080604052600080fdfea2646970667358221220b4fef08f9e3ab3367b0614cb11cb9ec36fd74ac9fad781c8b011a36f0eb2bb6b64736f6c634300081200336080604052348015600f57600080fd5b5060848061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c806326121ff014602d575b600080fd5b60336035565b005b60018060018060876102ffa46013600f63ffffffff015256fea2646970667358221220dbb28de6633684f549a1b6c2b223dd89447bc213763fd3ae0c0b113d712d4bb164736f6c63430008120033"))
        .run();
  }

  @Test
  void TestMxpEdgeCaseMXPX() {
    BytecodeRunner.of(
            Bytes.fromHexString(
                "608060405234801561001057600080fd5b50600060405161001f906101c9565b604051809103906000f08015801561003b573d6000803e3d6000fd5b50905060005a905060006014905060005b818110156101c0578373ffffffffffffffffffffffffffffffffffffffff166326121ff083600461007d919061020f565b856100889190610280565b6040518263ffffffff1660e01b8152600401600060405180830381600088803b1580156100b457600080fd5b5087f1935050505080156100c6575060015b508373ffffffffffffffffffffffffffffffffffffffff1663e2179b8e8360046100f0919061020f565b856100fb9190610280565b6040518263ffffffff1660e01b8152600401600060405180830381600088803b15801561012757600080fd5b5087f193505050508015610139575060015b508373ffffffffffffffffffffffffffffffffffffffff1663b8c9d365836004610163919061020f565b8561016e9190610280565b6040518263ffffffff1660e01b8152600401600060405180830381600088803b15801561019a57600080fd5b5087f1935050505080156101ac575060015b5080806101b8906102b1565b91505061004c565b505050506102f9565b6102e58061034683390190565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061021a826101d6565b9150610225836101d6565b9250828202610233816101d6565b9150828204841483151761024a576102496101e0565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061028b826101d6565b9150610296836101d6565b9250826102a6576102a5610251565b5b828204905092915050565b60006102bc826101d6565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102ee576102ed6101e0565b5b600182019050919050565b603f806103076000396000f3fe6080604052600080fdfea264697066735822122033f6db328248c8354d1fe00a403cabce83502d4a3c86a6f7856dcf4f085d972264736f6c63430008120033608060405234801561001057600080fd5b506102c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806326121ff014610046578063b8c9d36514610050578063e2179b8e1461005a575b600080fd5b61004e610064565b005b6100586100a4565b005b6100626100b7565b005b600061006e6100dc565b9050600061007a6100dc565b905060006100866100dc565b905060006100926100dc565b9050808284866000805af15050505050565b60006100ae6100dc565b90506013815250565b60006100c16100dc565b905060006100cd6100dc565b90506001806001808486a45050565b6000806100e9600361015a565b905060008103610105576100fd600361015a565b915050610157565b6001810361012c57610117600361015a565b61ffff61012491906101d1565b915050610157565b600281036101555761013e600361015a565b63ffffffff61014d91906101d1565b915050610157565b505b90565b6000815a60405160200161016e9190610214565b6040516020818303038152906040528051906020012060001c610191919061025e565b9050919050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006101dc82610198565b91506101e783610198565b92508282019050808211156101ff576101fe6101a2565b5b92915050565b61020e81610198565b82525050565b60006020820190506102296000830184610205565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061026982610198565b915061027483610198565b9250826102845761028361022f565b5b82820690509291505056fea26469706673582212204bdb26312b4759dfceb17e8aca627599aafa7fb39df036d87c2077c49f13806b64736f6c63430008120033"))
        .run();
  }

  @Test
  void TestMxpRandom() {
    // Testing a random program
    BytecodeCompiler program = BytecodeCompiler.newProgram();
    final int INSTRUCTION_COUNT = 4096;
    for (int i = 0; i < INSTRUCTION_COUNT; i++) {
      boolean isHalting = i == INSTRUCTION_COUNT - 1;
      triggerNonTrivialOrNoop(program, isHalting);
    }
    BytecodeRunner.of(program.compile()).run();
  }

  @Test
  void TestMxpRandomTriggerMxpx() {
    // Testing a random program
    BytecodeCompiler program = BytecodeCompiler.newProgram();
    final int INSTRUCTION_COUNT = 256;
    for (int i = 0; i < INSTRUCTION_COUNT; i++) {
      boolean isHalting = i == INSTRUCTION_COUNT - 1;
      triggerNonTrivialOrNoop(program, isHalting);
    }
    triggerNonTrivialButMxpxOrRoob(program, false, false);
    BytecodeRunner.of(program.compile()).run();
  }

  @Test
  void TestMxpRandomTriggerRoob() {
    // Testing a random program
    BytecodeCompiler program = BytecodeCompiler.newProgram();
    final int INSTRUCTION_COUNT = 256;
    for (int i = 0; i < INSTRUCTION_COUNT; i++) {
      boolean isHalting = i == INSTRUCTION_COUNT - 1;
      triggerNonTrivialOrNoop(program, isHalting);
    }
    triggerNonTrivialButMxpxOrRoob(program, false, true);
    BytecodeRunner.of(program.compile()).run();
  }

  @Test
  void TestMxpxOrRoob() {
    final int REPETITIONS = 100;
    for (int i = 0; i < REPETITIONS; i++) {
      BytecodeCompiler program = BytecodeCompiler.newProgram();
      boolean isHalting = RAND.nextInt(2) == 0;
      boolean triggerRoob = RAND.nextInt(2) == 0;
      triggerNonTrivialButMxpxOrRoob(program, isHalting, triggerRoob);
      BytecodeRunner.of(program.compile()).run();
    }
  }

  @Test
  void TestMxpRandomAdvanced() {
    // Testing a random program that contains creates with meaning random arguments
    Bytes INIT = getRandomINITForCreate(); // This is the value given as an argument to CREATE

    BytecodeCompiler program = BytecodeCompiler.newProgram();
    int INSTRUCTION_COUNT = 256;
    for (int i = 0; i < INSTRUCTION_COUNT; i++) {
      boolean isHalting = i == INSTRUCTION_COUNT - 1;
      triggerNonTrivialOrNoop(program, isHalting, INIT);
    }
    BytecodeRunner.of(program.compile()).run();
  }

  @Test
  void TestCall() {
    /* NOTE: The contracts in this test are compiled by using
    solc *.sol --bin-runtime --evm-version london -o compiledContracts
    i.e., we do not include the init code of the contracts in the bytecode
    */
    // User address
    KeyPair keyPair = new SECP256K1().generateKeyPair();
    Address userAddress = Address.extract(Hash.hash(keyPair.getPublicKey().getEncodedBytes()));
    ToyAccount userAccount =
        ToyAccount.builder().balance(Wei.fromEth(100)).nonce(1).address(userAddress).build();

    // A
    ToyAccount contractAAccount =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(2)
            .address(Address.fromHexString("0x7b96aF9Bd211cBf6BA5b0dd53aa61Dc5806b6AcE"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b506004361061002b5760003560e01c80631b4d679d14610030575b600080fd5b61004a60048036038101906100459190610380565b61004c565b005b8173ffffffffffffffffffffffffffffffffffffffff1663bcf7277860146104576040518363ffffffff1660e01b815260040161008a929190610459565b600060405180830381600087803b1580156100a457600080fd5b505af11580156100b8573d6000803e3d6000fd5b505050508473ffffffffffffffffffffffffffffffffffffffff1663d602bd5c836040518263ffffffff1660e01b81526004016100f59190610491565b600060405180830381600087803b15801561010f57600080fd5b505af1158015610123573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff1663bcf7277860146108ae6040518363ffffffff1660e01b81526004016101659291906104e7565b600060405180830381600087803b15801561017f57600080fd5b505af1158015610193573d6000803e3d6000fd5b505050508373ffffffffffffffffffffffffffffffffffffffff1663e450cc8c8685856040518463ffffffff1660e01b81526004016101d493929190610510565b600060405180830381600087803b1580156101ee57600080fd5b505af1158015610202573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff1663bcf727786014610d056040518363ffffffff1660e01b8152600401610244929190610582565b600060405180830381600087803b15801561025e57600080fd5b505af1158015610272573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff1663c176f69a826040518263ffffffff1660e01b81526004016102af9190610491565b600060405180830381600087803b1580156102c957600080fd5b505af11580156102dd573d6000803e3d6000fd5b505050507f1e5d1a4c4137b394167b12a8275dfbf8d991f67b2951c477557b8ad000a48cac60405161030e90610608565b60405180910390a15050505050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061034d82610322565b9050919050565b61035d81610342565b811461036857600080fd5b50565b60008135905061037a81610354565b92915050565b600080600080600060a0868803121561039c5761039b61031d565b5b60006103aa8882890161036b565b95505060206103bb8882890161036b565b94505060406103cc8882890161036b565b93505060606103dd8882890161036b565b92505060806103ee8882890161036b565b9150509295509295909350565b6000819050919050565b61040e816103fb565b82525050565b6000819050919050565b6000819050919050565b600061044361043e61043984610414565b61041e565b6103fb565b9050919050565b61045381610428565b82525050565b600060408201905061046e6000830185610405565b61047b602083018461044a565b9392505050565b61048b81610342565b82525050565b60006020820190506104a66000830184610482565b92915050565b6000819050919050565b60006104d16104cc6104c7846104ac565b61041e565b6103fb565b9050919050565b6104e1816104b6565b82525050565b60006040820190506104fc6000830185610405565b61050960208301846104d8565b9392505050565b60006060820190506105256000830186610482565b6105326020830185610482565b61053f6040830184610482565b949350505050565b6000819050919050565b600061056c61056761056284610547565b61041e565b6103fb565b9050919050565b61057c81610551565b82525050565b60006040820190506105976000830185610405565b6105a46020830184610573565b9392505050565b600082825260208201905092915050565b7f656e642041000000000000000000000000000000000000000000000000000000600082015250565b60006105f26005836105ab565b91506105fd826105bc565b602082019050919050565b60006020820190508181036000830152610621816105e5565b905091905056fea2646970667358221220640d751b7d7fe08b426fcc44369630811e36d03ac711145444892f288ee4d4ef64736f6c63430008150033"))
            .build();

    // B
    ToyAccount contractBAccount =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(3)
            .address(Address.fromHexString("0x3328358128832A260C76A4141e19E2A943CD4B6D"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d602bd5c14610030575b600080fd5b61004a60048036038101906100459190610157565b61004c565b005b8073ffffffffffffffffffffffffffffffffffffffff1663bcf72778601461115c6040518363ffffffff1660e01b815260040161008a9291906101e2565b600060405180830381600087803b1580156100a457600080fd5b505af11580156100b8573d6000803e3d6000fd5b505050507f1e5d1a4c4137b394167b12a8275dfbf8d991f67b2951c477557b8ad000a48cac6040516100e990610268565b60405180910390a150565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610124826100f9565b9050919050565b61013481610119565b811461013f57600080fd5b50565b6000813590506101518161012b565b92915050565b60006020828403121561016d5761016c6100f4565b5b600061017b84828501610142565b91505092915050565b6000819050919050565b61019781610184565b82525050565b6000819050919050565b6000819050919050565b60006101cc6101c76101c28461019d565b6101a7565b610184565b9050919050565b6101dc816101b1565b82525050565b60006040820190506101f7600083018561018e565b61020460208301846101d3565b9392505050565b600082825260208201905092915050565b7f656e642042000000000000000000000000000000000000000000000000000000600082015250565b600061025260058361020b565b915061025d8261021c565b602082019050919050565b6000602082019050818103600083015261028181610245565b905091905056fea26469706673582212209406457293fbcd172f20479072cec0849029c9cd8a8a20e6ba723917c76bde9464736f6c63430008150033"))
            .build();

    // C
    ToyAccount contractCAccount =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(4)
            .address(Address.fromHexString("0x5e17b14ADd6c386305A32928F985b29bbA34Eff5"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b506004361061002b5760003560e01c8063e450cc8c14610030575b600080fd5b61004a6004803603810190610045919061030f565b61004c565b005b8073ffffffffffffffffffffffffffffffffffffffff1663bcf7277860146115b36040518363ffffffff1660e01b815260040161008a9291906103c0565b600060405180830381600087803b1580156100a457600080fd5b505af11580156100b8573d6000803e3d6000fd5b505050508273ffffffffffffffffffffffffffffffffffffffff1663d602bd5c826040518263ffffffff1660e01b81526004016100f591906103f8565b600060405180830381600087803b15801561010f57600080fd5b505af1158015610123573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff1663bcf727786014611a0a6040518363ffffffff1660e01b815260040161016592919061044e565b600060405180830381600087803b15801561017f57600080fd5b505af1158015610193573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff1663d602bd5c826040518263ffffffff1660e01b81526004016101d091906103f8565b600060405180830381600087803b1580156101ea57600080fd5b505af11580156101fe573d6000803e3d6000fd5b505050508073ffffffffffffffffffffffffffffffffffffffff1663bcf727786014611e616040518363ffffffff1660e01b81526004016102409291906104b2565b600060405180830381600087803b15801561025a57600080fd5b505af115801561026e573d6000803e3d6000fd5b505050507f1e5d1a4c4137b394167b12a8275dfbf8d991f67b2951c477557b8ad000a48cac60405161029f90610538565b60405180910390a1505050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102dc826102b1565b9050919050565b6102ec816102d1565b81146102f757600080fd5b50565b600081359050610309816102e3565b92915050565b600080600060608486031215610328576103276102ac565b5b6000610336868287016102fa565b9350506020610347868287016102fa565b9250506040610358868287016102fa565b9150509250925092565b6000819050919050565b61037581610362565b82525050565b6000819050919050565b6000819050919050565b60006103aa6103a56103a08461037b565b610385565b610362565b9050919050565b6103ba8161038f565b82525050565b60006040820190506103d5600083018561036c565b6103e260208301846103b1565b9392505050565b6103f2816102d1565b82525050565b600060208201905061040d60008301846103e9565b92915050565b6000819050919050565b600061043861043361042e84610413565b610385565b610362565b9050919050565b6104488161041d565b82525050565b6000604082019050610463600083018561036c565b610470602083018461043f565b9392505050565b6000819050919050565b600061049c61049761049284610477565b610385565b610362565b9050919050565b6104ac81610481565b82525050565b60006040820190506104c7600083018561036c565b6104d460208301846104a3565b9392505050565b600082825260208201905092915050565b7f656e642043000000000000000000000000000000000000000000000000000000600082015250565b60006105226005836104db565b915061052d826104ec565b602082019050919050565b6000602082019050818103600083015261055181610515565b905091905056fea2646970667358221220515b50fb324aff261b8083b11f8d5e7d0de2e50e0a6f77e3328a7b83aaf1c53864736f6c63430008150033"))
            .build();

    // D
    ToyAccount contractDAccount =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(5)
            .address(Address.fromHexString("0xe2899bddFD890e320e643044c6b95B9B0b84157A"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d602bd5c14610030575b600080fd5b61004a60048036038101906100459190610157565b61004c565b005b8073ffffffffffffffffffffffffffffffffffffffff1663bcf7277860146122b86040518363ffffffff1660e01b815260040161008a9291906101e2565b600060405180830381600087803b1580156100a457600080fd5b505af11580156100b8573d6000803e3d6000fd5b505050507f1e5d1a4c4137b394167b12a8275dfbf8d991f67b2951c477557b8ad000a48cac6040516100e990610268565b60405180910390a150565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610124826100f9565b9050919050565b61013481610119565b811461013f57600080fd5b50565b6000813590506101518161012b565b92915050565b60006020828403121561016d5761016c6100f4565b5b600061017b84828501610142565b91505092915050565b6000819050919050565b61019781610184565b82525050565b6000819050919050565b6000819050919050565b60006101cc6101c76101c28461019d565b6101a7565b610184565b9050919050565b6101dc816101b1565b82525050565b60006040820190506101f7600083018561018e565b61020460208301846101d3565b9392505050565b600082825260208201905092915050565b7f656e642044000000000000000000000000000000000000000000000000000000600082015250565b600061025260058361020b565b915061025d8261021c565b602082019050919050565b6000602082019050818103600083015261028181610245565b905091905056fea26469706673582212206f5a584fda0c1021ce78bcaa1e8c737359fbabfb27f80fc8460ee369eae4480864736f6c63430008150033"))
            .build();

    // MO1
    ToyAccount contractMO1Account =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(6)
            .address(Address.fromHexString("0xD4Fc541236927E2EAf8F27606bD7309C1Fc2cbee"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b50600436106100935760003560e01c8063c176f69a11610066578063c176f69a1461011e578063c6232f401461013a578063e366cbd214610156578063e79f469514610160578063ed61b8d41461017c57610093565b80633ceea8211461009857806390b02f8f146100b6578063a8f0ab79146100e6578063bcf7277814610102575b600080fd5b6100a06101ac565b6040516100ad9190610775565b60405180910390f35b6100d060048036038101906100cb91906107c1565b6101b9565b6040516100dd919061081a565b60405180910390f35b61010060048036038101906100fb91906107c1565b6101cb565b005b61011c600480360381019061011791906107c1565b6101d2565b005b61013860048036038101906101339190610893565b61045e565b005b610154600480360381019061014f91906108f9565b61054d565b005b61015e610554565b005b61017a60048036038101906101759190610893565b6105fb565b005b61019660048036038101906101919190610939565b6106e4565b6040516101a39190610775565b60405180910390f35b6000805990508091505090565b60008082842090508091505092915050565b8082525050565b8060008190555060018081905550600080600090505b83811015610458576101fa60066106f4565b915060008203610247577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb604051610231906109c3565b60405180910390a16102416101ac565b50610445565b6001820361029d577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb60405161027c90610a2f565b60405180910390a16102976102926140006106f4565b6106e4565b50610444565b6002820361031b577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb6040516102d290610a9b565b60405180910390a16103166102e86140006106f4565b6103117fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6106f4565b6101cb565b610443565b60038203610399577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb60405161035090610b07565b60405180910390a16103946103666140006106f4565b61038f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6106f4565b61054d565b610442565b600482036103e3577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb6040516103ce90610b73565b60405180910390a16103de610554565b610441565b60058203610440577fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb60405161041890610bdf565b60405180910390a161043e61042e6140006106f4565b6104396140006106f4565b6101b9565b505b5b5b5b5b5b808061045090610c2e565b9150506101e8565b50505050565b7fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb60405161048b90610ce8565b60405180910390a18073ffffffffffffffffffffffffffffffffffffffff1663b17b2aba60006040518263ffffffff1660e01b81526004016104cd9190610d4d565b60006040518083038186803b1580156104e557600080fd5b505afa1580156104f9573d6000803e3d6000fd5b5050505060003d9050600061050f6140006106f4565b905060006105286001846105239190610d68565b6106f4565b90506000610540828561053b9190610d68565b6106f4565b90508082843e5050505050565b8082535050565b6000604067ffffffffffffffff81111561057157610570610d9c565b5b6040519080825280601f01601f1916602001820160405280156105a35781602001600182028036833780820191505090505b509050604051806060016040528060408152602001610ff16040913990507fafabcf2dd47e06a477a89e49c03f8ebe8e0a7e94f775b25bbb24227c9d0110b2816040516105f09190610e5b565b60405180910390a150565b7fe1b72bde44fcea72169114f1bcc1e99e59744d560e36a6e64a48ebedbcdb47eb60405161062890610eef565b60405180910390a18073ffffffffffffffffffffffffffffffffffffffff16639bbfe3b760006040518263ffffffff1660e01b815260040161066a9190610d4d565b60006040518083038186803b15801561068257600080fd5b505afa925050508015610693575060015b5060003d905060006106a66140006106f4565b905060006106bf6001846106ba9190610d68565b6106f4565b905060006106d782856106d29190610d68565b6106f4565b90508082843e5050505050565b6000808251905080915050919050565b60008060005460015460405160200161070e929190610f30565b60405160208183030381529060405280519060200120905060018060008282546107389190610f5c565b925050819055506000838260001c6107509190610fbf565b90508092505050919050565b6000819050919050565b61076f8161075c565b82525050565b600060208201905061078a6000830184610766565b92915050565b600080fd5b61079e8161075c565b81146107a957600080fd5b50565b6000813590506107bb81610795565b92915050565b600080604083850312156107d8576107d7610790565b5b60006107e6858286016107ac565b92505060206107f7858286016107ac565b9150509250929050565b6000819050919050565b61081481610801565b82525050565b600060208201905061082f600083018461080b565b92915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061086082610835565b9050919050565b61087081610855565b811461087b57600080fd5b50565b60008135905061088d81610867565b92915050565b6000602082840312156108a9576108a8610790565b5b60006108b78482850161087e565b91505092915050565b600060ff82169050919050565b6108d6816108c0565b81146108e157600080fd5b50565b6000813590506108f3816108cd565b92915050565b600080604083850312156109105761090f610790565b5b600061091e858286016107ac565b925050602061092f858286016108e4565b9150509250929050565b60006020828403121561094f5761094e610790565b5b600061095d848285016107ac565b91505092915050565b600082825260208201905092915050565b7f6d73697a65457865630000000000000000000000000000000000000000000000600082015250565b60006109ad600983610966565b91506109b882610977565b602082019050919050565b600060208201905081810360008301526109dc816109a0565b9050919050565b7f6d6c6f6164457865630000000000000000000000000000000000000000000000600082015250565b6000610a19600983610966565b9150610a24826109e3565b602082019050919050565b60006020820190508181036000830152610a4881610a0c565b9050919050565b7f6d73746f72654578656300000000000000000000000000000000000000000000600082015250565b6000610a85600a83610966565b9150610a9082610a4f565b602082019050919050565b60006020820190508181036000830152610ab481610a78565b9050919050565b7f6d73746f72653845786563000000000000000000000000000000000000000000600082015250565b6000610af1600b83610966565b9150610afc82610abb565b602082019050919050565b60006020820190508181036000830152610b2081610ae4565b9050919050565b7f6c6f674578656300000000000000000000000000000000000000000000000000600082015250565b6000610b5d600783610966565b9150610b6882610b27565b602082019050919050565b60006020820190508181036000830152610b8c81610b50565b9050919050565b7f6b656363616b3235364578656300000000000000000000000000000000000000600082015250565b6000610bc9600d83610966565b9150610bd482610b93565b602082019050919050565b60006020820190508181036000830152610bf881610bbc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610c398261075c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610c6b57610c6a610bff565b5b600182019050919050565b7f72657475726e64617461636f707945786563202861667465722072657475726e60008201527f2900000000000000000000000000000000000000000000000000000000000000602082015250565b6000610cd2602183610966565b9150610cdd82610c76565b604082019050919050565b60006020820190508181036000830152610d0181610cc5565b9050919050565b6000819050919050565b6000819050919050565b6000610d37610d32610d2d84610d08565b610d12565b61075c565b9050919050565b610d4781610d1c565b82525050565b6000602082019050610d626000830184610d3e565b92915050565b6000610d738261075c565b9150610d7e8361075c565b9250828203905081811115610d9657610d95610bff565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600081519050919050565b600082825260208201905092915050565b60005b83811015610e05578082015181840152602081019050610dea565b60008484015250505050565b6000601f19601f8301169050919050565b6000610e2d82610dcb565b610e378185610dd6565b9350610e47818560208601610de7565b610e5081610e11565b840191505092915050565b60006020820190508181036000830152610e758184610e22565b905092915050565b7f72657475726e64617461636f707945786563202861667465722072657665727460008201527f2900000000000000000000000000000000000000000000000000000000000000602082015250565b6000610ed9602183610966565b9150610ee482610e7d565b604082019050919050565b60006020820190508181036000830152610f0881610ecc565b9050919050565b6000819050919050565b610f2a610f258261075c565b610f0f565b82525050565b6000610f3c8285610f19565b602082019150610f4c8284610f19565b6020820191508190509392505050565b6000610f678261075c565b9150610f728361075c565b9250828201905080821115610f8a57610f89610bff565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610fca8261075c565b9150610fd58361075c565b925082610fe557610fe4610f90565b5b82820690509291505056feaaaa567890abcdef0123456789abcdef01234567890abcdef0123456789abcde1234567890abcdef0123456789abcdef01234567890abcdef0123456789affffa264697066735822122029ec0e0d1a390205eba0ff239d392c0855e3495413eccca5388bb8ea662dc23864736f6c63430008150033"))
            .build();

    // MO2
    ToyAccount contractMO2Account =
        ToyAccount.builder()
            .balance(Wei.fromEth(100))
            .nonce(6)
            .address(Address.fromHexString("0x5FD6eB55D12E759a21C09eF703fe0CBa1DC9d88D"))
            .code(
                Bytes.fromHexString(
                    "608060405234801561001057600080fd5b50600436106100365760003560e01c80639bbfe3b71461003b578063b17b2aba14610057575b600080fd5b610055600480360381019061005091906101e2565b610073565b005b610071600480360381019061006c91906101e2565b61010d565b005b7fffffffffffffffff11111111111111112222222222222222333333333333333381527fffffffffffffffff44444444444444445555555555555555666666666666666660208201527fffffffffffffffff77777777777777778888888888888888999999999999999960408201527fffffffffffffffffaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbcccccccccccccccc6060820152608081fd5b7fffffffffffffffff11111111111111112222222222222222333333333333333381527fffffffffffffffff44444444444444445555555555555555666666666666666660208201527fffffffffffffffff77777777777777778888888888888888999999999999999960408201527fffffffffffffffffaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbcccccccccccccccc6060820152608081f35b600080fd5b6000819050919050565b6101bf816101ac565b81146101ca57600080fd5b50565b6000813590506101dc816101b6565b92915050565b6000602082840312156101f8576101f76101a7565b5b6000610206848285016101cd565b9150509291505056fea2646970667358221220f300591154e39b22544c8d3cb08095fe6bbaa5cfae4910cd3c0cd753f6e43b4764736f6c63430008150033"))
            .build();

    Transaction tx =
        ToyTransaction.builder()
            .sender(userAccount)
            .to(contractAAccount)
            .payload(
                Bytes.fromHexString(
                    "0x1b4d679d0000000000000000000000003328358128832a260c76a4141e19e2a943cd4b6d0000000000000000000000005e17b14add6c386305a32928f985b29bba34eff5000000000000000000000000e2899bddfd890e320e643044c6b95b9b0b84157a000000000000000000000000d4fc541236927e2eaf8f27606bd7309c1fc2cbee0000000000000000000000005fd6eb55d12e759a21c09ef703fe0cba1dc9d88d"))
            .transactionType(TransactionType.FRONTIER)
            .gasLimit(0xffffffffL)
            .value(Wei.ZERO)
            .keyPair(keyPair)
            .build();

    ToyWorld toyWorld =
        ToyWorld.builder()
            .accounts(
                List.of(
                    userAccount,
                    contractAAccount,
                    contractBAccount,
                    contractCAccount,
                    contractDAccount,
                    contractMO1Account,
                    contractMO2Account))
            .build();

    ToyExecutionEnvironment.builder()
        .toyWorld(toyWorld)
        .transaction(tx)
        .testValidator(x -> {})
        .build()
        .run();
  }

  private Bytes getRandomINITForCreate() {
    final int INSTRUCTION_COUNT_INIT = 256;
    BytecodeCompiler INIT = BytecodeCompiler.newProgram();
    for (int i = 0; i < INSTRUCTION_COUNT_INIT; i++) {
      boolean isHalting = i == INSTRUCTION_COUNT_INIT - 1;
      triggerNonTrivialOrNoop(INIT, isHalting);
    }
    return INIT.compile();
  }

  private void triggerNonTrivialOrNoop(BytecodeCompiler program, boolean isHalting) {
    triggerNonTrivialOrNoop(program, isHalting, Bytes.EMPTY);
  }

  private void triggerNonTrivialOrNoop(BytecodeCompiler program, boolean isHalting, Bytes INIT) {
    final float NOOP_PROB = 0.3f;
    final int MAX_BYTE_SIZE = 2;
    MxpType mxpType;
    OpCode opCode;

    if (!isHalting) {
      mxpType = MxpType.values()[RAND.nextInt(1, 5)]; // Type 1 to 4 excluding opCodeLast
      opCode = getRandomOpCodeByType(mxpType);
    } else {
      mxpType = MxpType.TYPE_4;
      opCode = opCodesHalting[RAND.nextInt(opCodesHalting.length)]; // opCodeLast
    }

    // Generate as many random values as needed at most
    EWord size1;
    EWord offset1;
    EWord offset2;
    boolean roob;
    boolean mxpx;
    EWord value = EWord.of(getRandomBigIntegerByBytesSize(0, 4));
    Address address = getRandomBigIntegerByBytesSize(20, 20).toAddress();
    EWord salt = EWord.of(getRandomBigIntegerByBytesSize(0, 4));

    // Keep generating random values until we are in the !roob && !mxpx case
    do {
      size1 = EWord.of(getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE));
      offset1 = EWord.of(getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE));
      offset2 = EWord.of(getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE));

      // NOOP case (except for Type2 and Type3 instructions)
      if (mxpType != MxpType.TYPE_2 && mxpType != MxpType.TYPE_3) {
        if (RAND.nextFloat() < NOOP_PROB) {
          // One or both of the size parameters are equal to 0 (each scenario has the same
          // probability)
          size1 = EWord.ZERO;
          final float offsetModifier = RAND.nextFloat();
          if (offsetModifier < 1 / 3f) {
            // offset1 remains the same
          } else if (offsetModifier > 2 / 3f) {
            // offset1 is large
            offset1 = EWord.of(getRandomBigIntegerByBytesSize(0, 16));
          } else {
            // offset1 is huge
            offset1 = EWord.of(getRandomBigIntegerByBytesSize(16, 32));
          }
        }
      }

      // size2 is irrelevant for this case
      mxpx = isMxpx(mxpType, size1, offset1);
      roob = isRoob(mxpType, size1, offset1);
      if (roob || mxpx) {
        throw new RuntimeException("Unexpected ROOB or MXPX");
      }
    } while (roob || mxpx);

    switch (opCode) {
      case MSIZE:
        appendOpCodeCall(opCode, program);
        break;
      case MLOAD:
        appendOpCodeCall(List.of(offset1), opCode, program);
        program.op(OpCode.POP);
        break;
      case MSTORE, MSTORE8:
        appendOpCodeCall(List.of(value, offset1), opCode, program);
        break;
      case LOG0, SHA3, RETURN, REVERT: // RETURN and REVERT are selected only when isHalting is true
        appendOpCodeCall(List.of(size1, offset1), opCode, program);
        if (opCode == OpCode.SHA3) {
          program.op(OpCode.POP);
        }
        break;
      case LOG1:
        appendOpCodeCall(
            Stream.concat(getRandomUpTo32BytesBigIntegers(1).stream(), Stream.of(size1, offset1))
                .collect(Collectors.toList()),
            opCode,
            program);
        break;
      case LOG2:
        appendOpCodeCall(
            Stream.concat(getRandomUpTo32BytesBigIntegers(2).stream(), Stream.of(size1, offset1))
                .collect(Collectors.toList()),
            opCode,
            program);
        break;
      case LOG3:
        appendOpCodeCall(
            Stream.concat(getRandomUpTo32BytesBigIntegers(3).stream(), Stream.of(size1, offset1))
                .collect(Collectors.toList()),
            opCode,
            program);
        break;
      case LOG4:
        appendOpCodeCall(
            Stream.concat(getRandomUpTo32BytesBigIntegers(4).stream(), Stream.of(size1, offset1))
                .collect(Collectors.toList()),
            opCode,
            program);
        break;
      case CODECOPY, CALLDATACOPY:
        appendOpCodeCall(List.of(size1, offset2, offset1), opCode, program);
        break;
      case EXTCODECOPY:
        appendOpCodeCall(List.of(size1, offset2, offset1, address), opCode, program);
        break;
      case CREATE, CREATE2:
        // CREATEs are added only if INIT is provided
        if (!INIT.isEmpty()) {
          EWord INITCODEOFFSET =
              getRandomBigIntegerByBytesSize(
                  0, MAX_BYTE_SIZE); // roob or mxpx cannot be triggered this way

          size1 = EWord.of(INIT.size());
          offset1 = INITCODEOFFSET;

          for (int i = 0; i < INIT.size(); i += 32) {
            // Get chunks of 32 bytes from INIT
            Bytes chunk = INIT.slice(i, Math.min(32, INIT.size() - i));

            // Add right padding so as chunk always contains 32 bytes
            if (chunk.size() < 32) {
              chunk = Bytes.concatenate(chunk, Bytes.of(new byte[32 - chunk.size()]));
            }

            // MSTORE of chunk
            appendOpCodeCall(
                List.of(EWord.of(chunk), INITCODEOFFSET.add(i)), OpCode.MSTORE, program);
          }
          if (opCode == OpCode.CREATE) {
            // CREATE
            appendOpCodeCall(List.of(size1, offset1, value), opCode, program);
          } else {
            // CREATE2
            appendOpCodeCall(List.of(salt, size1, offset1, value), opCode, program);
          }
        } else {
          /* Otherwise the method is called again (reached only if INIT is not provided and CREATE
          or CREATE2 are selected) */
          triggerNonTrivialOrNoop(program, isHalting);
        }
        break;
      default:
        break;
    }
  }

  private void triggerNonTrivialButMxpxOrRoob(
      BytecodeCompiler program, boolean isHalting, boolean triggerRoob) {
    final int MAX_BYTE_SIZE =
        32; // To trigger MXPX we need at least 5 bytes, while ROOB at least 17 bytes
    MxpType mxpType;
    OpCode opCode;

    if (!isHalting) {
      mxpType = MxpType.values()[RAND.nextInt(2, 5)]; // Type 2 to 4
      opCode = getRandomOpCodeByType(mxpType);
    } else {
      mxpType = MxpType.TYPE_4;
      opCode = opCodesHalting[RAND.nextInt(opCodesHalting.length)]; // opCodeLast
    }

    // Generate as many random values as needed at most
    EWord size1;
    EWord offset1;
    EWord offset2;
    boolean roob;
    boolean mxpx;
    EWord value = getRandomBigIntegerByBytesSize(0, 4);
    Address address = getRandomBigIntegerByBytesSize(20, 20).toAddress();
    EWord salt = getRandomBigIntegerByBytesSize(0, 4);

    // Keep generating random values until we are in the mxpx && roob case or in the mxpx && !roob
    // case
    do {
      size1 = getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE);
      offset1 = getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE);
      offset2 = getRandomBigIntegerByBytesSize(0, MAX_BYTE_SIZE);

      // size2 is irrelevant for this case
      mxpx = isMxpx(mxpType, size1, offset1);
      roob = isRoob(mxpType, size1, offset1);
    } while (!(triggerRoob && mxpx && roob) && !(!triggerRoob && mxpx && !roob));

    switch (opCode) {
      case MLOAD -> appendOpCodeCall(List.of(offset1), opCode, program);
      case MSTORE, MSTORE8 -> appendOpCodeCall(List.of(value, offset1), opCode, program);
      case LOG0,
          SHA3,
          RETURN,
          REVERT -> // RETURN and REVERT are selected only when isHalting is true
      appendOpCodeCall(List.of(size1, offset1), opCode, program);
      case LOG1 -> appendOpCodeCall(
          Stream.concat(getRandomUpTo32BytesBigIntegers(1).stream(), Stream.of(size1, offset1))
              .collect(Collectors.toList()),
          opCode,
          program);
      case LOG2 -> appendOpCodeCall(
          Stream.concat(getRandomUpTo32BytesBigIntegers(2).stream(), Stream.of(size1, offset1))
              .collect(Collectors.toList()),
          opCode,
          program);
      case LOG3 -> appendOpCodeCall(
          Stream.concat(getRandomUpTo32BytesBigIntegers(3).stream(), Stream.of(size1, offset1))
              .collect(Collectors.toList()),
          opCode,
          program);
      case LOG4 -> appendOpCodeCall(
          Stream.concat(getRandomUpTo32BytesBigIntegers(4).stream(), Stream.of(size1, offset1))
              .collect(Collectors.toList()),
          opCode,
          program);
      case CODECOPY, CALLDATACOPY -> appendOpCodeCall(
          List.of(size1, offset2, offset1), opCode, program);
      case EXTCODECOPY -> appendOpCodeCall(
          List.of(size1, offset2, offset1, EWord.of(address)), opCode, program);
      case CREATE, CREATE2 -> {
        if (opCode == OpCode.CREATE) {
          // CREATE
          appendOpCodeCall(List.of(size1, offset1, value), opCode, program);
        } else {
          // CREATE2
          appendOpCodeCall(List.of(salt, size1, offset1, value), opCode, program);
        }
      }
      default -> {}
    }
  }

  private boolean isRoob(MxpType randomMxpType, EWord size1, EWord offset1) {

    final boolean condition4And5 = offset1.compareTo(TWO_POW_128) >= 0 && !size1.isZero();

    return switch (randomMxpType) {
      case TYPE_2, TYPE_3 -> offset1.compareTo(TWO_POW_128) >= 0;
      case TYPE_4 -> size1.compareTo(TWO_POW_128) >= 0 || condition4And5;
        // We never test TYPE_5 in the randomized tests (CALLs)
      default -> false;
    };
  }

  private boolean isMxpx(MxpType randomMxpType, EWord size1, EWord offset1) {
    EWord maxOffset1 = EWord.ZERO;
    EWord maxOffset2 = EWord.ZERO;
    EWord maxOffset;

    switch (randomMxpType) {
      case TYPE_2 -> maxOffset1 = offset1.add(31);
      case TYPE_3 -> maxOffset1 = offset1;
      case TYPE_4 -> {
        if (!size1.isZero()) {
          maxOffset1 = offset1.add(size1).subtract(1);
        }
      }
        // We never test TYPE_5 in the randomized tests (CALLs)
    }

    maxOffset = maxOffset1.greaterThan(maxOffset2) ? maxOffset1 : maxOffset2;
    return maxOffset.compareTo(TWO_POW_32) >= 0;
  }

  private void appendOpCodeCall(List<Bytes> args, OpCode opCode, BytecodeCompiler program) {
    for (Bytes arg : args) {
      program.push(arg);
    }
    program.op(opCode);
  }

  private void appendOpCodeCall(OpCode randomOpCode, BytecodeCompiler program) {
    appendOpCodeCall(Collections.emptyList(), randomOpCode, program);
  }

  // Generates a BigInteger that requires a random number of bytes to be represented in [minBytes,
  // maxBytes)
  private EWord getRandomBigIntegerByBytesSize(int minBytes, int maxBytes) {
    if (minBytes < 0 || maxBytes > 32 || minBytes > maxBytes) {
      throw new IllegalArgumentException("Invalid input values");
    }
    int minBits = 8 * minBytes;
    int maxBits = 8 * maxBytes;
    int numBits = RAND.nextInt(minBits, maxBits + 1);
    return EWord.of(new BigInteger(numBits == 0 ? 1 : numBits, RAND));
  }

  private List<EWord> getRandomUpTo32BytesBigIntegers(int n) {
    List<EWord> randomBigIntegers = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      randomBigIntegers.add(EWord.of(getRandomBigIntegerByBytesSize(0, 32)));
    }
    return randomBigIntegers;
  }

  private OpCode getRandomOpCodeByType(MxpType mxpType) {
    return switch (mxpType) {
      case TYPE_1 -> opCodesType1[RAND.nextInt(opCodesType1.length)];
      case TYPE_2 -> opCodesType2[RAND.nextInt(opCodesType2.length)];
      case TYPE_3 -> opCodesType3[RAND.nextInt(opCodesType3.length)];
      case TYPE_4 -> opCodesType4[RAND.nextInt(opCodesType4.length)];
      default -> OpCode.MSIZE; // We never enter the default case since we skip MxpType.NONE
    };
  }
}
